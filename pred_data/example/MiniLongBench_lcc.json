{
    "0": {
        "origin_prompt": "Please complete the code given below. \n#!/usr/bin/env python\nfrom apps.webdriver_testing.pages.site_pages import UnisubsPage\nfrom urlparse import urlsplit\nclass VideoPage(UnisubsPage):\n    \"\"\"\n     Video Page contains the common elements in the video page.\n    \"\"\"\n    _URL = \"videos/%s/info/\"  # %s is the unique onsite video id\n    _VIDEO_TITLE = \".main-title a\"\n    _SPEAKER_NAME = \"div.content div div > h4\"\n    _LOCATION = \"div.content div div h4:nth-child(2)\"\n    _DESCRIPTION = \"div#description\"\n    _EMBEDDED_VIDEO = \"div.unisubs-widget div.unisubs-videoTab-container\"\n    _SUBTITLE_MENU = \"a.unisubs-subtitleMeLink span.unisubs-tabTextchoose\"\n    _LIKE_FACEBOOK = \"li.unisubs-facebook-like button\"\n    _POST_FACEBOOK = \"a.facebook\"\n    _POST_TWITTER = \"a.twittter\"\n    _EMAIL_FRIENDS = \"a.email\"\n    _FOLLOW = \"button.follow-button\"\n    #FOLLOW CONFIRMATION\n    _UNFOLLOW_ALL = 'input#unfollow-all-languages-button'\n    _SUBTITLES_OK = 'input#popup_ok'\n    _EMBED_HELP = \"div.unisubs-share h3 a.embed_options_link\"\n    _EMBED_CODE = (\"div#embed-modal.modal div.modal-body form fieldset \"\n        \"textarea\")\n    #TOP TABS\n    _URLS_TAB = 'href=\"?tab=urls\"]'\n    _VIDEO_TAB = 'a[href=\"?tab=video\"]'\n    _COMMENTS_TAB = 'a[href=\"?tab=comments\"]'\n    _ACTIVITY_TAB = 'a[href=\"?tab=activity\"]'\n    _ADD_SUBTITLES = \"a.add_subtitles\"\n    #VIDEO SIDE SECTION\n    _INFO = \"ul#video-menu.left_nav li:nth-child(1) > a\"\n    _ADD_TRANSLATION = \"li.contribute a#add_translation\"\n    _UPLOAD_SUBTITLES = \"a#upload-subtitles-link\"\n    #SUBTITLES_SIDE_SECTION\n    _SUB_LANGUAGES = \"ul#subtitles-menu li\"\n    _STATUS_TAGS = \"span.tags\"\n    #TEAM_SIDE_SECTION\n    _ADD_TO_TEAM_PULLDOWN = (\"ul#moderation-menu.left_nav li div.sort_button \"\n        \"div.arrow\")\n    _TEAM_LINK = (\"ul#moderation-menu.left_nav li div.sort_button ul li \"\n        \"a[href*='%s']\")\n    #ADMIN_SIDE_SECTION\n    _DEBUG_INFO = \"\"\n    _EDIT = \"\"\n    #UPLOAD SUBTITLES DIALOG\n    _SELECT_LANGUAGE = 'select#id_language_code'\n    _TRANSLATE_FROM = 'select#id_from_language_code'\n    _PRIMARY_AUDIO = 'select#id_primary_audio_language_code'\n    _SUBTITLES_FILE = 'input#subtitles-file-field'\n    _IS_COMPLETE = 'input#updload-subtitles-form-is_complete' #checked default\n    _UPLOAD_SUBMIT = 'form#upload-subtitles-form button.green_button'\n    _FEEDBACK_MESSAGE = 'p.feedback-message'\n    _CLOSE = 'div#upload_subs-div a.close'\n    UPLOAD_SUCCESS_TEXT = ('Thank you for uploading. It may take a minute or '\n                           'so for your subtitles to appear.')\n    #TAB FIELDS\n    _COMMENTS_BOX = 'textarea#id_comment_form_content'\n    _ACTIVITY_LIST = 'ul.activity li p'    \n    def open_video_page(self, video_id):\n        self.open_page(self._URL % video_id)\n    def open_video_activity(self, video_id):\n        self.open_video_page(video_id)\n        self.click_by_css(self._ACTIVITY_TAB)\n    def video_title(self):\n        return self.get_text_by_css(self._VIDEO_TITLE)\n    def add_translation(self):\n        self.click_by_css(self._ADD_TRANSLATION)\n    def upload_subtitles(self, \n                         sub_lang, \n                         sub_file,\n                         audio_lang = None,\n                         translated_from = None, \n                         is_complete = True):\n        #Open the dialog\n        self.wait_for_element_visible(self._UPLOAD_SUBTITLES)\n        self.click_by_css(self._UPLOAD_SUBTITLES)\n        #Choose the language\n        self.wait_for_element_visible(self._SELECT_LANGUAGE)\n        self.select_option_by_text(self._SELECT_LANGUAGE, sub_lang)\n        #Set the audio language\n        if audio_lang:\n            self.select_option_by_text(self._PRIMARY_AUDIO, audio_lang)\n        #Set the translation_from field\n        if translated_from:\n            self.select_option_by_text(self._TRANSLATE_FROM, translated_from)\n        #Input the subtitle file\n        self.type_by_css(self._SUBTITLES_FILE, sub_file)\n        #Set complete\n        if not is_complete:\n            self.click_by_css(self._IS_COMPLETE)\n        #Start the upload\n        self.wait_for_element_present(self._UPLOAD_SUBMIT)\n        self.click_by_css(self._UPLOAD_SUBMIT)\n        #Get the the response message\n        self.wait_for_element_present(self._FEEDBACK_MESSAGE, wait_time=20)\n        message_text = self.get_text_by_css(self._FEEDBACK_MESSAGE)\n        #Close the dialog\n        self.click_by_css(self._CLOSE)\n        self.wait_for_element_not_visible(self._CLOSE)\n        return message_text\n    def open_info_page(self):\n        self.click_by_css(self._INFO)\n    def add_video_to_team(self, team_name):\n        self.click_by_css(self._ADD_TO_TEAM_PULLDOWN)\n        self.click_by_css(self._TEAM_LINK % team_name)\n    def video_id(self):\n        page_url = self.browser.current_url\n        url_parts = urlsplit(page_url).path\n        urlfrag = url_parts.split('/')[3]\n        return urlfrag\n    def description_text(self):\n        return self.get_text_by_css(self._DESCRIPTION)\n    def speaker_name(self):\n        return self.get_text_by_css(self._SPEAKER_NAME)\n    def location(self):\n        return self.get_text_by_css(self._LOCATION)\n    def video_embed_present(self):\n        if self.is_element_present(self._EMBEDDED_VIDEO):\n            return True\n    def add_subtitles(self):\n        self.click_by_css(self._ADD_SUBTITLES)\n    def team_slug(self, slug):\n        \"\"\"Return true if the team stub is linked on the video page.\n        \"\"\"\n        team_link = \"a[href*='/teams/%s/']\" % slug\n        if self.is_element_present(team_link):\n            return True\n    def feature_video(self):\n        self.click_link_text('Feature video')\n    def unfeature_video(self):\n        self.click_link_text('Unfeature video')\n    def displays_subtitle_me(self):\n        return self.is_element_visible(self._SUBTITLE_MENU)\n    def click_subtitle_me(self):\n        self.click_by_css(self._SUBTITLE_MENU)\n    def displays_add_subtitles(self):\n        return self.is_element_visible(self._ADD_SUBTITLES)\n    def displays_add_translation(self):\n        return self.is_element_visible(self._ADD_TRANSLATION)\n    def displays_upload_subtitles(self):\n        return self.is_element_visible(self._UPLOAD_SUBTITLES)\n    def follow_text(self):\n        return self.get_text_by_css(self._FOLLOW)\n    def toggle_follow(self, lang=False):\n        self.click_by_css(self._FOLLOW)\n        if lang:\n            self.click_by_css(self._SUBTITLES_OK)\n        else:\n            self.click_by_css(self._UNFOLLOW_ALL)\n    def subtitle_languages(self):\n        langs = []\n        els = self.get_elements_list(self._SUB_LANGUAGES + \" a\")\n        for el in els:\n            langs.append(el.text)\n        return langs\n    def language_status(self, language):\n        els =  self.get_elements_list(self._SUB_LANGUAGES)\n        for el in els:\n            e = el.find_element_by_css_selector(\"a\")\n            self.logger.info(e.text)\nNext line of code:\n",
        "prediction": "   def subtitle_languages(self):\n        langs = []\n        els = self.get_elements_list(self._SUB_LANGUAGES + \" a\")\n        for el in els:\n            langs.append(el.text)\n        return langs",
        "gold": [
            "            if e.text == language:"
        ],
        "time": 3.3505969047546387
    },
    "1": {
        "origin_prompt": "Please complete the code given below. \n/*\n * jPOS Project [http://jpos.org]\n * Copyright (C) 2000-2015 Alejandro P. Revilla\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.jpos.space;\nimport java.io.*;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport com.sleepycat.je.*;\nimport com.sleepycat.persist.EntityStore; \nimport com.sleepycat.persist.StoreConfig; \nimport com.sleepycat.persist.EntityCursor;\nimport com.sleepycat.persist.PrimaryIndex;\nimport com.sleepycat.persist.SecondaryIndex;\nimport com.sleepycat.persist.model.Entity;\nimport com.sleepycat.persist.model.Persistent;\nimport com.sleepycat.persist.model.PrimaryKey;\nimport com.sleepycat.persist.model.SecondaryKey;\nimport com.sleepycat.persist.model.Relationship;\nimport java.util.HashSet;\nimport java.util.concurrent.TimeUnit;\nimport org.jpos.util.Log;\nimport org.jpos.util.Loggeable;\n/**\n * BerkeleyDB Jave Edition based persistent space implementation\n *\n * @author Alejandro Revilla\n * @since 1.6.5\n */\n@SuppressWarnings(\"unchecked\")\npublic class JESpace<K,V> extends Log implements LocalSpace<K,V>, Loggeable, Runnable {\n    Environment dbe = null;\n    EntityStore store = null;\n    PrimaryIndex<Long, Ref> pIndex = null;\n    PrimaryIndex<Long,GCRef> gcpIndex = null;\n    SecondaryIndex<String,Long, Ref> sIndex = null;\n    SecondaryIndex<Long,Long,GCRef> gcsIndex = null;\n    Semaphore gcSem = new Semaphore(1);\n    LocalSpace<Object,SpaceListener> sl;\n    private static final long NRD_RESOLUTION = 500L;\n    public static final long GC_DELAY = 60*1000L;\n    private Future gcTask;\n    static final Map<String,Space> spaceRegistrar = \n        new HashMap<String,Space> ();\n    public JESpace(String name, String path) throws SpaceError {\n        super();\n        try {\n            EnvironmentConfig envConfig = new EnvironmentConfig();\n            StoreConfig storeConfig = new StoreConfig();\n            envConfig.setAllowCreate (true);\n            envConfig.setTransactional(true);\n            // envConfig.setTxnTimeout(5L, TimeUnit.MINUTES);\n            envConfig.setLockTimeout(5, TimeUnit.SECONDS);\n            storeConfig.setAllowCreate (true);\n            storeConfig.setTransactional (true);\n            File dir = new File(path);\n            dir.mkdirs();\n            dbe = new Environment (dir, envConfig);\n            store = new EntityStore (dbe, name, storeConfig);\n            pIndex = store.getPrimaryIndex (Long.class, Ref.class);\n            gcpIndex = store.getPrimaryIndex (Long.class, GCRef.class);\n            sIndex = store.getSecondaryIndex (pIndex, String.class, \"key\");\n            gcsIndex = store.getSecondaryIndex (gcpIndex, Long.class, \"expires\");\n            gcTask = SpaceFactory.getGCExecutor().scheduleAtFixedRate(this, GC_DELAY, GC_DELAY, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        }\n    }\n    public void out (K key, V value) {\n        out (key, value, 0L);\n    }\n    public void out (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            if (timeout > 0L)\n                gcpIndex.putNoReturn (\n                    new GCRef (ref.getId(), ref.getExpiration())\n                );\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            pIndex.delete (ref.getId());\n            ref.reverseId();\n            pIndex.put (ref);\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value) {\n        push (key, value, 0L);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V rdp (Object key) {\n        try {\n            return (V) getObject (key, false);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key) {\n        Object obj;\n        while ((obj = inp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = inp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key) {\n        Object obj;\n        while ((obj = rdp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    public synchronized void nrd  (Object key) {\n        while (rdp (key) != null) {\n            try {\n                this.wait (NRD_RESOLUTION);\n            } catch (InterruptedException ignored) { }\n        }\n    }\n    public synchronized V nrd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) != null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (Math.min(NRD_RESOLUTION, end - now));\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V inp (Object key) {\n        try {\n            return (V) getObject (key, true);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    public boolean existAny (Object[] keys) {\n        for (Object key : keys) {\n            if (rdp(key) != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public boolean existAny (Object[] keys, long timeout) {\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((now = System.currentTimeMillis()) < end) {\n            if (existAny (keys))\n                return true;\n            synchronized (this) {\n                try {\n                    wait (end - now);\n                } catch (InterruptedException ignored) { }\n            }\n        }\n        return false;\n    }\n    public synchronized void put (K key, V value, long timeout) {\n        while (inp (key) != null)\n            ;\n        out (key, value, timeout);\n    }\n    public synchronized void put (K key, V value) {\n        while (inp (key) != null)\n            ;\n        out (key, value);\n    }\n    public void gc () throws DatabaseException {\n        Transaction txn = null;\n        EntityCursor<GCRef> cursor = null;\n        try {\n            if (!gcSem.tryAcquire())\n                return;\n            txn = dbe.beginTransaction (null, null);\n            cursor = gcsIndex.entities (\n                txn, 0L, true, System.currentTimeMillis(), false, null\n            );\n            for (GCRef gcRef: cursor) {\n                pIndex.delete (gcRef.getId());\n                cursor.delete ();\n            }\n            cursor.close();\n            cursor = null;\n            txn.commit();\n            txn = null;\n            if (sl != null) {\n                synchronized (this) {\n                    if (sl != null && sl.getKeySet().isEmpty())\n                        sl = null;\n                }\n            }\n        } finally {\n            if (cursor != null)\n                cursor.close();\n            if (txn != null)\n                abort (txn);\n            gcSem.release();\n        }\n    }\n    public void run() {\n        try {\n            gc();\n        } catch (DatabaseException e) {\n            warn(e);\n        }\n    }\n    public void close () throws DatabaseException {\n        gcSem.acquireUninterruptibly();\n        gcTask.cancel(false);\n        while (!gcTask.isDone()) {\n            try {\n                Thread.sleep(500L);\n            } catch (InterruptedException ignored) { }\n        }\n        store.close ();\n        dbe.close();\n    }\n    public synchronized static JESpace getSpace (String name, String path)\n    {\n        JESpace sp = (JESpace) spaceRegistrar.get (name);\n        if (sp == null) {\nNext line of code:\n",
        "prediction": "           sp = new Space (name, path);\n            spaceRegistrar.register (name, sp);\n        }\n        return sp;\n    }\n    public static void main (String[] args) {\n        String name = \"space\";\n        String path = \"space.db\";",
        "gold": [
            "            sp = new JESpace(name, path);"
        ],
        "time": 3.3634097576141357
    },
    "2": {
        "origin_prompt": "Please complete the code given below. \n/**\n * Genji Scrum Tool and Issue Tracker\n * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions\n * <a href=\"http://www.trackplus.com\">Genji Scrum Tool</a>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n/* $Id:$ */\npackage com.aurel.track.fieldType.runtime.system.select;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport com.aurel.track.admin.customize.lists.systemOption.StatusBL;\nimport com.aurel.track.admin.customize.projectType.ProjectTypesBL;\nimport com.aurel.track.beans.IBeanID;\nimport com.aurel.track.beans.ILabelBean;\nimport com.aurel.track.beans.ISerializableLabelBean;\nimport com.aurel.track.beans.TPersonBean;\nimport com.aurel.track.beans.TProjectBean;\nimport com.aurel.track.beans.TStateBean;\nimport com.aurel.track.beans.TWorkItemBean;\nimport com.aurel.track.exchange.track.NameMappingBL;\nimport com.aurel.track.fieldType.bulkSetters.IBulkSetter;\nimport com.aurel.track.fieldType.constants.SystemFields;\nimport com.aurel.track.fieldType.fieldChange.FieldChangeValue;\nimport com.aurel.track.fieldType.runtime.base.LookupContainer;\nimport com.aurel.track.fieldType.runtime.base.SelectContext;\nimport com.aurel.track.fieldType.runtime.base.SerializableBeanAllowedContext;\nimport com.aurel.track.fieldType.runtime.matchers.design.IMatcherValue;\nimport com.aurel.track.fieldType.runtime.matchers.design.MatcherDatasourceContext;\nimport com.aurel.track.fieldType.runtime.matchers.run.MatcherContext;\nimport com.aurel.track.item.massOperation.MassOperationContext;\nimport com.aurel.track.item.massOperation.MassOperationValue;\nimport com.aurel.track.item.workflow.execute.StatusWorkflow;\nimport com.aurel.track.item.workflow.execute.WorkflowContext;\nimport com.aurel.track.lucene.LuceneUtil;\nimport com.aurel.track.resources.LocalizeUtil;\nimport com.aurel.track.util.GeneralUtils;\npublic class SystemStateRT extends SystemSelectBaseLocalizedRT{\n\t/**\n\t * In case of a custom picker or system selects select the list type\n\t * Used by saving custom pickers and \n\t * explicit history for both system and custom fields\n\t * @return\n\t */\n\t@Override\n\tpublic Integer getSystemOptionType() {\n\t\treturn SystemFields.INTEGER_STATE;\n\t}\n\t\n\t/**\n\t * Loads the edit data source for state list \n\t * @param selectContext\n\t * @return\n\t */\n\t@Override\n\tpublic List loadEditDataSource(SelectContext selectContext) {\n\t\tTWorkItemBean workItemBean = selectContext.getWorkItemBean();\n\t\tInteger person = selectContext.getPersonID();\n\t\tList<TStateBean> dataSource;\n\t\tif (workItemBean.isAccessLevelFlag()) {\n\t\t\t//for private issue do not make workflow limitations\n\t\t\tdataSource = StatusBL.getByProjectTypeIssueTypeAssignments(workItemBean.getProjectID(),\n\t\t\t\t\tworkItemBean.getListTypeID(), workItemBean.getStateID());\n\t\t} else {\n\t\t\tdataSource = StatusWorkflow.loadStatesTo(workItemBean.getProjectID(),\n\t\t\t\t\tworkItemBean.getListTypeID(), workItemBean.getStateID(), person, workItemBean, null);\n\t\t\t}\n\t\treturn LocalizeUtil.localizeDropDownList(dataSource, selectContext.getLocale());\n\t}\n\t\n\t/**\n\t * Loads the create data source for state list\n\t * The list should contain a single value, \n\t * consequently the initial entry can't be changed \n\t * even if it will be (accidentally) shown in the create issue screen\t\n\t * @param selectContext\n\t * @return\n\t */\n\t@Override\n\tpublic List loadCreateDataSource(SelectContext selectContext) {\n\t\tTWorkItemBean workItemBean = selectContext.getWorkItemBean();\n\t\tList<TStateBean> dataSource = StatusWorkflow.loadInitialStates(workItemBean.getProjectID(),\n\t\t\t\tworkItemBean.getListTypeID(), workItemBean, selectContext.getPersonID(), null);\n\t\treturn LocalizeUtil.localizeDropDownList(dataSource, selectContext.getLocale());\n\t}\n\t\t\n\t/**\n\t * Loads the datasource for the matcher\n\t * used by select fields to get the possible values\n\t * It will be called from both field expressions and upper selects \n\t * The value can be a list for simple select or a map of lists for composite selects or a tree\n\t * @param matcherValue\n\t * @param matcherDatasourceContext the data source may be project dependent. \n\t * @param parameterCode for composite selects\n\t * @return the datasource (list or tree)\n\t */\t\n\t@Override\n\tpublic Object getMatcherDataSource(IMatcherValue matcherValue, MatcherDatasourceContext matcherDatasourceContext, Integer parameterCode) {\n\t\tList<TStateBean> datasource;\n\t\tInteger[] projectTypeIDs = ProjectTypesBL.getProjectTypeIDsForProjectIDs(matcherDatasourceContext.getProjectIDs());\n\t\tif (projectTypeIDs == null || projectTypeIDs.length==0) {\n\t\t\tdatasource = (List)StatusBL.loadAll();\n\t\t} else {\n\t\t\tdatasource =(List)StatusBL.loadAllowedByProjectTypesAndIssueTypes(projectTypeIDs, matcherDatasourceContext.getItemTypeIDs());\n\t\t}\n\t\tLocale locale = matcherDatasourceContext.getLocale();\n\t\tLocalizeUtil.localizeDropDownList(datasource, locale);\n\t\tif (matcherDatasourceContext.isWithParameter()) {\n\t\t\tdatasource.add((TStateBean)getLabelBean(MatcherContext.PARAMETER, locale));\n\t\t}\t\n\t\tif (matcherValue!=null) {\n\t\t\tif (matcherDatasourceContext.isInitValueIfNull()) {\n\t\t\t\t//from field expression\n\t\t\t\tObject value = matcherValue.getValue();\n\t\t\t\tif (value==null && datasource!=null && !datasource.isEmpty()) {\n\t\t\t\t\tmatcherValue.setValue(new Integer[] {datasource.get(0).getObjectID()});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//from upper select\n\t\t\t\tif (matcherDatasourceContext.isFirstLoad()) {\n\t\t\t\t\t//select the not closed states\n\t\t\t\t\tList<Integer> notClosedStates = new ArrayList<Integer>(); \n\t\t\t\t\tfor ( int i = 0; i < datasource.size(); i++) { \n\t\t\t\t\t\tTStateBean stateBean = datasource.get(i); \n\t\t\t\t\t\tInteger stateFlag = stateBean.getStateflag();\n\t\t\t\t\t\t//stateflag null for $Parameter \n\t\t\t\t\t\tif (stateFlag!=null && TStateBean.STATEFLAGS.CLOSED!=stateFlag.intValue() ) {\n\t\t\t\t\t\t\tnotClosedStates.add(stateBean.getObjectID());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInteger[] selectedStates = GeneralUtils.createIntegerArrFromCollection(notClosedStates);\n\t\t\t\t\tmatcherValue.setValue(selectedStates);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn datasource;\n\t}\n\t\n\t/**\n\t * Loads the IBulkSetter object for configuring the bulk operation\n\t * @param fieldID\n\t */\n\t@Override\n\tpublic IBulkSetter getBulkSetterDT(Integer fieldID) {\n\t\tIBulkSetter bulkSetter = super.getBulkSetterDT(fieldID);\n\t\t//should be verified against project types and workflow\n\t\tbulkSetter.setSelectValueSurelyAllowed(false);\n\t\treturn bulkSetter;\n\t}\n\t\n\t/**\n\t * Loads the datasource for the mass operation\n\t * used mainly by select fields to get \n\t * the all possible options for a field (system or custom select) \n\t * It also sets a value if not yet selected\n\t * The value can be a List for simple select or a Map of lists for composite selects  \n\t * @param massOperationContext\n\t * @param massOperationValue\n\t * @param parameterCode\n\t * @param personBean\n\t * @param locale\n\t * @return\n\t */\n\t@Override\n\tpublic void loadBulkOperationDataSource(MassOperationContext massOperationContext,\n\t\t\tMassOperationValue massOperationValue,\n\t\t\tInteger parameterCode, TPersonBean personBean, Locale locale) {\n\t\tList<IBeanID> datasource = (List)StatusBL.loadAll(locale);\n\t\tmassOperationValue.setPossibleValues(datasource);\n\t\tmassOperationValue.setValue(getBulkSelectValue(massOperationContext,\n\t\t\t\tmassOperationValue.getFieldID(), null, \n\t\t\t\t(Integer)massOperationValue.getValue(), \n\t\t\t\t(List<IBeanID>)massOperationValue.getPossibleValues()));\n\t}\n\t\n\t/**\n\t * Loads the datasource and value for configuring the field change\n\t * @param workflowContext\n\t * @param fieldChangeValue\n\t * @param parameterCode\n\t * @param personBean\n\t * @param locale\n\t */\n\t@Override\n\tpublic void loadFieldChangeDatasourceAndValue(WorkflowContext workflowContext,\n\t\t\tFieldChangeValue fieldChangeValue, \n\t\t\tInteger parameterCode, TPersonBean personBean, Locale locale) {\n\t\tList<TStateBean> datasource = null;\n\t\tInteger itemTypeID = workflowContext.getItemTypeID();\n\t\tInteger projectID = workflowContext.getProjectID();\n\t\tInteger projectTypeID = workflowContext.getProjectTypeID();\n\t\tif (projectTypeID==null && projectID!=null) {\n\t\t\tTProjectBean projectBean = LookupContainer.getProjectBean(projectID);\n\t\t\tif (projectBean!=null) {\n\t\t\t\tprojectTypeID = projectBean.getProjectType();\n\t\t\t}\n\t\t}\n\t\tif (projectTypeID==null || itemTypeID==null) {\n\t\t\tdatasource = StatusBL.loadAll();\n\t\t} else {\n\t\t\tdatasource = StatusBL.getByProjectTypeIssueTypeAssignments(projectTypeID, itemTypeID, (Integer)fieldChangeValue.getValue());\n\t\t}\n\t\tfieldChangeValue.setPossibleValues(LocalizeUtil.localizeDropDownList(datasource, locale));\n\t\tfieldChangeValue.setValue(getBulkSelectValue(null,\n\t\t\t\tfieldChangeValue.getFieldID(), null, \n\t\t\t\t(Integer)fieldChangeValue.getValue(), \n\t\t\t\t(List<IBeanID>)fieldChangeValue.getPossibleValues()));\n\t}\n\t\n\t/**\n\t * Get the ILabelBean by primary key \n\t * @return\n\t */\n\t@Override\n\tpublic ILabelBean getLabelBean(Integer optionID, Locale locale) {\n\t\tif (optionID!=null && \n\t\t\t\toptionID.equals(MatcherContext.PARAMETER)) {\n\t\t\tTStateBean stateBean = new TStateBean();\n\t\t\tstateBean.setLabel(MatcherContext.getLocalizedParameter(locale));\n\t\t\tstateBean.setObjectID(optionID);\n\t\t\treturn stateBean;\n\t\t}\n\t\treturn StatusBL.loadByPrimaryKey(optionID);\n\t}\n\t\n\t/**\n\t * Returns the lookup entity type related to the fieldType\n\t * @return\n\t */\n\t@Override\n\tpublic int getLookupEntityType() {\n\t\treturn LuceneUtil.LOOKUPENTITYTYPES.STATE;\n\t}\n\t\n\t/**\n\t * Creates a new empty serializableLabelBean\n\t * @return\n\t */\n\t@Override\n\tpublic ISerializableLabelBean getNewSerializableLabelBean() {\n\t\treturn new TStateBean();\n\t}\n\t\n\t/**\n\t * Gets the ID by the label\n\t * @param fieldID\n\t * @param projectID\n\t * @param issueTypeID\n\t * @param locale\n\t * @param label\n\t * @param lookupBeansMap\n\t * @param componentPartsMap\n\t * @return\n\t */\n\t@Override\n\tpublic Integer getLookupIDByLabel(Integer fieldID,\n\t\t\tInteger projectID, Integer issueTypeID, \n\t\t\tLocale locale, String label,\n\t\t\tMap<String, ILabelBean> lookupBeansMap, Map<Integer, Integer> componentPartsMap) {\n\t\tInteger objectID = NameMappingBL.getExactMatch(label, lookupBeansMap);\n\t\tif (objectID!=null) {\n\t\t\treturn objectID;\n\t\t}\n\t\tTStateBean stateBean = null;\n\t\tInteger primaryKey = LocalizeUtil.getDropDownPrimaryKeyFromLocalizedText(\n\t\t\t\tnew TStateBean().getKeyPrefix(), label, locale);\n\t\tif (primaryKey!=null) {\n\t\t\tstateBean = LookupContainer.getStatusBean(primaryKey);\n\t\t\tif (stateBean!=null) {\n\t\t\t\treturn primaryKey;\n\t\t\t}\n\t\t}\n\t\tList<TStateBean> stateBeans = StatusBL.loadByLabel(label); \n\t\tif (stateBeans!=null && !stateBeans.isEmpty()) {\n\t\t\tstateBean =  stateBeans.get(0);\n\t\t}\n\t\tif (stateBean!=null) {\n\t\t\treturn stateBean.getObjectID();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Whether the lookupID found by label is allowed in \n\t * the context of serializableBeanAllowedContext\n\t * In excel the lookup entries are not limited by the user interface controls\n\t * This method should return false if the lookupID\n\t * is not allowed (for ex. a person without manager role was set as manager) \n\t * @param objectID\n\t * @param serializableBeanAllowedContext\n\t * @return\n\t */\n\t@Override\n\tpublic boolean lookupBeanAllowed(Integer objectID, \n\t\t\tSerializableBeanAllowedContext serializableBeanAllowedContext) {\n\t\tList<TStateBean> stateBeansList=null;\n\t\tInteger projectID = serializableBeanAllowedContext.getProjectID();\n\t\tInteger issueTypeID = serializableBeanAllowedContext.getIssueTypeID();\nNext line of code:\n",
        "prediction": "\t\tif (projectID!=null && issueTypeID!=null) {\n\t\t\tstateBeansList = StatusBL.loadByProjectTypeIssueType(projectID, issueTypeID);\n\t\t} else {\n\t\t\tstateBeansList = StatusBL.loadBy",
        "gold": [
            "\t\tif (projectID==null || issueTypeID==null) {"
        ],
        "time": 3.3601057529449463
    },
    "3": {
        "origin_prompt": "Please complete the code given below. \n# Copyright 2009-2013 Canonical Ltd.  This software is licensed under the\n# GNU Affero General Public License version 3 (see the file LICENSE).\n\"\"\"Browser views for products.\"\"\"\n__metaclass__ = type\n__all__ = [\n    'ProductAddSeriesView',\n    'ProductAddView',\n    'ProductAddViewBase',\n    'ProductAdminView',\n    'ProductBrandingView',\n    'ProductBugsMenu',\n    'ProductConfigureBase',\n    'ProductConfigureAnswersView',\n    'ProductConfigureBlueprintsView',\n    'ProductDownloadFileMixin',\n    'ProductDownloadFilesView',\n    'ProductEditPeopleView',\n    'ProductEditView',\n    'ProductFacets',\n    'ProductInvolvementView',\n    'ProductNavigation',\n    'ProductNavigationMenu',\n    'ProductOverviewMenu',\n    'ProductPackagesView',\n    'ProductPackagesPortletView',\n    'ProductPurchaseSubscriptionView',\n    'ProductRdfView',\n    'ProductReviewLicenseView',\n    'ProductSeriesSetView',\n    'ProductSetBreadcrumb',\n    'ProductSetFacets',\n    'ProductSetNavigation',\n    'ProductSetReviewLicensesView',\n    'ProductSetView',\n    'ProductSpecificationsMenu',\n    'ProductView',\n    'SortSeriesMixin',\n    'ProjectAddStepOne',\n    'ProjectAddStepTwo',\n    ]\nfrom operator import attrgetter\nfrom lazr.delegates import delegates\nfrom lazr.restful.interface import copy_field\nfrom lazr.restful.interfaces import IJSONRequestCache\nfrom z3c.ptcompat import ViewPageTemplateFile\nfrom zope.component import getUtility\nfrom zope.event import notify\nfrom zope.formlib import form\nfrom zope.formlib.interfaces import WidgetInputError\nfrom zope.formlib.widget import CustomWidgetFactory\nfrom zope.formlib.widgets import (\n    CheckBoxWidget,\n    TextAreaWidget,\n    TextWidget,\n    )\nfrom zope.interface import (\n    implements,\n    Interface,\n    )\nfrom zope.lifecycleevent import ObjectCreatedEvent\nfrom zope.schema import (\n    Bool,\n    Choice,\n    )\nfrom zope.schema.vocabulary import (\n    SimpleTerm,\n    SimpleVocabulary,\n    )\nfrom lp import _\nfrom lp.answers.browser.faqtarget import FAQTargetNavigationMixin\nfrom lp.answers.browser.questiontarget import (\n    QuestionTargetFacetMixin,\n    QuestionTargetTraversalMixin,\n    )\nfrom lp.app.browser.launchpadform import (\n    action,\n    custom_widget,\n    LaunchpadEditFormView,\n    LaunchpadFormView,\n    ReturnToReferrerMixin,\n    safe_action,\n    )\nfrom lp.app.browser.lazrjs import (\n    BooleanChoiceWidget,\n    InlinePersonEditPickerWidget,\n    TextLineEditorWidget,\n    )\nfrom lp.app.browser.multistep import (\n    MultiStepView,\n    StepView,\n    )\nfrom lp.app.browser.stringformatter import FormattersAPI\nfrom lp.app.browser.tales import (\n    format_link,\n    MenuAPI,\n    )\nfrom lp.app.enums import (\n    InformationType,\n    PROPRIETARY_INFORMATION_TYPES,\n    PUBLIC_PROPRIETARY_INFORMATION_TYPES,\n    ServiceUsage,\n    )\nfrom lp.app.errors import NotFoundError\nfrom lp.app.interfaces.headings import IEditableContextTitle\nfrom lp.app.interfaces.launchpad import ILaunchpadCelebrities\nfrom lp.app.utilities import json_dump_information_types\nfrom lp.app.vocabularies import InformationTypeVocabulary\nfrom lp.app.widgets.date import DateWidget\nfrom lp.app.widgets.itemswidgets import (\n    CheckBoxMatrixWidget,\n    LaunchpadRadioWidget,\n    LaunchpadRadioWidgetWithDescription,\n    )\nfrom lp.app.widgets.popup import PersonPickerWidget\nfrom lp.app.widgets.product import (\n    GhostWidget,\n    LicenseWidget,\n    ProductNameWidget,\n    )\nfrom lp.app.widgets.textwidgets import StrippedTextWidget\nfrom lp.blueprints.browser.specificationtarget import (\n    HasSpecificationsMenuMixin,\n    )\nfrom lp.bugs.browser.bugtask import (\n    BugTargetTraversalMixin,\n    get_buglisting_search_filter_url,\n    )\nfrom lp.bugs.browser.structuralsubscription import (\n    expose_structural_subscription_data_to_js,\n    StructuralSubscriptionMenuMixin,\n    StructuralSubscriptionTargetTraversalMixin,\n    )\nfrom lp.bugs.interfaces.bugtask import RESOLVED_BUGTASK_STATUSES\nfrom lp.code.browser.branchref import BranchRef\nfrom lp.code.browser.sourcepackagerecipelisting import HasRecipesMenuMixin\nfrom lp.registry.browser import (\n    add_subscribe_link,\n    BaseRdfView,\n    )\nfrom lp.registry.browser.announcement import HasAnnouncementsView\nfrom lp.registry.browser.branding import BrandingChangeView\nfrom lp.registry.browser.menu import (\n    IRegistryCollectionNavigationMenu,\n    RegistryCollectionActionMenuBase,\n    )\nfrom lp.registry.browser.pillar import (\n    PillarBugsMenu,\n    PillarInvolvementView,\n    PillarNavigationMixin,\n    PillarViewMixin,\n    )\nfrom lp.registry.browser.productseries import get_series_branch_error\nfrom lp.registry.interfaces.pillar import IPillarNameSet\nfrom lp.registry.interfaces.product import (\n    IProduct,\n    IProductReviewSearch,\n    IProductSet,\n    License,\n    LicenseStatus,\n    )\nfrom lp.registry.interfaces.productrelease import (\n    IProductRelease,\n    IProductReleaseSet,\n    )\nfrom lp.registry.interfaces.productseries import IProductSeries\nfrom lp.registry.interfaces.series import SeriesStatus\nfrom lp.registry.interfaces.sourcepackagename import ISourcePackageNameSet\nfrom lp.services.config import config\nfrom lp.services.database.decoratedresultset import DecoratedResultSet\nfrom lp.services.feeds.browser import FeedsMixin\nfrom lp.services.fields import (\n    PillarAliases,\n    PublicPersonChoice,\n    )\nfrom lp.services.librarian.interfaces import ILibraryFileAliasSet\nfrom lp.services.propertycache import cachedproperty\nfrom lp.services.webapp import (\n    ApplicationMenu,\n    canonical_url,\n    enabled_with_permission,\n    LaunchpadView,\n    Link,\n    Navigation,\n    sorted_version_numbers,\n    StandardLaunchpadFacets,\n    stepthrough,\n    stepto,\n    structured,\n    )\nfrom lp.services.webapp.authorization import check_permission\nfrom lp.services.webapp.batching import BatchNavigator\nfrom lp.services.webapp.breadcrumb import Breadcrumb\nfrom lp.services.webapp.interfaces import UnsafeFormGetSubmissionError\nfrom lp.services.webapp.menu import NavigationMenu\nfrom lp.services.worlddata.helpers import browser_languages\nfrom lp.services.worlddata.interfaces.country import ICountry\nfrom lp.translations.browser.customlanguagecode import (\n    HasCustomLanguageCodesTraversalMixin,\n    )\nOR = ' OR '\nSPACE = ' '\nclass ProductNavigation(\n    Navigation, BugTargetTraversalMixin,\n    FAQTargetNavigationMixin, HasCustomLanguageCodesTraversalMixin,\n    QuestionTargetTraversalMixin, StructuralSubscriptionTargetTraversalMixin,\n    PillarNavigationMixin):\n    usedfor = IProduct\n    @stepto('.bzr')\n    def dotbzr(self):\n        if self.context.development_focus.branch:\n            return BranchRef(self.context.development_focus.branch)\n        else:\n            return None\n    @stepthrough('+spec')\n    def traverse_spec(self, name):\n        spec = self.context.getSpecification(name)\n        if not check_permission('launchpad.LimitedView', spec):\n            return None\n        return spec\n    @stepthrough('+milestone')\n    def traverse_milestone(self, name):\n        return self.context.getMilestone(name)\n    @stepthrough('+release')\n    def traverse_release(self, name):\n        return self.context.getRelease(name)\n    @stepthrough('+announcement')\n    def traverse_announcement(self, name):\n        return self.context.getAnnouncement(name)\n    @stepthrough('+commercialsubscription')\n    def traverse_commercialsubscription(self, name):\n        return self.context.commercial_subscription\n    def traverse(self, name):\n        return self.context.getSeries(name)\nclass ProductSetNavigation(Navigation):\n    usedfor = IProductSet\n    def traverse(self, name):\n        product = self.context.getByName(name)\n        if product is None:\n            raise NotFoundError(name)\n        return self.redirectSubTree(canonical_url(product))\nclass ProductLicenseMixin:\n    \"\"\"Adds licence validation and requests reviews of licences.\n    Subclasses must inherit from Launchpad[Edit]FormView as well.\n    Requires the \"product\" attribute be set in the child\n    classes' action handler.\n    \"\"\"\n    def validate(self, data):\n        \"\"\"Validate 'licenses' and 'license_info'.\n        'licenses' must not be empty unless the product already\n        exists and never has had a licence set.\n        'license_info' must not be empty if \"Other/Proprietary\"\n        or \"Other/Open Source\" is checked.\n        \"\"\"\n        licenses = data.get('licenses', [])\n        license_widget = self.widgets.get('licenses')\n        if (len(licenses) == 0 and license_widget is not None):\n            self.setFieldError(\n                'licenses',\n                'You must select at least one licence.  If you select '\n                'Other/Proprietary or Other/OpenSource you must include a '\n                'description of the licence.')\n        elif License.OTHER_PROPRIETARY in licenses:\n            if not data.get('license_info'):\n                self.setFieldError(\n                    'license_info',\n                    'A description of the \"Other/Proprietary\" '\n                    'licence you checked is required.')\n        elif License.OTHER_OPEN_SOURCE in licenses:\n            if not data.get('license_info'):\n                self.setFieldError(\n                    'license_info',\n                    'A description of the \"Other/Open Source\" '\n                    'licence you checked is required.')\n        else:\n            # Launchpad is ok with all licenses used in this project.\n            pass\nclass ProductFacets(QuestionTargetFacetMixin, StandardLaunchpadFacets):\n    \"\"\"The links that will appear in the facet menu for an IProduct.\"\"\"\n    usedfor = IProduct\n    enable_only = ['overview', 'bugs', 'answers', 'specifications',\n                   'translations', 'branches']\n    links = StandardLaunchpadFacets.links\n    def overview(self):\n        text = 'Overview'\n        summary = 'General information about %s' % self.context.displayname\n        return Link('', text, summary)\n    def bugs(self):\n        text = 'Bugs'\n        summary = 'Bugs reported about %s' % self.context.displayname\n        return Link('', text, summary)\n    def branches(self):\n        text = 'Code'\n        summary = 'Branches for %s' % self.context.displayname\n        return Link('', text, summary)\n    def specifications(self):\n        text = 'Blueprints'\n        summary = 'Feature specifications for %s' % self.context.displayname\n        return Link('', text, summary)\n    def translations(self):\n        text = 'Translations'\n        summary = 'Translations of %s in Launchpad' % self.context.displayname\n        return Link('', text, summary)\nclass ProductInvolvementView(PillarInvolvementView):\n    \"\"\"Encourage configuration of involvement links for projects.\"\"\"\n    has_involvement = True\n    @property\n    def visible_disabled_link_names(self):\n        \"\"\"Show all disabled links...except blueprints\"\"\"\n        involved_menu = MenuAPI(self).navigation\n        all_links = involved_menu.keys()\n        # The register blueprints link should not be shown since its use is\n        # not encouraged.\n        all_links.remove('register_blueprint')\n        return all_links\n    @cachedproperty\n    def configuration_states(self):\n        \"\"\"Create a dictionary indicating the configuration statuses.\n        Each app area will be represented in the return dictionary, except\n        blueprints which we are not currently promoting.\n        \"\"\"\n        states = {}\n        states['configure_bugtracker'] = (\n            self.context.bug_tracking_usage != ServiceUsage.UNKNOWN)\n        states['configure_answers'] = (\n            self.context.answers_usage != ServiceUsage.UNKNOWN)\n        states['configure_translations'] = (\n            self.context.translations_usage != ServiceUsage.UNKNOWN)\n        states['configure_codehosting'] = (\n            self.context.codehosting_usage != ServiceUsage.UNKNOWN)\n        return states\n    @property\n    def configuration_links(self):\n        \"\"\"The enabled involvement links.\n        Returns a list of dicts keyed by:\n        'link' -- the menu link, and\n        'configured' -- a boolean representing the configuration status.\n        \"\"\"\n        overview_menu = MenuAPI(self.context).overview\n        series_menu = MenuAPI(self.context.development_focus).overview\n        configuration_names = [\n            'configure_bugtracker',\n            'configure_answers',\n            'configure_translations',\n            #'configure_blueprints',\n            ]\n        config_list = []\n        config_statuses = self.configuration_states\n        for key in configuration_names:\n            config_list.append(dict(link=overview_menu[key],\n                                    configured=config_statuses[key]))\n        # Add the branch configuration in separately.\n        set_branch = series_menu['set_branch']\n        set_branch.text = 'Configure project branch'\n        set_branch.summary = \"Specify the location of this project's code.\"\n        config_list.append(\n            dict(link=set_branch,\n                 configured=config_statuses['configure_codehosting']))\n        return config_list\n    @property\n    def registration_completeness(self):\n        \"\"\"The percent complete for registration.\"\"\"\n        config_statuses = self.configuration_states\n        configured = sum(1 for val in config_statuses.values() if val)\n        scale = 100\n        done = int(float(configured) / len(config_statuses) * scale)\n        undone = scale - done\n        return dict(done=done, undone=undone)\n    @property\n    def registration_done(self):\n        \"\"\"A boolean indicating that the services are fully configured.\"\"\"\n        return (self.registration_completeness['done'] == 100)\nclass ProductNavigationMenu(NavigationMenu):\n    usedfor = IProduct\n    facet = 'overview'\n    links = [\n        'details',\n        'announcements',\n        'downloads',\n        ]\n    def details(self):\n        text = 'Details'\n        return Link('', text)\n    def announcements(self):\n        text = 'Announcements'\n        return Link('+announcements', text)\n    def downloads(self):\n        text = 'Downloads'\n        return Link('+download', text)\nclass ProductEditLinksMixin(StructuralSubscriptionMenuMixin):\n    \"\"\"A mixin class for menus that need Product edit links.\"\"\"\n    @enabled_with_permission('launchpad.Edit')\n    def edit(self):\n        text = 'Change details'\n        return Link('+edit', text, icon='edit')\n    @enabled_with_permission('launchpad.BugSupervisor')\n    def configure_bugtracker(self):\n        text = 'Configure bug tracker'\n        summary = 'Specify where bugs are tracked for this project'\n        return Link('+configure-bugtracker', text, summary, icon='edit')\n    @enabled_with_permission('launchpad.TranslationsAdmin')\n    def configure_translations(self):\n        text = 'Configure translations'\n        summary = 'Allow users to submit translations for this project'\n        return Link('+configure-translations', text, summary, icon='edit')\n    @enabled_with_permission('launchpad.Edit')\n    def configure_answers(self):\n        text = 'Configure support tracker'\n        summary = 'Allow users to ask questions on this project'\n        return Link('+configure-answers', text, summary, icon='edit')\n    @enabled_with_permission('launchpad.Edit')\n    def configure_blueprints(self):\n        text = 'Configure blueprints'\n        summary = 'Enable tracking of feature planning.'\n        return Link('+configure-blueprints', text, summary, icon='edit')\n    @enabled_with_permission('launchpad.Edit')\n    def branding(self):\n        text = 'Change branding'\n        return Link('+branding', text, icon='edit')\n    @enabled_with_permission('launchpad.Edit')\n    def reassign(self):\n        text = 'Change people'\n        return Link('+edit-people', text, icon='edit')\n    @enabled_with_permission('launchpad.Moderate')\n    def review_license(self):\n        text = 'Review project'\n        return Link('+review-license', text, icon='edit')\n    @enabled_with_permission('launchpad.Moderate')\n    def administer(self):\n        text = 'Administer'\n        return Link('+admin', text, icon='edit')\n    @enabled_with_permission('launchpad.Driver')\n    def sharing(self):\n        return Link('+sharing', 'Sharing', icon='edit')\nclass IProductEditMenu(Interface):\n    \"\"\"A marker interface for the 'Change details' navigation menu.\"\"\"\nclass IProductActionMenu(Interface):\n    \"\"\"A marker interface for the global action navigation menu.\"\"\"\nclass ProductActionNavigationMenu(NavigationMenu, ProductEditLinksMixin):\n    \"\"\"A sub-menu for acting upon a Product.\"\"\"\n    usedfor = IProductActionMenu\n    facet = 'overview'\n    title = 'Actions'\n    @cachedproperty\n    def links(self):\n        links = ['edit', 'review_license', 'administer', 'sharing']\n        add_subscribe_link(links)\n        return links\nclass ProductOverviewMenu(ApplicationMenu, ProductEditLinksMixin,\n                          HasRecipesMenuMixin):\n    usedfor = IProduct\n    facet = 'overview'\n    links = [\n        'edit',\n        'configure_answers',\n        'configure_blueprints',\n        'configure_bugtracker',\n        'configure_translations',\n        'reassign',\n        'top_contributors',\n        'distributions',\n        'packages',\n        'series',\n        'series_add',\n        'milestones',\n        'downloads',\n        'announce',\n        'announcements',\n        'administer',\n        'review_license',\n        'rdf',\n        'branding',\n        'view_recipes',\n        ]\n    def top_contributors(self):\n        text = 'More contributors'\n        return Link('+topcontributors', text, icon='info')\n    def distributions(self):\n        text = 'Distribution packaging information'\n        return Link('+distributions', text, icon='info')\n    def packages(self):\n        text = 'Show distribution packages'\n        return Link('+packages', text, icon='info')\n    def series(self):\n        text = 'View full history'\n        return Link('+series', text, icon='info')\n    @enabled_with_permission('launchpad.Driver')\n    def series_add(self):\n        text = 'Register a series'\n        return Link('+addseries', text, icon='add')\n    def milestones(self):\n        text = 'View milestones'\n        return Link('+milestones', text, icon='info')\n    @enabled_with_permission('launchpad.Edit')\n    def announce(self):\n        text = 'Make announcement'\n        summary = 'Publish an item of news for this project'\n        return Link('+announce', text, summary, icon='add')\n    def announcements(self):\n        text = 'Read all announcements'\n        enabled = bool(self.context.getAnnouncements())\n        return Link('+announcements', text, icon='info', enabled=enabled)\n    def rdf(self):\n        text = structured(\n            '<abbr title=\"Resource Description Framework\">'\n            'RDF</abbr> metadata')\n        return Link('+rdf', text, icon='download')\n    def downloads(self):\n        text = 'Downloads'\n        return Link('+download', text, icon='info')\nclass ProductBugsMenu(PillarBugsMenu, ProductEditLinksMixin):\n    usedfor = IProduct\n    facet = 'bugs'\n    configurable_bugtracker = True\n    @cachedproperty\n    def links(self):\n        links = ['filebug', 'bugsupervisor', 'cve']\n        add_subscribe_link(links)\n        links.append('configure_bugtracker')\n        return links\nclass ProductSpecificationsMenu(NavigationMenu, ProductEditLinksMixin,\n                                HasSpecificationsMenuMixin):\n    usedfor = IProduct\n    facet = 'specifications'\n    links = ['configure_blueprints', 'listall', 'doc', 'assignments', 'new',\n             'register_sprint']\ndef _cmp_distros(a, b):\n    \"\"\"Put Ubuntu first, otherwise in alpha order.\"\"\"\n    if a == 'ubuntu':\n        return -1\n    elif b == 'ubuntu':\n        return 1\n    else:\n        return cmp(a, b)\nclass ProductSetBreadcrumb(Breadcrumb):\n    \"\"\"Return a breadcrumb for an `IProductSet`.\"\"\"\n    text = \"Projects\"\nclass ProductSetFacets(StandardLaunchpadFacets):\n    \"\"\"The links that will appear in the facet menu for the IProductSet.\"\"\"\n    usedfor = IProductSet\n    enable_only = ['overview', 'branches']\nclass SortSeriesMixin:\n    \"\"\"Provide access to helpers for series.\"\"\"\n    def _sorted_filtered_list(self, filter=None):\n        \"\"\"Return a sorted, filtered list of series.\n        The series list is sorted by version in reverse order.  It is also\n        filtered by calling `filter` on every series.  If the `filter`\n        function returns False, don't include the series.  With None (the\n        default, include everything).\n        The development focus is always first in the list.\n        \"\"\"\n        series_list = []\n        for series in self.product.series:\n            if filter is None or filter(series):\n                series_list.append(series)\n        # In production data, there exist development focus series that are\n        # obsolete.  This may be caused by bad data, or it may be intended\n        # functionality.  In either case, ensure that the development focus\n        # branch is first in the list.\n        if self.product.development_focus in series_list:\n            series_list.remove(self.product.development_focus)\n        # Now sort the list by name with newer versions before older.\n        series_list = sorted_version_numbers(series_list,\n                                             key=attrgetter('name'))\n        series_list.insert(0, self.product.development_focus)\n        return series_list\n    @property\n    def sorted_series_list(self):\n        \"\"\"Return a sorted list of series.\n        The series list is sorted by version in reverse order.\n        The development focus is always first in the list.\n        \"\"\"\n        return self._sorted_filtered_list()\n    @property\n    def sorted_active_series_list(self):\n        \"\"\"Like `sorted_series_list()` but filters out OBSOLETE series.\"\"\"\n        # Callback for the filter which only allows series that have not been\n        # marked obsolete.\n        def check_active(series):\n            return series.status != SeriesStatus.OBSOLETE\n        return self._sorted_filtered_list(check_active)\nclass ProductWithSeries:\n    \"\"\"A decorated product that includes series data.\n    The extra data is included in this class to avoid repeated\n    database queries.  Rather than hitting the database, the data is\n    cached locally and simply returned.\n    \"\"\"\n    # `series` and `development_focus` need to be declared as class\n    # attributes so that this class will not delegate the actual instance\n    # variables to self.product, which would bypass the caching.\n    series = None\n    development_focus = None\n    delegates(IProduct, 'product')\n    def __init__(self, product):\n        self.product = product\n        self.series = []\n        for series in self.product.series:\n            series_with_releases = SeriesWithReleases(series, parent=self)\n            self.series.append(series_with_releases)\n            if self.product.development_focus == series:\n                self.development_focus = series_with_releases\n        # Get all of the releases for all of the series in a single\n        # query.  The query sorts the releases properly so we know the\n        # resulting list is sorted correctly.\n        series_by_id = dict((series.id, series) for series in self.series)\n        self.release_by_id = {}\n        milestones_and_releases = list(\n            self.product.getMilestonesAndReleases())\n        for milestone, release in milestones_and_releases:\n            series = series_by_id[milestone.productseries.id]\n            release_delegate = ReleaseWithFiles(release, parent=series)\n            series.addRelease(release_delegate)\n            self.release_by_id[release.id] = release_delegate\nclass DecoratedSeries:\n    \"\"\"A decorated series that includes helper attributes for templates.\"\"\"\n    delegates(IProductSeries, 'series')\n    def __init__(self, series):\n        self.series = series\n    @property\n    def css_class(self):\n        \"\"\"The highlight, lowlight, or normal CSS class.\"\"\"\n        if self.is_development_focus:\n            return 'highlight'\n        elif self.status == SeriesStatus.OBSOLETE:\n            return 'lowlight'\n        else:\n            # This is normal presentation.\n            return ''\n    @cachedproperty\n    def packagings(self):\n        \"\"\"Convert packagings to list to prevent multiple evaluations.\"\"\"\n        return list(self.series.packagings)\nclass SeriesWithReleases(DecoratedSeries):\n    \"\"\"A decorated series that includes releases.\n    The extra data is included in this class to avoid repeated\n    database queries.  Rather than hitting the database, the data is\n    cached locally and simply returned.\n    \"\"\"\n    # `parent` and `releases` need to be declared as class attributes so that\n    # this class will not delegate the actual instance variables to\n    # self.series, which would bypass the caching for self.releases and would\n    # raise an AttributeError for self.parent.\n    parent = None\n    releases = None\n    def __init__(self, series, parent):\n        super(SeriesWithReleases, self).__init__(series)\n        self.parent = parent\n        self.releases = []\n    def addRelease(self, release):\n        self.releases.append(release)\n    @cachedproperty\n    def has_release_files(self):\n        for release in self.releases:\n            if len(release.files) > 0:\n                return True\n        return False\nclass ReleaseWithFiles:\n    \"\"\"A decorated release that includes product release files.\n    The extra data is included in this class to avoid repeated\n    database queries.  Rather than hitting the database, the data is\n    cached locally and simply returned.\n    \"\"\"\n    # `parent` needs to be declared as class attributes so that\n    # this class will not delegate the actual instance variables to\n    # self.release, which would raise an AttributeError.\n    parent = None\n    delegates(IProductRelease, 'release')\n    def __init__(self, release, parent):\n        self.release = release\n        self.parent = parent\n        self._files = None\n    @property\n    def files(self):\n        \"\"\"Cache the release files for all the releases in the product.\"\"\"\n        if self._files is None:\n            # Get all of the files for all of the releases.  The query\n            # returns all releases sorted properly.\n            product = self.parent.parent\n            release_delegates = product.release_by_id.values()\n            files = getUtility(IProductReleaseSet).getFilesForReleases(\n                release_delegates)\n            for release_delegate in release_delegates:\n                release_delegate._files = []\n            for file in files:\n                id = file.productrelease.id\n                release_delegate = product.release_by_id[id]\n                release_delegate._files.append(file)\n        # self._files was set above, since self is actually in the\n        # release_delegates variable.\n        return self._files\n    @property\n    def name_with_codename(self):\n        milestone = self.release.milestone\n        if milestone.code_name:\n            return \"%s (%s)\" % (milestone.name, milestone.code_name)\n        else:\n            return milestone.name\n    @cachedproperty\n    def total_downloads(self):\n        \"\"\"Total downloads of files associated with this release.\"\"\"\n        return sum(file.libraryfile.hits for file in self.files)\nclass ProductDownloadFileMixin:\n    \"\"\"Provides methods for managing download files.\"\"\"\n    @cachedproperty\n    def product(self):\n        \"\"\"Product with all series, release and file data cached.\n        Decorated classes are created, and they contain cached data\n        obtained with a few queries rather than many iterated queries.\n        \"\"\"\n        return ProductWithSeries(self.context)\n    def deleteFiles(self, releases):\n        \"\"\"Delete the selected files from the set of releases.\n        :param releases: A set of releases in the view.\n        :return: The number of files deleted.\n        \"\"\"\n        del_count = 0\n        for release in releases:\n            for release_file in release.files:\n                if release_file.libraryfile.id in self.delete_ids:\n                    release_file.destroySelf()\n                    self.delete_ids.remove(release_file.libraryfile.id)\n                    del_count += 1\n        return del_count\n    def getReleases(self):\n        \"\"\"Find the releases with download files for view.\"\"\"\n        raise NotImplementedError\n    def processDeleteFiles(self):\n        \"\"\"If the 'delete_files' button was pressed, process the deletions.\"\"\"\n        del_count = None\n        if 'delete_files' in self.form:\n            if self.request.method == 'POST':\n                self.delete_ids = [\n                    int(value) for key, value in self.form.items()\n                    if key.startswith('checkbox')]\n                del(self.form['delete_files'])\n                releases = self.getReleases()\n                del_count = self.deleteFiles(releases)\n            else:\n                # If there is a form submission and it is not a POST then\n                # raise an error.  This is to protect against XSS exploits.\n                raise UnsafeFormGetSubmissionError(self.form['delete_files'])\n        if del_count is not None:\n            if del_count <= 0:\n                self.request.response.addNotification(\n                    \"No files were deleted.\")\n            elif del_count == 1:\n                self.request.response.addNotification(\n                    \"1 file has been deleted.\")\n            else:\n                self.request.response.addNotification(\n                    \"%d files have been deleted.\" %\n                    del_count)\n    @cachedproperty\n    def latest_release_with_download_files(self):\n        \"\"\"Return the latest release with download files.\"\"\"\n        for series in self.sorted_active_series_list:\n            for release in series.releases:\n                if len(list(release.files)) > 0:\n                    return release\n        return None\n    @cachedproperty\n    def has_download_files(self):\n        for series in self.context.series:\n            if series.status == SeriesStatus.OBSOLETE:\n                continue\n            for release in series.getCachedReleases():\n                if len(list(release.files)) > 0:\n                    return True\n        return False\nclass ProductView(PillarViewMixin, HasAnnouncementsView, SortSeriesMixin,\n                  FeedsMixin, ProductDownloadFileMixin):\n    implements(IProductActionMenu, IEditableContextTitle)\n    @property\n    def maintainer_widget(self):\n        return InlinePersonEditPickerWidget(\n            self.context, IProduct['owner'],\n            format_link(self.context.owner),\n            header='Change maintainer', edit_view='+edit-people',\n            step_title='Select a new maintainer', show_create_team=True)\n    @property\n    def driver_widget(self):\n        return InlinePersonEditPickerWidget(\n            self.context, IProduct['driver'],\n            format_link(self.context.driver, empty_value=\"Not yet selected\"),\n            header='Change driver', edit_view='+edit-people',\n            step_title='Select a new driver', show_create_team=True,\n            null_display_value=\"Not yet selected\",\n            help_link=\"/+help-registry/driver.html\")\n    def __init__(self, context, request):\n        HasAnnouncementsView.__init__(self, context, request)\n        self.form = request.form_ng\n    def initialize(self):\n        super(ProductView, self).initialize()\n        self.status_message = None\n        product = self.context\n        title_field = IProduct['title']\n        title = \"Edit this title\"\n        self.title_edit_widget = TextLineEditorWidget(\n            product, title_field, title, 'h1', max_width='95%',\n            truncate_lines=2)\n        programming_lang = IProduct['programminglang']\n        title = 'Edit programming languages'\n        additional_arguments = {\n            'width': '9em',\n            'css_class': 'nowrap'}\n        if self.context.programminglang is None:\n            additional_arguments.update(dict(\n                default_text='Not yet specified',\n                initial_value_override='',\n                ))\n        self.languages_edit_widget = TextLineEditorWidget(\n            product, programming_lang, title, 'span', **additional_arguments)\n        self.show_programming_languages = bool(\n            self.context.programminglang or\n            check_permission('launchpad.Edit', self.context))\n        expose_structural_subscription_data_to_js(\n            self.context, self.request, self.user)\n    @property\n    def page_title(self):\n        return '%s in Launchpad' % self.context.displayname\n    @property\n    def page_description(self):\n        return '\\n'.filter(\n            None,\n            [self.context.summary, self.context.description])\n    @property\n    def show_license_status(self):\n        return self.context.license_status != LicenseStatus.OPEN_SOURCE\n    @property\n    def freshmeat_url(self):\n        if self.context.freshmeatproject:\n            return (\"http://freshmeat.net/projects/%s\"\n                % self.context.freshmeatproject)\n        return None\n    @property\n    def sourceforge_url(self):\n        if self.context.sourceforgeproject:\n            return (\"http://sourceforge.net/projects/%s\"\n                % self.context.sourceforgeproject)\n        return None\n    @property\n    def has_external_links(self):\n        return (self.context.homepageurl or\n                self.context.sourceforgeproject or\n                self.context.freshmeatproject or\n                self.context.wikiurl or\n                self.context.screenshotsurl or\n                self.context.downloadurl)\n    @property\n    def external_links(self):\n        \"\"\"The project's external links.\n        The home page link is not included because its link must have the\n        rel=nofollow attribute.\n        \"\"\"\n        from lp.services.webapp.menu import MenuLink\n        urls = [\n            ('Sourceforge project', self.sourceforge_url),\n            ('Freshmeat record', self.freshmeat_url),\n            ('Wiki', self.context.wikiurl),\n            ('Screenshots', self.context.screenshotsurl),\n            ('External downloads', self.context.downloadurl),\n            ]\n        links = []\n        for (text, url) in urls:\n            if url is not None:\n                menu_link = MenuLink(\n                    Link(url, text, icon='external-link', enabled=True))\n                menu_link.url = url\n                links.append(menu_link)\n        return links\n    @property\n    def should_display_homepage(self):\n        return (self.context.homepageurl and\n                self.context.homepageurl not in\n                    [self.freshmeat_url, self.sourceforge_url])\n    def requestCountry(self):\n        return ICountry(self.request, None)\n    def browserLanguages(self):\n        return browser_languages(self.request)\n    def getClosedBugsURL(self, series):\n        status = [status.title for status in RESOLVED_BUGTASK_STATUSES]\n        url = canonical_url(series) + '/+bugs'\n        return get_buglisting_search_filter_url(url, status=status)\n    @property\n    def can_purchase_subscription(self):\n        return (check_permission('launchpad.Edit', self.context)\n                and not self.context.qualifies_for_free_hosting)\n    @cachedproperty\n    def effective_driver(self):\n        \"\"\"Return the product driver or the project driver.\"\"\"\n        if self.context.driver is not None:\n            driver = self.context.driver\n        elif (self.context.project is not None and\n              self.context.project.driver is not None):\n            driver = self.context.project.driver\n        else:\n            driver = None\n        return driver\n    @cachedproperty\n    def show_commercial_subscription_info(self):\n        \"\"\"Should subscription information be shown?\n        Subscription information is only shown to the project maintainers,\n        Launchpad admins, and members of the Launchpad commercial team.  The\n        first two are allowed via the Launchpad.Edit permission.  The latter\n        is allowed via Launchpad.Commercial.\n        \"\"\"\n        return (check_permission('launchpad.Edit', self.context) or\n                check_permission('launchpad.Commercial', self.context))\n    @cachedproperty\n    def show_license_info(self):\n        \"\"\"Should the view show the extra licence information.\"\"\"\n        return (\n            License.OTHER_OPEN_SOURCE in self.context.licenses\n            or License.OTHER_PROPRIETARY in self.context.licenses)\n    @cachedproperty\n    def is_proprietary(self):\n        \"\"\"Is the project proprietary.\"\"\"\n        return License.OTHER_PROPRIETARY in self.context.licenses\n    @property\n    def active_widget(self):\n        return BooleanChoiceWidget(\n            self.context, IProduct['active'],\n            content_box_id='%s-edit-active' % FormattersAPI(\n                self.context.name).css_id(),\n            edit_view='+review-license',\n            tag='span',\n            false_text='Deactivated',\n            true_text='Active',\n            header='Is this project active and usable by the community?')\n    @property\n    def project_reviewed_widget(self):\n        return BooleanChoiceWidget(\n            self.context, IProduct['project_reviewed'],\n            content_box_id='%s-edit-project-reviewed' % FormattersAPI(\n                self.context.name).css_id(),\n            edit_view='+review-license',\n            tag='span',\n            false_text='Unreviewed',\n            true_text='Reviewed',\n            header='Have you reviewed the project?')\n    @property\n    def license_approved_widget(self):\n        licenses = list(self.context.licenses)\n        if License.OTHER_PROPRIETARY in licenses:\n            return 'Commercial subscription required'\n        elif [License.DONT_KNOW] == licenses or [] == licenses:\n            return 'Licence required'\n        return BooleanChoiceWidget(\n            self.context, IProduct['license_approved'],\n            content_box_id='%s-edit-license-approved' % FormattersAPI(\n                self.context.name).css_id(),\n            edit_view='+review-license',\n            tag='span',\n            false_text='Unapproved',\n            true_text='Approved',\n            header='Does the licence qualifiy the project for free hosting?')\nclass ProductPurchaseSubscriptionView(ProductView):\n    \"\"\"View the instructions to purchase a commercial subscription.\"\"\"\n    page_title = 'Purchase subscription'\nclass ProductPackagesView(LaunchpadView):\n    \"\"\"View for displaying product packaging\"\"\"\n    label = 'Linked packages'\n    page_title = label\n    @cachedproperty\n    def series_batch(self):\n        \"\"\"A batch of series that are active or have packages.\"\"\"\n        decorated_series = DecoratedResultSet(\n            self.context.active_or_packaged_series, DecoratedSeries)\n        return BatchNavigator(decorated_series, self.request)\n    @property\n    def distro_packaging(self):\n        \"\"\"This method returns a representation of the product packagings\n        for this product, in a special structure used for the\n        product-distros.pt page template.\n        Specifically, it is a list of \"distro\" objects, each of which has a\n        title, and an attribute \"packagings\" which is a list of the relevant\n        packagings for this distro and product.\n        \"\"\"\n        distros = {}\n        for packaging in self.context.packagings:\n            distribution = packaging.distroseries.distribution\n            if distribution.name in distros:\n                distro = distros[distribution.name]\n            else:\n                # Create a dictionary for the distribution.\n                distro = dict(\n                    distribution=distribution,\n                    packagings=[])\n                distros[distribution.name] = distro\n            distro['packagings'].append(packaging)\n        # Now we sort the resulting list of \"distro\" objects, and return that.\n        distro_names = distros.keys()\n        distro_names.sort(cmp=_cmp_distros)\n        results = [distros[name] for name in distro_names]\n        return results\nclass ProductPackagesPortletView(LaunchpadView):\n    \"\"\"View class for product packaging portlet.\"\"\"\n    schema = Interface\n    @cachedproperty\n    def sourcepackages(self):\n        \"\"\"The project's latest source packages.\"\"\"\n        current_packages = [\n            sp for sp in self.context.sourcepackages\n            if sp.currentrelease is not None]\n        current_packages.reverse()\n        return current_packages[0:5]\n    @cachedproperty\n    def can_show_portlet(self):\n        \"\"\"Are there packages, or can packages be suggested.\"\"\"\n        if len(self.sourcepackages) > 0:\n            return True\nclass SeriesReleasePair:\n    \"\"\"Class for holding a series and release.\n    Replaces the use of a (series, release) tuple so that it can be more\n    clearly addressed in the view class.\n    \"\"\"\n    def __init__(self, series, release):\n        self.series = series\n        self.release = release\nclass ProductDownloadFilesView(LaunchpadView,\n                               SortSeriesMixin,\n                               ProductDownloadFileMixin):\n    \"\"\"View class for the product's file downloads page.\"\"\"\n    batch_size = config.launchpad.download_batch_size\n    @property\n    def page_title(self):\n        return \"%s project files\" % self.context.displayname\n    def initialize(self):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        self.form = self.request.form\n        # Manually process action for the 'Delete' button.\n        self.processDeleteFiles()\n    def getReleases(self):\n        \"\"\"See `ProductDownloadFileMixin`.\"\"\"\n        releases = set()\n        for series in self.product.series:\n            releases.update(series.releases)\n        return releases\n    @cachedproperty\n    def series_and_releases_batch(self):\n        \"\"\"Get a batch of series and release\n        Each entry returned is a tuple of (series, release).\n        \"\"\"\n        series_and_releases = []\n        for series in self.sorted_series_list:\n            for release in series.releases:\n                if len(release.files) > 0:\n                    pair = SeriesReleasePair(series, release)\n                    if pair not in series_and_releases:\n                        series_and_releases.append(pair)\n        batch = BatchNavigator(series_and_releases, self.request,\n                               size=self.batch_size)\n        batch.setHeadings(\"release\", \"releases\")\n        return batch\n    @cachedproperty\n    def has_download_files(self):\n        \"\"\"Across series and releases do any download files exist?\"\"\"\n        for series in self.product.series:\n            if series.has_release_files:\n                return True\n        return False\n    @cachedproperty\n    def any_download_files_with_signatures(self):\n        \"\"\"Do any series or release download files have signatures?\"\"\"\n        for series in self.product.series:\n            for release in series.releases:\n                for file in release.files:\n                    if file.signature:\n                        return True\n        return False\n    @cachedproperty\n    def milestones(self):\n        \"\"\"A mapping between series and releases that are milestones.\"\"\"\n        result = dict()\n        for series in self.product.series:\n            result[series.name] = set()\n            milestone_list = [m.name for m in series.milestones]\n            for release in series.releases:\n                if release.version in milestone_list:\n                    result[series.name].add(release.version)\n        return result\n    def is_milestone(self, series, release):\n        \"\"\"Determine whether a release is milestone for the series.\"\"\"\n        return (series.name in self.milestones and\n                release.version in self.milestones[series.name])\nclass ProductBrandingView(BrandingChangeView):\n    \"\"\"A view to set branding.\"\"\"\n    implements(IProductEditMenu)\n    label = \"Change branding\"\n    schema = IProduct\n    field_names = ['icon', 'logo', 'mugshot']\n    @property\n    def page_title(self):\n        \"\"\"The HTML page title.\"\"\"\n        return \"Change %s's branding\" % self.context.title\n    @property\n    def cancel_url(self):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        return canonical_url(self.context)\nclass ProductConfigureBase(ReturnToReferrerMixin, LaunchpadEditFormView):\n    implements(IProductEditMenu)\n    schema = IProduct\n    usage_fieldname = None\n    def setUpFields(self):\n        super(ProductConfigureBase, self).setUpFields()\n        if self.usage_fieldname is not None:\n            # The usage fields are shared among pillars.  But when referring\n            # to an individual object in Launchpad it is better to call it by\n            # its real name, i.e. 'project' instead of 'pillar'.\n            usage_field = self.form_fields.get(self.usage_fieldname)\n            if usage_field:\n                usage_field.custom_widget = CustomWidgetFactory(\n                    LaunchpadRadioWidget, orientation='vertical')\n                # Copy the field or else the description in the interface will\n                # be modified in-place.\n                field = copy_field(usage_field.field)\n                field.description = (\n                    field.description.replace('pillar', 'project'))\n                usage_field.field = field\n                if (self.usage_fieldname in\n                    ('answers_usage', 'translations_usage') and\n                    self.context.information_type in\n                    PROPRIETARY_INFORMATION_TYPES):\n                    values = usage_field.field.vocabulary.items\n                    terms = [SimpleTerm(value, value.name, value.title)\n                             for value in values\n                             if value != ServiceUsage.LAUNCHPAD]\n                    usage_field.field.vocabulary = SimpleVocabulary(terms)\n    @property\n    def field_names(self):\n        return [self.usage_fieldname]\n    @property\n    def page_title(self):\n        return self.label\n    @action(\"Change\", name='change')\n    def change_action(self, action, data):\n        self.updateContextFromData(data)\nclass ProductConfigureBlueprintsView(ProductConfigureBase):\n    \"\"\"View class to configure the Launchpad Blueprints for a project.\"\"\"\n    label = \"Configure blueprints\"\n    usage_fieldname = 'blueprints_usage'\nclass ProductConfigureAnswersView(ProductConfigureBase):\n    \"\"\"View class to configure the Launchpad Answers for a project.\"\"\"\n    label = \"Configure answers\"\n    usage_fieldname = 'answers_usage'\nclass ProductEditView(ProductLicenseMixin, LaunchpadEditFormView):\n    \"\"\"View class that lets you edit a Product object.\"\"\"\n    implements(IProductEditMenu)\n    label = \"Edit details\"\n    schema = IProduct\n    field_names = [\n        \"displayname\",\n        \"title\",\n        \"summary\",\n        \"description\",\n        \"project\",\n        \"homepageurl\",\n        \"information_type\",\n        \"sourceforgeproject\",\n        \"freshmeatproject\",\n        \"wikiurl\",\n        \"screenshotsurl\",\n        \"downloadurl\",\n        \"programminglang\",\n        \"development_focus\",\n        \"licenses\",\n        \"license_info\",\n        ]\n    custom_widget('licenses', LicenseWidget)\n    custom_widget('license_info', GhostWidget)\n    custom_widget(\n        'information_type', LaunchpadRadioWidgetWithDescription,\n        vocabulary=InformationTypeVocabulary(\n            types=PUBLIC_PROPRIETARY_INFORMATION_TYPES))\n    @property\n    def next_url(self):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        if self.context.active:\n            if len(self.errors) > 0:\n                return None\n            return canonical_url(self.context)\n        else:\n            return canonical_url(getUtility(IProductSet))\n    cancel_url = next_url\n    @property\n    def page_title(self):\n        \"\"\"The HTML page title.\"\"\"\n        return \"Change %s's details\" % self.context.title\n    def initialize(self):\n        # The JSON cache must be populated before the super call, since\n        # the form is rendered during LaunchpadFormView's initialize()\n        # when an action is invoked.\n        cache = IJSONRequestCache(self.request)\n        json_dump_information_types(\n            cache, PUBLIC_PROPRIETARY_INFORMATION_TYPES)\n        super(ProductEditView, self).initialize()\n    def validate(self, data):\n        \"\"\"Validate 'licenses' and 'license_info'.\n        'licenses' must not be empty unless the product already\n        exists and never has had a licence set.\n        'license_info' must not be empty if \"Other/Proprietary\"\n        or \"Other/Open Source\" is checked.\n        \"\"\"\n        super(ProductEditView, self).validate(data)\n        information_type = data.get('information_type')\n        if information_type:\n            errors = [\n                str(e) for e in self.context.checkInformationType(\n                    information_type)]\n            if len(errors) > 0:\n                self.setFieldError('information_type', ' '.join(errors))\n    def showOptionalMarker(self, field_name):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        # This has the effect of suppressing the \": (Optional)\" stuff for the\n        # license_info widget.  It's the last piece of the puzzle for\n        # manipulating the license_info widget into the table for the\n        # LicenseWidget instead of the enclosing form.\n        if field_name == 'license_info':\n            return False\n        return super(ProductEditView, self).showOptionalMarker(field_name)\n    @action(\"Change\", name='change')\n    def change_action(self, action, data):\n        self.updateContextFromData(data)\nclass ProductValidationMixin:\n    def validate_deactivation(self, data):\n        \"\"\"Verify whether a product can be safely deactivated.\"\"\"\n        if data['active'] == False and self.context.active == True:\n            if len(self.context.sourcepackages) > 0:\n                self.setFieldError('active',\n                    structured(\n                        'This project cannot be deactivated since it is '\n                        'linked to one or more '\n                        '<a href=\"%s\">source packages</a>.',\n                        canonical_url(self.context, view_name='+packages')))\nclass ProductAdminView(ProductEditView, ProductValidationMixin):\n    \"\"\"View for $project/+admin\"\"\"\n    label = \"Administer project details\"\n    default_field_names = [\n        \"name\",\n        \"owner\",\n        \"active\",\n        \"autoupdate\",\n        ]\n    @property\n    def page_title(self):\n        \"\"\"The HTML page title.\"\"\"\n        return 'Administer %s' % self.context.title\n    def setUpFields(self):\n        \"\"\"Setup the normal fields from the schema plus adds 'Registrant'.\n        The registrant is normally a read-only field and thus does not have a\n        proper widget created by default.  Even though it is read-only, admins\n        need the ability to change it.\n        \"\"\"\n        self.field_names = self.default_field_names[:]\n        admin = check_permission('launchpad.Admin', self.context)\n        if not admin:\n            self.field_names.remove('owner')\n            self.field_names.remove('autoupdate')\n        super(ProductAdminView, self).setUpFields()\n        self.form_fields = self._createAliasesField() + self.form_fields\n        if admin:\n            self.form_fields = (\n                self.form_fields + self._createRegistrantField())\n    def _createAliasesField(self):\n        \"\"\"Return a PillarAliases field for IProduct.aliases.\"\"\"\n        return form.Fields(\n            PillarAliases(\n                __name__='aliases', title=_('Aliases'),\n                description=_('Other names (separated by space) under which '\n                              'this project is known.'),\n                required=False, readonly=False),\n            render_context=self.render_context)\n    def _createRegistrantField(self):\n        \"\"\"Return a popup widget person selector for the registrant.\n        This custom field is necessary because *normally* the registrant is\n        read-only but we want the admins to have the ability to correct legacy\n        data that was set before the registrant field existed.\n        \"\"\"\n        return form.Fields(\n            PublicPersonChoice(\n                __name__='registrant',\n                title=_('Project Registrant'),\n                description=_('The person who originally registered the '\n                              'product.  Distinct from the current '\n                              'owner.  This is historical data and should '\n                              'not be changed without good cause.'),\n                vocabulary='ValidPersonOrTeam',\n                required=True,\n                readonly=False,\n                ),\n            render_context=self.render_context\n            )\n    def validate(self, data):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        super(ProductAdminView, self).validate(data)\n        self.validate_deactivation(data)\n    @property\n    def cancel_url(self):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        return canonical_url(self.context)\nclass ProductReviewLicenseView(ReturnToReferrerMixin, ProductEditView,\n                               ProductValidationMixin):\n    \"\"\"A view to review a project and change project privileges.\"\"\"\n    label = \"Review project\"\n    field_names = [\n        \"project_reviewed\",\n        \"license_approved\",\n        \"active\",\n        \"reviewer_whiteboard\",\n        ]\n    @property\n    def page_title(self):\n        \"\"\"The HTML page title.\"\"\"\n        return 'Review %s' % self.context.title\n    def validate(self, data):\n        \"\"\"See `LaunchpadFormView`.\"\"\"\n        super(ProductReviewLicenseView, self).validate(data)\n        # A project can only be approved if it has OTHER_OPEN_SOURCE as one of\n        # its licenses and not OTHER_PROPRIETARY.\n        licenses = self.context.licenses\n        license_approved = data.get('license_approved', False)\n        if license_approved:\n            if License.OTHER_PROPRIETARY in licenses:\n                self.setFieldError(\n                    'license_approved',\n                    'Proprietary projects may not be manually '\n                    'approved to use Launchpad.  Proprietary projects '\n                    'must use the commercial subscription voucher system '\n                    'to be allowed to use Launchpad.')\n            else:\n                # An Other/Open Source licence was specified so it may be\n                # approved.\n                pass\n        self.validate_deactivation(data)\nclass ProductAddSeriesView(LaunchpadFormView):\n    \"\"\"A form to add new product series\"\"\"\n    schema = IProductSeries\nNext line of code:\n",
        "prediction": "   @action(\"Add Series\", name='add_series')\n    def add_series_action(self, data):\n        \"\"\"Add a new product series.\"\"\"\n        self.updateContextFromData(data)\n        self.validate_deactivation(data)\n        self.validate",
        "gold": [
            "    field_names = ['name', 'summary', 'branch', 'releasefileglob']"
        ],
        "time": 3.3590121269226074
    },
    "4": {
        "origin_prompt": "Please complete the code given below. \nusing System;\nusing Server.Items;\nusing Server.Spells;\nnamespace Server.Engines.Craft\n{\n    public class DefInscription : CraftSystem\n    {\n        public override SkillName MainSkill\n        {\n            get\n            {\n                return SkillName.Inscribe;\n            }\n        }\n        public override int GumpTitleNumber\n        {\n            get\n            {\n                return 1044009;\n            }// <CENTER>INSCRIPTION MENU</CENTER>\n        }\n        private static CraftSystem m_CraftSystem;\n        public static CraftSystem CraftSystem\n        {\n            get\n            {\n                if (m_CraftSystem == null)\n                    m_CraftSystem = new DefInscription();\n                return m_CraftSystem;\n            }\n        }\n        public override double GetChanceAtMin(CraftItem item)\n        {\n            return 0.0; // 0%\n        }\n        private DefInscription()\n            : base(1, 1, 1.25)// base( 1, 1, 3.0 )\n        {\n        }\n        public override int CanCraft(Mobile from, BaseTool tool, Type typeItem)\n        {\n            if (tool == null || tool.Deleted || tool.UsesRemaining < 0)\n                return 1044038; // You have worn out your tool!\n            else if (!BaseTool.CheckAccessible(tool, from))\n                return 1044263; // The tool must be on your person to use.\n            if (typeItem != null)\n            {\n                object o = Activator.CreateInstance(typeItem);\n                if (o is SpellScroll)\n                {\n                    SpellScroll scroll = (SpellScroll)o;\n                    Spellbook book = Spellbook.Find(from, scroll.SpellID);\n                    bool hasSpell = (book != null && book.HasSpell(scroll.SpellID));\n                    scroll.Delete();\n                    return (hasSpell ? 0 : 1042404); // null : You don't have that spell!\n                }\n                else if (o is Item)\n                {\n                    ((Item)o).Delete();\n                }\n            }\n            return 0;\n        }\n        public override void PlayCraftEffect(Mobile from)\n        {\n            from.PlaySound(0x249);\n        }\n        private static readonly Type typeofSpellScroll = typeof(SpellScroll);\n        public override int PlayEndingEffect(Mobile from, bool failed, bool lostMaterial, bool toolBroken, int quality, bool makersMark, CraftItem item)\n        {\n            if (toolBroken)\n                from.SendLocalizedMessage(1044038); // You have worn out your tool\n            if (!typeofSpellScroll.IsAssignableFrom(item.ItemType)) //  not a scroll\n            {\n                if (failed)\n                {\n                    if (lostMaterial)\n                        return 1044043; // You failed to create the item, and some of your materials are lost.\n                    else\n                        return 1044157; // You failed to create the item, but no materials were lost.\n                }\n                else\n                {\n                    if (quality == 0)\n                        return 502785; // You were barely able to make this item.  It's quality is below average.\n                    else if (makersMark && quality == 2)\n                        return 1044156; // You create an exceptional quality item and affix your maker's mark.\n                    else if (quality == 2)\n                        return 1044155; // You create an exceptional quality item.\n                    else\n                        return 1044154; // You create the item.\n                }\n            }\n            else\n            {\n                if (failed)\n                    return 501630; // You fail to inscribe the scroll, and the scroll is ruined.\n                else\n                    return 501629; // You inscribe the spell and put the scroll in your backpack.\n            }\n        }\n        private int m_Circle, m_Mana;\n        private enum Reg { BlackPearl, Bloodmoss, Garlic, Ginseng, MandrakeRoot, Nightshade, SulfurousAsh, SpidersSilk, BatWing, GraveDust, DaemonBlood, NoxCrystal, PigIron, Bone, DragonBlood, FertileDirt, DaemonBone }\n        private readonly Type[] m_RegTypes = new Type[]\n        {\n            typeof( BlackPearl ),\n\t\t\ttypeof( Bloodmoss ),\n\t\t\ttypeof( Garlic ),\n\t\t\ttypeof( Ginseng ),\n\t\t\ttypeof( MandrakeRoot ),\n\t\t\ttypeof( Nightshade ),\n\t\t\ttypeof( SulfurousAsh ),\t\n\t\t\ttypeof( SpidersSilk ),\n            typeof( BatWing ),\n            typeof( GraveDust ),\n            typeof( DaemonBlood ),\n            typeof( NoxCrystal ),\n            typeof( PigIron ),\n\t\t\ttypeof( Bone ),\n\t\t\ttypeof( DragonBlood ),\n\t\t\ttypeof( FertileDirt ),\n\t\t\ttypeof( DaemonBone )\t\t\t\n        };\n        private int m_Index;\n        private void AddSpell(Type type, params Reg[] regs)\n        {\n            double minSkill, maxSkill;\n            int cliloc;\n            switch (m_Circle)\n            {\n                default:\n                case 0: minSkill = -25.0; maxSkill = 25.0; cliloc = 1111691; break;\n                case 1: minSkill = -10.8; maxSkill = 39.2; cliloc = 1111691; break;\n                case 2: minSkill = 03.5; maxSkill = 53.5; cliloc = 1111692; break;\n                case 3: minSkill = 17.8; maxSkill = 67.8; cliloc = 1111692; break;\n                case 4: minSkill = 32.1; maxSkill = 82.1; cliloc = 1111693; break;\n                case 5: minSkill = 46.4; maxSkill = 96.4; cliloc = 1111693; break;\n                case 6: minSkill = 60.7; maxSkill = 110.7; cliloc = 1111694; break;\n                case 7: minSkill = 75.0; maxSkill = 125.0; cliloc = 1111694; break;\n            }\n            int index = AddCraft(type, cliloc, 1044381 + m_Index++, minSkill, maxSkill, m_RegTypes[(int)regs[0]], 1044353 + (int)regs[0], 1, 1044361 + (int)regs[0]);\n            for (int i = 1; i < regs.Length; ++i)\n                AddRes(index, m_RegTypes[(int)regs[i]], 1044353 + (int)regs[i], 1, 1044361 + (int)regs[i]);\n            AddRes(index, typeof(BlankScroll), 1044377, 1, 1044378);\n            SetManaReq(index, m_Mana);\n        }\n        private void AddNecroSpell(int spell, int mana, double minSkill, Type type, params Reg[] regs)\n        {\n            int id = GetRegLocalization(regs[0]);\n            int index = AddCraft(type, 1061677, 1060509 + spell, minSkill, minSkill + 1.0, m_RegTypes[(int)regs[0]], id, 1, 501627);\n            for (int i = 1; i < regs.Length; ++i)\n            {\n                id = GetRegLocalization(regs[i]);\n                AddRes(index, m_RegTypes[(int)regs[0]], id, 1, 501627);\n            }\n            AddRes(index, typeof(BlankScroll), 1044377, 1, 1044378);\n            SetManaReq(index, mana);\n        }\n        private void AddMysticSpell(int id, int mana, double minSkill, Type type, params Reg[] regs)\n        {\n            int index = AddCraft(type, 1111671, id, minSkill, minSkill + 1.0, m_RegTypes[(int)regs[0]], GetRegLocalization(regs[0]), 1, 501627);\t//Yes, on OSI it's only 1.0 skill diff'.  Don't blame me, blame OSI.\n            for (int i = 1; i < regs.Length; ++i)\n                AddRes(index, m_RegTypes[(int)regs[0]], GetRegLocalization(regs[i]), 1, 501627);\n            AddRes(index, typeof(BlankScroll), 1044377, 1, 1044378);\n            SetManaReq(index, mana);\n        }\n        private int GetRegLocalization(Reg reg)\n        {\n            int loc = 0;\n            switch (reg)\n            {\n                case Reg.BatWing: loc = 1023960; break;\n                case Reg.GraveDust: loc = 1023983; break;\n                case Reg.DaemonBlood: loc = 1023965; break;\n                case Reg.NoxCrystal: loc = 1023982; break;\n                case Reg.PigIron: loc = 1023978; break;\n                case Reg.Bone: loc = 1023966; break;\n                case Reg.DragonBlood: loc = 1023970; break;\n                case Reg.FertileDirt: loc = 1023969; break;\n                case Reg.DaemonBone: loc = 1023968; break;\n            }\n            if (loc == 0)\n                loc = 1044353 + (int)reg;\n            return loc;\n        }\n        public override void InitCraftList()\n        {\n            m_Circle = 0;\n\t\t\tm_Mana = 4;\n\t\t\tAddSpell( typeof( ReactiveArmorScroll ), Reg.Garlic, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ClumsyScroll ), Reg.Bloodmoss, Reg.Nightshade );\n\t\t\tAddSpell( typeof( CreateFoodScroll ), Reg.Garlic, Reg.Ginseng, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( FeeblemindScroll ), Reg.Nightshade, Reg.Ginseng );\n\t\t\tAddSpell( typeof( HealScroll ), Reg.Garlic, Reg.Ginseng, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( MagicArrowScroll ), Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( NightSightScroll ), Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( WeakenScroll ), Reg.Garlic, Reg.Nightshade );\n\t\t\tm_Circle = 1;\n\t\t\tm_Mana = 6;\n\t\t\tAddSpell( typeof( AgilityScroll ), Reg.Bloodmoss, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( CunningScroll ), Reg.Nightshade, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( CureScroll ), Reg.Garlic, Reg.Ginseng );\n\t\t\tAddSpell( typeof( HarmScroll ), Reg.Nightshade, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( MagicTrapScroll ), Reg.Garlic, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( MagicUnTrapScroll ), Reg.Bloodmoss, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ProtectionScroll ), Reg.Garlic, Reg.Ginseng, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( StrengthScroll ), Reg.Nightshade, Reg.MandrakeRoot );\n\t\t\tm_Circle = 2;\n\t\t\tm_Mana = 9;\n\t\t\tAddSpell( typeof( BlessScroll ), Reg.Garlic, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( FireballScroll ), Reg.BlackPearl );\n\t\t\tAddSpell( typeof( MagicLockScroll ), Reg.Bloodmoss, Reg.Garlic, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( PoisonScroll ), Reg.Nightshade );\n\t\t\tAddSpell( typeof( TelekinisisScroll ), Reg.Bloodmoss, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( TeleportScroll ), Reg.Bloodmoss, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( UnlockScroll ), Reg.Bloodmoss, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( WallOfStoneScroll ), Reg.Bloodmoss, Reg.Garlic );\n\t\t\tm_Circle = 3;\n\t\t\tm_Mana = 11;\n\t\t\tAddSpell( typeof( ArchCureScroll ), Reg.Garlic, Reg.Ginseng, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( ArchProtectionScroll ), Reg.Garlic, Reg.Ginseng, Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( CurseScroll ), Reg.Garlic, Reg.Nightshade, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( FireFieldScroll ), Reg.BlackPearl, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( GreaterHealScroll ), Reg.Garlic, Reg.SpidersSilk, Reg.MandrakeRoot, Reg.Ginseng );\n\t\t\tAddSpell( typeof( LightningScroll ), Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ManaDrainScroll ), Reg.BlackPearl, Reg.SpidersSilk, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( RecallScroll ), Reg.BlackPearl, Reg.Bloodmoss, Reg.MandrakeRoot );\n\t\t\tm_Circle = 4;\n\t\t\tm_Mana = 14;\n\t\t\tAddSpell( typeof( BladeSpiritsScroll ), Reg.BlackPearl, Reg.Nightshade, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( DispelFieldScroll ), Reg.BlackPearl, Reg.Garlic, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( IncognitoScroll ), Reg.Bloodmoss, Reg.Garlic, Reg.Nightshade );\n\t\t\tAddSpell( typeof( MagicReflectScroll ), Reg.Garlic, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( MindBlastScroll ), Reg.BlackPearl, Reg.MandrakeRoot, Reg.Nightshade, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ParalyzeScroll ), Reg.Garlic, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( PoisonFieldScroll ), Reg.BlackPearl, Reg.Nightshade, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( SummonCreatureScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tm_Circle = 5;\n\t\t\tm_Mana = 20;\n\t\t\tAddSpell( typeof( DispelScroll ), Reg.Garlic, Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( EnergyBoltScroll ), Reg.BlackPearl, Reg.Nightshade );\n\t\t\tAddSpell( typeof( ExplosionScroll ), Reg.Bloodmoss, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( InvisibilityScroll ), Reg.Bloodmoss, Reg.Nightshade );\n\t\t\tAddSpell( typeof( MarkScroll ), Reg.Bloodmoss, Reg.BlackPearl, Reg.MandrakeRoot );\n\t\t\tAddSpell( typeof( MassCurseScroll ), Reg.Garlic, Reg.MandrakeRoot, Reg.Nightshade, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ParalyzeFieldScroll ), Reg.BlackPearl, Reg.Ginseng, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( RevealScroll ), Reg.Bloodmoss, Reg.SulfurousAsh );\n\t\t\tm_Circle = 6;\n\t\t\tm_Mana = 40;\n\t\t\tAddSpell( typeof( ChainLightningScroll ), Reg.BlackPearl, Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( EnergyFieldScroll ), Reg.BlackPearl, Reg.MandrakeRoot, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( FlamestrikeScroll ), Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( GateTravelScroll ), Reg.BlackPearl, Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( ManaVampireScroll ), Reg.BlackPearl, Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( MassDispelScroll ), Reg.BlackPearl, Reg.Garlic, Reg.MandrakeRoot, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( MeteorSwarmScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SulfurousAsh, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( PolymorphScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tm_Circle = 7;\n\t\t\tm_Mana = 50;\n\t\t\tAddSpell( typeof( EarthquakeScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.Ginseng, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( EnergyVortexScroll ), Reg.BlackPearl, Reg.Bloodmoss, Reg.MandrakeRoot, Reg.Nightshade );\n\t\t\tAddSpell( typeof( ResurrectionScroll ), Reg.Bloodmoss, Reg.Garlic, Reg.Ginseng );\n\t\t\tAddSpell( typeof( SummonAirElementalScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( SummonDaemonScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( SummonEarthElementalScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tAddSpell( typeof( SummonFireElementalScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk, Reg.SulfurousAsh );\n\t\t\tAddSpell( typeof( SummonWaterElementalScroll ), Reg.Bloodmoss, Reg.MandrakeRoot, Reg.SpidersSilk );\n\t\t\tif ( Core.SE )\n\t\t\t{\n\t\t\t\tAddNecroSpell(  0, 23, 39.6, typeof( AnimateDeadScroll ), Reg.GraveDust, Reg.DaemonBlood );\n\t\t\t\tAddNecroSpell(  1, 13, 19.6, typeof( BloodOathScroll ), Reg.DaemonBlood );\n\t\t\t\tAddNecroSpell(  2, 11, 19.6, typeof( CorpseSkinScroll ), Reg.BatWing, Reg.GraveDust );\n\t\t\t\tAddNecroSpell(  3,  7, 19.6, typeof( CurseWeaponScroll ), Reg.PigIron );\n\t\t\t\tAddNecroSpell(  4, 11, 19.6, typeof( EvilOmenScroll ), Reg.BatWing, Reg.NoxCrystal );\n\t\t\t\tAddNecroSpell(  5, 11, 39.6, typeof( HorrificBeastScroll ), Reg.BatWing, Reg.DaemonBlood );\n\t\t\t\tAddNecroSpell(  6, 23, 69.6, typeof( LichFormScroll ), Reg.GraveDust, Reg.DaemonBlood, Reg.NoxCrystal );\n\t\t\t\tAddNecroSpell(  7, 17, 29.6, typeof( MindRotScroll ), Reg.BatWing, Reg.DaemonBlood, Reg.PigIron );\n\t\t\t\tAddNecroSpell(  8,  5, 19.6, typeof( PainSpikeScroll ), Reg.GraveDust, Reg.PigIron );\n\t\t\t\tAddNecroSpell(  9, 17, 49.6, typeof( PoisonStrikeScroll ), Reg.NoxCrystal );\n\t\t\t\tAddNecroSpell( 10, 29, 64.6, typeof( StrangleScroll ), Reg.DaemonBlood, Reg.NoxCrystal );\n\t\t\t\tAddNecroSpell( 11, 17, 29.6, typeof( SummonFamiliarScroll ), Reg.BatWing, Reg.GraveDust, Reg.DaemonBlood );\n\t\t\t\tAddNecroSpell( 12, 23, 98.6, typeof( VampiricEmbraceScroll ), Reg.BatWing, Reg.NoxCrystal, Reg.PigIron );\n\t\t\t\tAddNecroSpell( 13, 41, 79.6, typeof( VengefulSpiritScroll ), Reg.BatWing, Reg.GraveDust, Reg.PigIron );\n\t\t\t\tAddNecroSpell( 14, 23, 59.6, typeof( WitherScroll ), Reg.GraveDust, Reg.NoxCrystal, Reg.PigIron );\n\t\t\t\tAddNecroSpell( 15, 17, 79.6, typeof( WraithFormScroll ), Reg.NoxCrystal, Reg.PigIron );\n\t\t\t\tAddNecroSpell( 16, 40, 79.6, typeof( ExorcismScroll ), Reg.NoxCrystal, Reg.GraveDust );\n\t\t\t}\n            int index;\n\t\t\t\n            if (Core.ML)\n            {\n                index = this.AddCraft(typeof(EnchantedSwitch), 1044294, 1072893, 45.0, 95.0, typeof(BlankScroll), 1044377, 1, 1044378);\n                this.AddRes(index, typeof(SpidersSilk), 1044360, 1, 1044253);\n                this.AddRes(index, typeof(BlackPearl), 1044353, 1, 1044253);\n                this.AddRes(index, typeof(SwitchItem), 1073464, 1, 1044253);\n                this.ForceNonExceptional(index);\n                this.SetNeededExpansion(index, Expansion.ML);\n\t\t\t\t\n                index = this.AddCraft(typeof(RunedPrism), 1044294, 1073465, 45.0, 95.0, typeof(BlankScroll), 1044377, 1, 1044378);\n                this.AddRes(index, typeof(SpidersSilk), 1044360, 1, 1044253);\nNext line of code:\n",
        "prediction": "               this.AddRes(index, typeof(BlackPearl), 1044353, 1, 1044253);\n                this.AddRes(index, typeof(SwitchItem), 1073464, 1, 1",
        "gold": [
            "                this.AddRes(index, typeof(BlackPearl), 1044353, 1, 1044253);"
        ],
        "time": 3.3613409996032715
    },
    "5": {
        "origin_prompt": "Please complete the code given below. \n/*\nCopyright (C) SYSTAP, LLC DBA Blazegraph 2006-2016.  All rights reserved.\nContact:\n     SYSTAP, LLC DBA Blazegraph\n     2501 Calvert ST NW #106\n     Washington, DC 20008\n     licenses@blazegraph.com\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2 of the License.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n/*\n * Created on Nov 14, 2008\n */\npackage com.bigdata.rdf.store;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Properties;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport org.apache.log4j.Logger;\nimport org.openrdf.model.Statement;\nimport com.bigdata.journal.Journal;\nimport com.bigdata.journal.TimestampUtility;\nimport com.bigdata.rdf.axioms.Axioms;\nimport com.bigdata.rdf.axioms.NoAxioms;\nimport com.bigdata.rdf.internal.IV;\nimport com.bigdata.rdf.model.BigdataStatement;\nimport com.bigdata.rdf.rio.AbstractStatementBuffer.StatementBuffer2;\nimport com.bigdata.rdf.rio.StatementBuffer;\nimport com.bigdata.rdf.rules.BackchainAccessPath;\nimport com.bigdata.rdf.spo.ISPO;\nimport com.bigdata.rdf.spo.SPO;\nimport com.bigdata.rdf.store.AbstractTripleStore.Options;\nimport com.bigdata.relation.accesspath.BlockingBuffer;\nimport com.bigdata.relation.accesspath.IAccessPath;\nimport com.bigdata.striterator.IChunkedOrderedIterator;\nimport cutthecrap.utils.striterators.ICloseableIterator;\n/**\n * Utility class for comparing graphs for equality, bulk export, etc.\n * \n * @author <a href=\"mailto:thompsonbry@users.sourceforge.net\">Bryan Thompson</a>\n * @version $Id$\n */\npublic class TripleStoreUtility {\n    \n    protected static final Logger log = Logger.getLogger(TripleStoreUtility.class);\n    /**\n     * Compares two RDF graphs for equality (same statements).\n     * <p>\n     * Note: This does NOT handle bnodes, which much be treated as variables for\n     * RDF semantics.\n     * <p>\n     * Note: Comparison is performed in terms of the externalized RDF\n     * {@link Statement}s rather than {@link SPO}s since different graphs use\n     * different lexicons.\n     * <p>\n     * Note: If the graphs differ in which entailments they are storing in their\n     * data and which entailments are backchained then you MUST make them\n     * consistent in this regard. You can do this by exporting one or both using\n     * {@link #bulkExport(AbstractTripleStore)}, which will cause all\n     * entailments to be materialized in the returned {@link TempTripleStore}.\n     * \n     * @param expected\n     *            One graph.\n     * \n     * @param actual\n     *            Another graph <strong>with a consistent policy for forward and\n     *            backchained entailments</strong>.\n     * \n     * @return true if all statements in the expected graph are in the actual\n     *         graph and if the actual graph does not contain any statements\n     *         that are not also in the expected graph.\n     */\n    public static boolean modelsEqual(AbstractTripleStore expected,\n            AbstractTripleStore actual) throws Exception {\n        //        int actualSize = 0;\n        int notExpecting = 0;\n        int expecting = 0;\n        boolean sameStatements1 = true;\n        {\n            final ICloseableIterator<BigdataStatement> it = notFoundInTarget(actual, expected);\n            try {\n                while (it.hasNext()) {\n                    final BigdataStatement stmt = it.next();\n                    sameStatements1 = false;\n                    log(\"Not expecting: \" + stmt);\n                    notExpecting++;\n                    //                    actualSize++; // count #of statements actually visited.\n                }\n            } finally {\n                it.close();\n            }\n            log(\"all the statements in actual in expected? \" + sameStatements1);\n        }\n        //        int expectedSize = 0;\n        boolean sameStatements2 = true;\n        {\n            final ICloseableIterator<BigdataStatement> it = notFoundInTarget(expected, actual);\n            try {\n                while (it.hasNext()) {\n                    final BigdataStatement stmt = it.next();\n                    sameStatements2 = false;\n                    log(\"    Expecting: \" + stmt);\n                    expecting++;\n                    //                    expectedSize++; // counts statements actually visited.\n                }\n            } finally {\n                it.close();\n            }\n            //          BigdataStatementIterator it = expected.asStatementIterator(expected\n            //          .getInferenceEngine().backchainIterator(\n            //                  expected.getAccessPath(NULL, NULL, NULL)));\n            //\n            //            try {\n            //\n            //                while(it.hasNext()) {\n            //\n            //                BigdataStatement stmt = it.next();\n            //\n            //                if (!hasStatement(actual,//\n            //                        (Resource)actual.getValueFactory().asValue(stmt.getSubject()),//\n            //                        (URI)actual.getValueFactory().asValue(stmt.getPredicate()),//\n            //                        (Value)actual.getValueFactory().asValue(stmt.getObject()))//\n            //                        ) {\n            //\n            //                    sameStatements2 = false;\n            //\n            //                    log(\"    Expecting: \" + stmt);\n            //                    \n            //                    expecting++;\n            //\n            //                }\n            //                \n            //                expectedSize++; // counts statements actually visited.\n            //\n            //                }\n            //                \n            //            } finally {\n            //                \n            //                it.close();\n            //                \n            //            }\n            log(\"all the statements in expected in actual? \" + sameStatements2);\n        }\n        //        final boolean sameSize = expectedSize == actualSize;\n        //        \n        //        log(\"size of 'expected' repository: \" + expectedSize);\n        //\n        //        log(\"size of 'actual'   repository: \" + actualSize);\n        log(\"# expected but not found: \" + expecting);\n        log(\"# not expected but found: \" + notExpecting);\n        return /*sameSize &&*/sameStatements1 && sameStatements2;\n    }\n    public static void log(final String s) {\n    \tif(log.isInfoEnabled())\n    \t\tlog.info(s);\n    }\n    /**\n     * Visits <i>expected</i> {@link BigdataStatement}s not found in <i>actual</i>.\n     * \n     * @param expected\n     * @param actual\n     * \n     * @return An iterator visiting {@link BigdataStatement}s present in\n     *         <i>expected</i> but not found in <i>actual</i>.\n     * \n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    public static ICloseableIterator<BigdataStatement> notFoundInTarget(//\n            final AbstractTripleStore expected,//\n            final AbstractTripleStore actual //\n    ) throws InterruptedException, ExecutionException {\n        /*\n         * The source access path is a full scan of the SPO index.\n         */\n        final IAccessPath<ISPO> expectedAccessPath = expected.getAccessPath(\n                (IV) null, (IV) null, (IV) null);\n        /*\n         * Efficiently convert SPOs to BigdataStatements (externalizes\n         * statements).\n         */\n        final BigdataStatementIterator itr2 = expected\n                .asStatementIterator(expectedAccessPath.iterator());\n        final int capacity = 100000;\n        final BlockingBuffer<BigdataStatement> buffer = new BlockingBuffer<BigdataStatement>(\n                capacity);\n        final StatementBuffer2<Statement, BigdataStatement> sb = new StatementBuffer2<Statement, BigdataStatement>(\n                actual, true/* readOnly */, capacity) {\n            /**\n             * Statements not found in [actual] are written on the\n             * BlockingBuffer.\n             * \n             * @return The #of statements that were not found.\n             */\n            @Override\n            protected int handleProcessedStatements(final BigdataStatement[] a) {\n                if (log.isInfoEnabled())\n                    log.info(\"Given \" + a.length + \" statements\");\n                // bulk filter for statements not present in [actual].\n                final IChunkedOrderedIterator<ISPO> notFoundItr = actual\n                        .bulkFilterStatements(a, a.length, false/* present */);\n                int nnotFound = 0;\n                try {\n                    while (notFoundItr.hasNext()) {\n                        final ISPO notFoundStmt = notFoundItr.next();\n                        if (log.isInfoEnabled())\n                            log.info(\"Not found: \" + notFoundStmt);\n                        buffer.add((BigdataStatement) notFoundStmt);\n                        nnotFound++;\n                    }\n                } finally {\n                    notFoundItr.close();\n                }\n                if (log.isInfoEnabled())\n                    log.info(\"Given \" + a.length + \" statements, \" + nnotFound\n                            + \" of them were not found\");\n                return nnotFound;\n            }\n        };\n        /**\n         * Run task. The task consumes externalized statements from [expected]\n         * and writes statements not found in [actual] onto the blocking buffer.\n         */\n        final Callable<Void> myTask = new Callable<Void>() {\n                public Void call() throws Exception {\n                    try {\n                        while (itr2.hasNext()) {\n                            // a statement from the source db.\n                            final BigdataStatement stmt = itr2.next();\n                            // if (log.isInfoEnabled()) log.info(\"Source: \"\n                            // + stmt);\n                            // add to the buffer.\n                            sb.add(stmt);\n                        }\n                    } finally {\n                        itr2.close();\n                    }\n                    /*\n                     * Flush everything in the StatementBuffer so that it\n                     * shows up in the BlockingBuffer's iterator().\n                     */\n                    final long nnotFound = sb.flush();\n                    if (log.isInfoEnabled())\n                        log.info(\"Flushed: #notFound=\" + nnotFound);\n                    return null;\n                }\n        };\n        /**\n         * @see <a href=\"https://sourceforge.net/apps/trac/bigdata/ticket/707\">\n         *      BlockingBuffer.close() does not unblock threads </a>\n         */\n        // Wrap computation as FutureTask.\n        final FutureTask<Void> ft = new FutureTask<Void>(myTask);\n        \n        // Set Future on BlockingBuffer.\n        buffer.setFuture(ft);\n        \n        // Submit computation for evaluation.\n        actual.getExecutorService().submit(ft);\n        /*\n         * Return iterator reading \"not found\" statements from the blocking\n         * buffer.\n         */\n        return buffer.iterator();\n    }\n    /**\n     * Exports all statements found in the data and all backchained entailments\n     * for the <i>db</i> into a {@link TempTripleStore}. This may be used to\n     * compare graphs purely in their data by pre-generation of all backchained\n     * entailments.\n     * <p>\n     * Note: This is not a general purpose bulk export as it uses only a single\n     * access path, does not store justifications, and does retain the\n     * {@link Axioms} model of the source graph. This method is specifically\n     * designed to export \"just the triples\", e.g., for purposes of comparison.\n     * \n     * @param db\n     *            The source database.\n     * \n     * @return The {@link TempTripleStore}.\n     */\n    static public TempTripleStore bulkExport(final AbstractTripleStore db) {\n    \n        final Properties properties = new Properties();\n        \n        properties.setProperty(Options.ONE_ACCESS_PATH, \"true\");\n        \n        properties.setProperty(Options.JUSTIFY, \"false\");\n        \n        properties.setProperty(Options.AXIOMS_CLASS,\n                NoAxioms.class.getName());\n        properties.setProperty(Options.STATEMENT_IDENTIFIERS,\n                \"\" + db.isStatementIdentifiers());\n        final TempTripleStore tmp = new TempTripleStore(properties);\n        try {\n\t\t\tfinal StatementBuffer<Statement> sb = new StatementBuffer<Statement>(tmp, 100000/* capacity */,\n\t\t\t\t\t10/* queueCapacity */);\n            final IV NULL = null;\n            final IChunkedOrderedIterator<ISPO> itr1 = new BackchainAccessPath(\n                    db, db.getAccessPath(NULL, NULL, NULL)).iterator();\n            final BigdataStatementIterator itr2 = db.asStatementIterator(itr1);\n            try {\n                while (itr2.hasNext()) {\n                    final BigdataStatement stmt = itr2.next();\n                    sb.add(stmt);\n                }\n            } finally {\n                itr2.close();\n            }\n            sb.flush();\n        } catch (Throwable t) {\n            tmp.close();\n            throw new RuntimeException(t);\n        }\n    \n        return tmp;\n    \n    }\n    /**\n     * Compares two {@link LocalTripleStore}s\n     * \n     * @param args\n     *            filename filename (namespace)\n     * \n     * @throws Exception\n     *  \n     * @todo namespace for each, could be the same file, and timestamp for each.\n     * \n     * @todo handle other database modes.\n     */\n    public static void main(String[] args) throws Exception {\n        \nNext line of code:\n",
        "prediction": "       final String ns = \"http://www.example.com/\";\n        final String filename = \"test.ttl\";\n        final String filename2 = \"test2.ttl\";\n        final String filename3 = \"test3.ttl\";\n        final String filename4 = \"test",
        "gold": [
            "        if (args.length < 2 || args.length > 3) {"
        ],
        "time": 3.363922119140625
    },
    "6": {
        "origin_prompt": "Please complete the code given below. \npackage org.ovirt.engine.core.bll;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyList;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.validation.ConstraintViolation;\nimport org.junit.Test;\nimport org.mockito.Mockito;\nimport org.ovirt.engine.core.bll.context.EngineContext;\nimport org.ovirt.engine.core.bll.network.macpoolmanager.MacPoolManagerStrategy;\nimport org.ovirt.engine.core.common.action.ImportVmTemplateParameters;\nimport org.ovirt.engine.core.common.businessentities.BusinessEntitiesDefinitions;\nimport org.ovirt.engine.core.common.businessentities.StorageDomain;\nimport org.ovirt.engine.core.common.businessentities.StorageDomainStatic;\nimport org.ovirt.engine.core.common.businessentities.StorageDomainStatus;\nimport org.ovirt.engine.core.common.businessentities.StorageDomainType;\nimport org.ovirt.engine.core.common.businessentities.StoragePool;\nimport org.ovirt.engine.core.common.businessentities.VDSGroup;\nimport org.ovirt.engine.core.common.businessentities.VmDevice;\nimport org.ovirt.engine.core.common.businessentities.VmTemplate;\nimport org.ovirt.engine.core.common.businessentities.storage.DiskImage;\nimport org.ovirt.engine.core.common.businessentities.storage.StorageType;\nimport org.ovirt.engine.core.common.businessentities.storage.VolumeFormat;\nimport org.ovirt.engine.core.common.businessentities.storage.VolumeType;\nimport org.ovirt.engine.core.common.errors.EngineMessage;\nimport org.ovirt.engine.core.common.queries.VdcQueryParametersBase;\nimport org.ovirt.engine.core.common.queries.VdcQueryReturnValue;\nimport org.ovirt.engine.core.common.queries.VdcQueryType;\nimport org.ovirt.engine.core.common.utils.ValidationUtils;\nimport org.ovirt.engine.core.compat.Guid;\nimport org.ovirt.engine.core.dao.StorageDomainDao;\nimport org.ovirt.engine.core.dao.StorageDomainStaticDao;\nimport org.ovirt.engine.core.dao.StoragePoolDao;\nimport org.ovirt.engine.core.dao.VmTemplateDao;\nimport org.springframework.util.Assert;\npublic class ImportVmTemplateCommandTest {\n    @Test\n    public void insufficientDiskSpace() {\n        // The following is enough since the validation is mocked out anyway. Just want to make sure the flow in CDA is correct.\n        // Full test for the scenarios is done in the inherited class.\n        final ImportVmTemplateCommand command = setupVolumeFormatAndTypeTest(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.NFS);\n        doReturn(false).when(command).validateSpaceRequirements(anyList());\n        assertFalse(command.canDoAction());\n    }\n    @Test\n    public void validVolumeFormatAndTypeCombinations() throws Exception {\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.NFS);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Sparse, StorageType.NFS);\n        assertValidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Sparse, StorageType.NFS);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.ISCSI);\n        assertValidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Sparse, StorageType.ISCSI);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Sparse, StorageType.ISCSI);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.FCP);\n        assertValidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Sparse, StorageType.FCP);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Sparse, StorageType.FCP);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.LOCALFS);\n        assertValidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Sparse, StorageType.LOCALFS);\n        assertValidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Sparse, StorageType.LOCALFS);\n    }\n    @Test\n    public void invalidVolumeFormatAndTypeCombinations() throws Exception {\n        assertInvalidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Preallocated, StorageType.NFS);\n        assertInvalidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Preallocated, StorageType.ISCSI);\n        assertInvalidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Preallocated, StorageType.FCP);\n        assertInvalidVolumeInfoCombination(VolumeFormat.COW, VolumeType.Preallocated, StorageType.LOCALFS);\n        assertInvalidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Unassigned, StorageType.NFS);\n        assertInvalidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Unassigned, StorageType.ISCSI);\n        assertInvalidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Unassigned, StorageType.FCP);\n        assertInvalidVolumeInfoCombination(VolumeFormat.RAW, VolumeType.Unassigned, StorageType.LOCALFS);\n        assertInvalidVolumeInfoCombination(VolumeFormat.Unassigned, VolumeType.Preallocated, StorageType.NFS);\n        assertInvalidVolumeInfoCombination(VolumeFormat.Unassigned, VolumeType.Preallocated, StorageType.ISCSI);\n        assertInvalidVolumeInfoCombination(VolumeFormat.Unassigned, VolumeType.Preallocated, StorageType.FCP);\n        assertInvalidVolumeInfoCombination(VolumeFormat.Unassigned, VolumeType.Preallocated, StorageType.LOCALFS);\n    }\n    public void testValidateUniqueTemplateNameInDC() {\n        ImportVmTemplateCommand command =\n                setupVolumeFormatAndTypeTest(VolumeFormat.RAW, VolumeType.Preallocated, StorageType.NFS);\n        doReturn(true).when(command).isVmTemplateWithSameNameExist();\n        CanDoActionTestUtils.runAndAssertCanDoActionFailure(command,\n                EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);\n    }\n    private void assertValidVolumeInfoCombination(VolumeFormat volumeFormat,\n            VolumeType volumeType,\n            StorageType storageType) {\n        CanDoActionTestUtils.runAndAssertCanDoActionSuccess(\n                setupVolumeFormatAndTypeTest(volumeFormat, volumeType, storageType));\n    }\n    private void assertInvalidVolumeInfoCombination(VolumeFormat volumeFormat,\n            VolumeType volumeType,\n            StorageType storageType) {\n        CanDoActionTestUtils.runAndAssertCanDoActionFailure(\n                setupVolumeFormatAndTypeTest(volumeFormat, volumeType, storageType),\n                EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);\n    }\n    /**\n     * Prepare a command for testing the given volume format and type combination.\n     *\n     * @param volumeFormat\n     *            The volume format of the \"imported\" image.\n     * @param volumeType\n     *            The volume type of the \"imported\" image.\n     * @param storageType\n     *            The target domain's storage type.\n     * @return The command which can be called to test the given combination.\n     */\n    private ImportVmTemplateCommand setupVolumeFormatAndTypeTest(\n            VolumeFormat volumeFormat,\n            VolumeType volumeType,\n            StorageType storageType) {\n        ImportVmTemplateCommand command = spy(new ImportVmTemplateCommand(createParameters()){\n            @Override\n            public VDSGroup getVdsGroup() {\n                return null;\n            }\n        });\n        Backend backend = mock(Backend.class);\n        doReturn(backend).when(command).getBackend();\n        doReturn(false).when(command).isVmTemplateWithSameNameExist();\n        doReturn(true).when(command).isVDSGroupCompatible();\n        doReturn(true).when(command).validateNoDuplicateDiskImages(any(Iterable.class));\n        mockGetTemplatesFromExportDomainQuery(volumeFormat, volumeType, command);\n        mockStorageDomainStatic(command, storageType);\n        doReturn(mock(VmTemplateDao.class)).when(command).getVmTemplateDao();\n        doReturn(Mockito.mock(MacPoolManagerStrategy.class)).when(command).getMacPool();\n        mockStoragePool(command);\n        mockStorageDomains(command);\n        doReturn(true).when(command).setAndValidateDiskProfiles();\n        doReturn(true).when(command).setAndValidateCpuProfile();\n        doReturn(true).when(command).validateSpaceRequirements(anyList());\n        return command;\n    }\n    private static void mockStorageDomains(ImportVmTemplateCommand command) {\n        final ImportVmTemplateParameters parameters = command.getParameters();\n        final StorageDomainDao dao = mock(StorageDomainDao.class);\n        final StorageDomain srcDomain = new StorageDomain();\n        srcDomain.setStorageDomainType(StorageDomainType.ImportExport);\n        srcDomain.setStatus(StorageDomainStatus.Active);\n        when(dao.getForStoragePool(parameters.getSourceDomainId(), parameters.getStoragePoolId()))\n                .thenReturn(srcDomain);\n        final StorageDomain destDomain = new StorageDomain();\n        destDomain.setStorageDomainType(StorageDomainType.Data);\n        destDomain.setUsedDiskSize(0);\n        destDomain.setAvailableDiskSize(1000);\n        destDomain.setStatus(StorageDomainStatus.Active);\n        when(dao.getForStoragePool(parameters.getDestDomainId(), parameters.getStoragePoolId()))\n                .thenReturn(destDomain);\n        doReturn(dao).when(command).getStorageDomainDao();\n    }\n    private static void mockStoragePool(ImportVmTemplateCommand command) {\n        final StoragePoolDao dao = mock(StoragePoolDao.class);\n        final StoragePool pool = new StoragePool();\n        pool.setId(command.getParameters().getStoragePoolId());\n        when(dao.get(any(Guid.class))).thenReturn(pool);\n        doReturn(dao).when(command).getStoragePoolDao();\n    }\n    private static void mockGetTemplatesFromExportDomainQuery(VolumeFormat volumeFormat,\n            VolumeType volumeType,\n            ImportVmTemplateCommand command) {\n        final VdcQueryReturnValue result = new VdcQueryReturnValue();\n        Map<VmTemplate, List<DiskImage>> resultMap = new HashMap<VmTemplate, List<DiskImage>>();\n        DiskImage image = new DiskImage();\n        image.setActualSizeInBytes(2);\n        image.setvolumeFormat(volumeFormat);\n        image.setVolumeType(volumeType);\n        resultMap.put(new VmTemplate(), Arrays.asList(image));\n        result.setReturnValue(resultMap);\n        result.setSucceeded(true);\n        when(command.getBackend().runInternalQuery(eq(VdcQueryType.GetTemplatesFromExportDomain),\n                any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(result);\n    }\n    private static void mockStorageDomainStatic(\n            ImportVmTemplateCommand command,\n            StorageType storageType) {\n        final StorageDomainStaticDao dao = mock(StorageDomainStaticDao.class);\n        final StorageDomainStatic domain = new StorageDomainStatic();\n        domain.setStorageType(storageType);\n        when(dao.get(any(Guid.class))).thenReturn(domain);\n        doReturn(dao).when(command).getStorageDomainStaticDao();\n    }\n    protected ImportVmTemplateParameters createParameters() {\n        VmTemplate t = new VmTemplate();\n        t.setName(\"testTemplate\");\n        final ImportVmTemplateParameters p =\n                new ImportVmTemplateParameters(Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), t);\n        return p;\n    }\n    private final String string100 = \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\" +\n            \"0987654321\";\n    @Test\n    public void testValidateNameSizeImportAsCloned() {\n        checkTemplateName(true, string100);\n    }\n    @Test\n    public void testDoNotValidateNameSizeImport() {\n        checkTemplateName(false, string100);\n    }\n    @Test\n    public void testValidateNameSpecialCharImportAsCloned() {\n        checkTemplateName(true, \"vm_$%$#%#$\");\n    }\n    @Test\n    public void testDoNotValidateNameSpecialCharImport() {\n        checkTemplateName(false, \"vm_$%$#%#$\");\n    }\n    private void checkTemplateName(boolean isImportAsNewEntity, String name) {\nNext line of code:\n",
        "prediction": "       final ImportVmTemplateParameters p =\n                new ImportVmTemplateParameters(Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(),\n                        new VmTemplate());\n        p.setName(name);\n",
        "gold": [
            "        ImportVmTemplateParameters parameters = createParameters();"
        ],
        "time": 3.3686282634735107
    },
    "7": {
        "origin_prompt": "Please complete the code given below. \n\n// This file has been generated by the GUI designer. Do not modify.\nnamespace BlinkStickClient\n{\n\tpublic partial class CpuEditorWidget\n\t{\n\t\tprivate global::Gtk.VBox vbox2;\n\t\t\n\t\tprivate global::Gtk.Frame frame1;\n\t\t\n\t\tprivate global::Gtk.Alignment GtkAlignment;\n\t\t\n\t\tprivate global::Gtk.VBox vbox3;\n\t\t\n\t\tprivate global::Gtk.RadioButton radiobuttonMonitor;\n\t\t\n\t\tprivate global::Gtk.Label labelMonitorHint;\n\t\t\n\t\tprivate global::Gtk.RadioButton radiobuttonAlert;\n\t\t\n\t\tprivate global::Gtk.Label labelAlertHint;\n\t\t\n\t\tprivate global::Gtk.Alignment alignment2;\n\t\t\n\t\tprivate global::Gtk.Table table1;\n\t\t\n\t\tprivate global::Gtk.ComboBox comboboxTriggerType;\n\t\t\n\t\tprivate global::Gtk.Label labelCheck;\n\t\t\n\t\tprivate global::Gtk.Label labelMinutes;\n\t\t\n\t\tprivate global::Gtk.Label labelPercent;\n\t\t\n\t\tprivate global::Gtk.Label labelWhen;\n\t\t\n\t\tprivate global::Gtk.SpinButton spinbuttonCheckPeriod;\n\t\t\n\t\tprivate global::Gtk.SpinButton spinbuttonCpuPercent;\n\t\t\n\t\tprivate global::Gtk.Label GtkLabel2;\n\t\t\n\t\tprivate global::Gtk.Frame frame3;\n\t\t\n\t\tprivate global::Gtk.Alignment GtkAlignment1;\n\t\t\n\t\tprivate global::Gtk.HBox hbox1;\n\t\t\n\t\tprivate global::Gtk.Label labelCurrentValue;\n\t\t\n\t\tprivate global::Gtk.Button buttonRefresh;\n\t\t\n\t\tprivate global::Gtk.Label GtkLabel3;\n\t\tprotected virtual void Build ()\n\t\t{\n\t\t\tglobal::Stetic.Gui.Initialize (this);\n\t\t\t// Widget BlinkStickClient.CpuEditorWidget\n\t\t\tglobal::Stetic.BinContainer.Attach (this);\n\t\t\tthis.Name = \"BlinkStickClient.CpuEditorWidget\";\n\t\t\t// Container child BlinkStickClient.CpuEditorWidget.Gtk.Container+ContainerChild\n\t\t\tthis.vbox2 = new global::Gtk.VBox ();\n\t\t\tthis.vbox2.Name = \"vbox2\";\n\t\t\tthis.vbox2.Spacing = 6;\n\t\t\t// Container child vbox2.Gtk.Box+BoxChild\n\t\t\tthis.frame1 = new global::Gtk.Frame ();\n\t\t\tthis.frame1.Name = \"frame1\";\n\t\t\tthis.frame1.ShadowType = ((global::Gtk.ShadowType)(0));\n\t\t\t// Container child frame1.Gtk.Container+ContainerChild\n\t\t\tthis.GtkAlignment = new global::Gtk.Alignment (0F, 0F, 1F, 1F);\n\t\t\tthis.GtkAlignment.Name = \"GtkAlignment\";\n\t\t\tthis.GtkAlignment.LeftPadding = ((uint)(12));\n\t\t\tthis.GtkAlignment.TopPadding = ((uint)(12));\n\t\t\t// Container child GtkAlignment.Gtk.Container+ContainerChild\n\t\t\tthis.vbox3 = new global::Gtk.VBox ();\n\t\t\tthis.vbox3.Name = \"vbox3\";\n\t\t\tthis.vbox3.Spacing = 6;\n\t\t\t// Container child vbox3.Gtk.Box+BoxChild\n\t\t\tthis.radiobuttonMonitor = new global::Gtk.RadioButton (global::Mono.Unix.Catalog.GetString (\"Monitor\"));\n\t\t\tthis.radiobuttonMonitor.CanFocus = true;\n\t\t\tthis.radiobuttonMonitor.Name = \"radiobuttonMonitor\";\n\t\t\tthis.radiobuttonMonitor.DrawIndicator = true;\n\t\t\tthis.radiobuttonMonitor.UseUnderline = true;\n\t\t\tthis.radiobuttonMonitor.Group = new global::GLib.SList (global::System.IntPtr.Zero);\n\t\t\tthis.vbox3.Add (this.radiobuttonMonitor);\n\t\t\tglobal::Gtk.Box.BoxChild w1 = ((global::Gtk.Box.BoxChild)(this.vbox3 [this.radiobuttonMonitor]));\n\t\t\tw1.Position = 0;\n\t\t\tw1.Expand = false;\n\t\t\tw1.Fill = false;\n\t\t\t// Container child vbox3.Gtk.Box+BoxChild\n\t\t\tthis.labelMonitorHint = new global::Gtk.Label ();\n\t\t\tthis.labelMonitorHint.Name = \"labelMonitorHint\";\n\t\t\tthis.labelMonitorHint.Xpad = 20;\n\t\t\tthis.labelMonitorHint.Xalign = 0F;\n\t\t\tthis.labelMonitorHint.LabelProp = global::Mono.Unix.Catalog.GetString (\"<i>Uses pattern\\'s first animation color to display 0% and second to transition to\" +\n\t\t\t\" 100%. Define a pattern with two Set Color animations for this to take effect</i\" +\n\t\t\t\">\");\n\t\t\tthis.labelMonitorHint.UseMarkup = true;\n\t\t\tthis.labelMonitorHint.Wrap = true;\n\t\t\tthis.vbox3.Add (this.labelMonitorHint);\n\t\t\tglobal::Gtk.Box.BoxChild w2 = ((global::Gtk.Box.BoxChild)(this.vbox3 [this.labelMonitorHint]));\n\t\t\tw2.Position = 1;\n\t\t\tw2.Expand = false;\n\t\t\tw2.Fill = false;\n\t\t\t// Container child vbox3.Gtk.Box+BoxChild\n\t\t\tthis.radiobuttonAlert = new global::Gtk.RadioButton (global::Mono.Unix.Catalog.GetString (\"Alert\"));\n\t\t\tthis.radiobuttonAlert.CanFocus = true;\n\t\t\tthis.radiobuttonAlert.Name = \"radiobuttonAlert\";\n\t\t\tthis.radiobuttonAlert.DrawIndicator = true;\n\t\t\tthis.radiobuttonAlert.UseUnderline = true;\n\t\t\tthis.radiobuttonAlert.Group = this.radiobuttonMonitor.Group;\n\t\t\tthis.vbox3.Add (this.radiobuttonAlert);\n\t\t\tglobal::Gtk.Box.BoxChild w3 = ((global::Gtk.Box.BoxChild)(this.vbox3 [this.radiobuttonAlert]));\n\t\t\tw3.Position = 2;\n\t\t\tw3.Expand = false;\n\t\t\tw3.Fill = false;\n\t\t\t// Container child vbox3.Gtk.Box+BoxChild\n\t\t\tthis.labelAlertHint = new global::Gtk.Label ();\n\t\t\tthis.labelAlertHint.Name = \"labelAlertHint\";\n\t\t\tthis.labelAlertHint.Xpad = 20;\n\t\t\tthis.labelAlertHint.Xalign = 0F;\n\t\t\tthis.labelAlertHint.LabelProp = global::Mono.Unix.Catalog.GetString (\"<i>When event occurs triggers pattern playback</i>\");\n\t\t\tthis.labelAlertHint.UseMarkup = true;\n\t\t\tthis.labelAlertHint.Wrap = true;\n\t\t\tthis.vbox3.Add (this.labelAlertHint);\n\t\t\tglobal::Gtk.Box.BoxChild w4 = ((global::Gtk.Box.BoxChild)(this.vbox3 [this.labelAlertHint]));\n\t\t\tw4.Position = 3;\n\t\t\tw4.Expand = false;\n\t\t\tw4.Fill = false;\n\t\t\t// Container child vbox3.Gtk.Box+BoxChild\n\t\t\tthis.alignment2 = new global::Gtk.Alignment (0.5F, 0.5F, 1F, 1F);\n\t\t\tthis.alignment2.Name = \"alignment2\";\n\t\t\tthis.alignment2.LeftPadding = ((uint)(40));\n\t\t\t// Container child alignment2.Gtk.Container+ContainerChild\n\t\t\tthis.table1 = new global::Gtk.Table (((uint)(2)), ((uint)(5)), false);\n\t\t\tthis.table1.Name = \"table1\";\n\t\t\tthis.table1.RowSpacing = ((uint)(6));\n\t\t\tthis.table1.ColumnSpacing = ((uint)(6));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.comboboxTriggerType = global::Gtk.ComboBox.NewText ();\n\t\t\tthis.comboboxTriggerType.AppendText (global::Mono.Unix.Catalog.GetString (\"increases above\"));\n\t\t\tthis.comboboxTriggerType.AppendText (global::Mono.Unix.Catalog.GetString (\"drops below\"));\n\t\t\tthis.comboboxTriggerType.Name = \"comboboxTriggerType\";\n\t\t\tthis.table1.Add (this.comboboxTriggerType);\n\t\t\tglobal::Gtk.Table.TableChild w5 = ((global::Gtk.Table.TableChild)(this.table1 [this.comboboxTriggerType]));\n\t\t\tw5.LeftAttach = ((uint)(1));\n\t\t\tw5.RightAttach = ((uint)(2));\n\t\t\tw5.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw5.YOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.labelCheck = new global::Gtk.Label ();\n\t\t\tthis.labelCheck.Name = \"labelCheck\";\n\t\t\tthis.labelCheck.Xalign = 1F;\n\t\t\tthis.labelCheck.LabelProp = global::Mono.Unix.Catalog.GetString (\"Check every\");\n\t\t\tthis.table1.Add (this.labelCheck);\n\t\t\tglobal::Gtk.Table.TableChild w6 = ((global::Gtk.Table.TableChild)(this.table1 [this.labelCheck]));\n\t\t\tw6.TopAttach = ((uint)(1));\n\t\t\tw6.BottomAttach = ((uint)(2));\n\t\t\tw6.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw6.YOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.labelMinutes = new global::Gtk.Label ();\n\t\t\tthis.labelMinutes.Name = \"labelMinutes\";\n\t\t\tthis.labelMinutes.Xalign = 0F;\n\t\t\tthis.labelMinutes.LabelProp = global::Mono.Unix.Catalog.GetString (\"min\");\n\t\t\tthis.table1.Add (this.labelMinutes);\n\t\t\tglobal::Gtk.Table.TableChild w7 = ((global::Gtk.Table.TableChild)(this.table1 [this.labelMinutes]));\n\t\t\tw7.TopAttach = ((uint)(1));\n\t\t\tw7.BottomAttach = ((uint)(2));\n\t\t\tw7.LeftAttach = ((uint)(3));\n\t\t\tw7.RightAttach = ((uint)(4));\n\t\t\tw7.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw7.YOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.labelPercent = new global::Gtk.Label ();\n\t\t\tthis.labelPercent.Name = \"labelPercent\";\n\t\t\tthis.labelPercent.Xalign = 0F;\n\t\t\tthis.labelPercent.LabelProp = global::Mono.Unix.Catalog.GetString (\"%\");\n\t\t\tthis.table1.Add (this.labelPercent);\n\t\t\tglobal::Gtk.Table.TableChild w8 = ((global::Gtk.Table.TableChild)(this.table1 [this.labelPercent]));\n\t\t\tw8.LeftAttach = ((uint)(3));\n\t\t\tw8.RightAttach = ((uint)(4));\n\t\t\tw8.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw8.YOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.labelWhen = new global::Gtk.Label ();\n\t\t\tthis.labelWhen.Name = \"labelWhen\";\n\t\t\tthis.labelWhen.Xalign = 1F;\n\t\t\tthis.labelWhen.LabelProp = global::Mono.Unix.Catalog.GetString (\"When\");\n\t\t\tthis.table1.Add (this.labelWhen);\n\t\t\tglobal::Gtk.Table.TableChild w9 = ((global::Gtk.Table.TableChild)(this.table1 [this.labelWhen]));\n\t\t\tw9.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw9.YOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\t// Container child table1.Gtk.Table+TableChild\n\t\t\tthis.spinbuttonCheckPeriod = new global::Gtk.SpinButton (1D, 120D, 1D);\n\t\t\tthis.spinbuttonCheckPeriod.CanFocus = true;\n\t\t\tthis.spinbuttonCheckPeriod.Name = \"spinbuttonCheckPeriod\";\n\t\t\tthis.spinbuttonCheckPeriod.Adjustment.PageIncrement = 10D;\n\t\t\tthis.spinbuttonCheckPeriod.ClimbRate = 1D;\n\t\t\tthis.spinbuttonCheckPeriod.Numeric = true;\n\t\t\tthis.spinbuttonCheckPeriod.Value = 1D;\n\t\t\tthis.table1.Add (this.spinbuttonCheckPeriod);\n\t\t\tglobal::Gtk.Table.TableChild w10 = ((global::Gtk.Table.TableChild)(this.table1 [this.spinbuttonCheckPeriod]));\nNext line of code:\n",
        "prediction": "\t\t\tw10.TopAttach = ((uint)(1));\n\t\t\tw10.BottomAttach = ((uint)(2));\n\t\t\tw10.XOptions = ((global::Gtk.AttachOptions)(4));\n\t\t\tw10.",
        "gold": [
            "\t\t\tw10.TopAttach = ((uint)(1));"
        ],
        "time": 3.383697986602783
    },
    "8": {
        "origin_prompt": "Please complete the code given below. \n/*\n * Copyright (c) 2003-2009 jMonkeyEngine\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of 'jMonkeyEngine' nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.jme.scene;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.util.logging.Logger;\nimport com.jme.intersection.CollisionResults;\nimport com.jme.math.Vector3f;\nimport com.jme.renderer.Renderer;\nimport com.jme.system.JmeException;\nimport com.jme.util.export.InputCapsule;\nimport com.jme.util.export.JMEExporter;\nimport com.jme.util.export.JMEImporter;\nimport com.jme.util.export.OutputCapsule;\nimport com.jme.util.geom.BufferUtils;\n/**\n * <code>QuadMesh</code> defines a geometry mesh. This mesh defines a three\n * dimensional object via a collection of points, colors, normals and textures.\n * The points are referenced via a indices array. This array instructs the\n * renderer the order in which to draw the points, creating quads based on the mode set.\n * \n * @author Joshua Slack\n * @version $Id: $\n */\npublic class QuadMesh extends Geometry implements Serializable {\n    private static final Logger logger = Logger.getLogger(QuadMesh.class\n            .getName());\n    private static final long serialVersionUID = 2L;\n    public enum Mode {\n        /**\n         * Every four vertices referenced by the indexbuffer will be considered\n         * a stand-alone quad.\n         */\n        Quads,\n        /**\n         * The first four vertices referenced by the indexbuffer create a\n         * triangle, from there, every two additional vertices are paired with\n         * the two preceding vertices to make a new quad.\n         */\n        Strip;\n    }\n    protected transient IntBuffer indexBuffer;\n    protected Mode mode = Mode.Quads;\n    protected int quadQuantity;\n    private static Vector3f[] quads;\n    /**\n     * Empty Constructor to be used internally only.\n     */\n    public QuadMesh() {\n        super();\n    }\n    /**\n     * Constructor instantiates a new <code>TriMesh</code> object.\n     * \n     * @param name\n     *            the name of the scene element. This is required for\n     *            identification and comparision purposes.\n     */\n    public QuadMesh(String name) {\n        super(name);\n    }\n    /**\n     * Constructor instantiates a new <code>TriMesh</code> object. Provided\n     * are the attributes that make up the mesh all attributes may be null,\n     * except for vertices and indices.\n     * \n     * @param name\n     *            the name of the scene element. This is required for\n     *            identification and comparision purposes.\n     * @param vertices\n     *            the vertices of the geometry.\n     * @param normal\n     *            the normals of the geometry.\n     * @param color\n     *            the colors of the geometry.\n     * @param coords\n     *            the texture coordinates of the mesh.\n     * @param indices\n     *            the indices of the vertex array.\n     */\n    public QuadMesh(String name, FloatBuffer vertices, FloatBuffer normal,\n            FloatBuffer color, TexCoords coords, IntBuffer indices) {\n        super(name);\n        reconstruct(vertices, normal, color, coords);\n        if (null == indices) {\n            logger.severe(\"Indices may not be null.\");\n            throw new JmeException(\"Indices may not be null.\");\n        }\n        setIndexBuffer(indices);\n        logger.info(\"QuadMesh created.\");\n    }\n    /**\n     * Recreates the geometric information of this TriMesh from scratch. The\n     * index and vertex array must not be null, but the others may be. Every 3\n     * indices define an index in the <code>vertices</code> array that\n     * refrences a vertex of a triangle.\n     * \n     * @param vertices\n     *            The vertex information for this TriMesh.\n     * @param normal\n     *            The normal information for this TriMesh.\n     * @param color\n     *            The color information for this TriMesh.\n     * @param coords\n     *            The texture information for this TriMesh.\n     * @param indices\n     *            The index information for this TriMesh.\n     */\n    public void reconstruct(FloatBuffer vertices, FloatBuffer normal,\n            FloatBuffer color, TexCoords coords, IntBuffer indices) {\n        super.reconstruct(vertices, normal, color, coords);\n        if (null == indices) {\n            logger.severe(\"Indices may not be null.\");\n            throw new JmeException(\"Indices may not be null.\");\n        }\n        setIndexBuffer(indices);\n    }\n    public void setMode(Mode mode) {\n        this.mode = mode;\n    }\n    public Mode getMode() {\n        return mode;\n    }\n    public IntBuffer getIndexBuffer() {\n        return indexBuffer;\n    }\n    public void setIndexBuffer(IntBuffer indices) {\n        this.indexBuffer = indices;\n        recalcQuadQuantity();\n    }\n    protected void recalcQuadQuantity() {\n        if (indexBuffer == null) {\n            quadQuantity = 0;\n            return;\n        }\n        \n        switch (mode) {\n            case Quads:\n                quadQuantity = indexBuffer.limit() / 4;\n                break;\n            case Strip:\n                quadQuantity = indexBuffer.limit() / 2 - 1;\n                break;\n        }\n    }\n    /**\n     * Returns the number of triangles contained in this mesh.\n     */\n    public int getQuadCount() {\n        return quadQuantity;\n    }\n    public void setQuadQuantity(int quadQuantity) {\n        this.quadQuantity = quadQuantity;\n    }\n    /**\n     * Clears the buffers of this QuadMesh. The buffers include its indexBuffer\n     * only.\n     */\n    public void clearBuffers() {\n        super.clearBuffers();\n        setIndexBuffer(null);\n    }\n    \n    public static Vector3f[] getQuads() {\n        return quads;\n    }\n    public static void setQuads(Vector3f[] quads) {\n        QuadMesh.quads = quads;\n    }\n    /**\n     * Stores in the <code>storage</code> array the indices of quad\n     * <code>i</code>. If <code>i</code> is an invalid index, or if\n     * <code>storage.length<4</code>, then nothing happens\n     * \n     * @param i\n     *            The index of the quad to get.\n     * @param storage\n     *            The array that will hold the i's indexes.\n     */\n    public void getQuad(int i, int[] storage) {\n        if (i < getQuadCount() && storage.length >= 4) {\n            IntBuffer indices = getIndexBuffer();\n            storage[0] = indices.get(getVertIndex(i, 0));\n            storage[1] = indices.get(getVertIndex(i, 1));\n            storage[2] = indices.get(getVertIndex(i, 2));\n            storage[3] = indices.get(getVertIndex(i, 3));\n        }\n    }\n    /**\n     * Stores in the <code>vertices</code> array the vertex values of quad\n     * <code>i</code>. If <code>i</code> is an invalid quad index,\n     * nothing happens.\n     * \n     * @param i\n     * @param vertices\n     */\n    public void getQuad(int i, Vector3f[] vertices) {\n        if (i < getQuadCount() && i >= 0) {\n            for (int x = 0; x < 4; x++) {\n                if (vertices[x] == null)\nNext line of code:\n",
        "prediction": "               vertices[x] = getVert(getVertIndex(i, x));\n            }\n        }\n    }\n    /**\n     * Stores in the <code>normals</code> array the normal values of quad\n     * <code>i</code>. If <code>",
        "gold": [
            "                    vertices[x] = new Vector3f();"
        ],
        "time": 3.361654043197632
    },
    "9": {
        "origin_prompt": "Please complete the code given below. \nusing System;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\nnamespace mRemoteNG.UI.TaskDialog\n{\n  public sealed partial class CommandButton : Button\n  {\n    //--------------------------------------------------------------------------------\n    #region PRIVATE MEMBERS\n    //--------------------------------------------------------------------------------\n    Image imgArrow1;\n    Image imgArrow2;\n    const int LEFT_MARGIN = 10;\n    const int TOP_MARGIN = 10;\n    const int ARROW_WIDTH = 19;\n    enum eButtonState { Normal, MouseOver, Down }\n    eButtonState m_State = eButtonState.Normal;\n    #endregion\n    //--------------------------------------------------------------------------------\n    #region PUBLIC PROPERTIES\n    //--------------------------------------------------------------------------------\n    // Override this to make sure the control is invalidated (repainted) when 'Text' is changed\n    public override string Text\n    {\n      get { return base.Text; }\n      set\n      {\n        base.Text = value;\n        if (m_autoHeight)\n          Height = GetBestHeight();\n        Invalidate(); \n      }\n    }\n    // SmallFont is the font used for secondary lines\n      private Font SmallFont { get; set; }\n      // AutoHeight determines whether the button automatically resizes itself to fit the Text\n    bool m_autoHeight = true;\n    [Browsable(true)]\n    [Category(\"Behavior\")]\n    [DefaultValue(true)]\n    public bool AutoHeight { get { return m_autoHeight; } set { m_autoHeight = value; if (m_autoHeight) Invalidate(); } }\n    #endregion\n    //--------------------------------------------------------------------------------\n    #region CONSTRUCTOR\n    //--------------------------------------------------------------------------------\n    public CommandButton()\n    {\n      InitializeComponent();\n      Font = new Font(\"Segoe UI\", 11.75F, FontStyle.Regular, GraphicsUnit.Point, 0);\n      SmallFont = new Font(\"Segoe UI\", 8F, FontStyle.Regular, GraphicsUnit.Point, 0);\n    }\n    \n    #endregion\n    //--------------------------------------------------------------------------------\n    #region PUBLIC ROUTINES\n    //--------------------------------------------------------------------------------\n    public int GetBestHeight()\n    {\n      return (TOP_MARGIN * 2) + (int)GetSmallTextSizeF().Height + (int)GetLargeTextSizeF().Height;\n    }\n    #endregion\n    //--------------------------------------------------------------------------------\n    #region PRIVATE ROUTINES\n    //--------------------------------------------------------------------------------\n    string GetLargeText()\n    {\n      string[] lines = Text.Split('\\n');\n      return lines[0];\n    }\n    string GetSmallText()\n    {\n      if (Text.IndexOf('\\n') < 0)\n        return \"\";\n      string s = Text;\n      string[] lines = s.Split('\\n');\n      s = \"\";\n      for (int i = 1; i < lines.Length; i++)\n        s += lines[i] + \"\\n\";\n      return s.Trim('\\n');\n    }\n    SizeF GetLargeTextSizeF()\n    {\n      int x = LEFT_MARGIN + ARROW_WIDTH + 5;\n      SizeF mzSize = new SizeF(Width - x - LEFT_MARGIN, 5000.0F);  // presume RIGHT_MARGIN = LEFT_MARGIN\n      Graphics g = Graphics.FromHwnd(Handle);\n      SizeF textSize = g.MeasureString(GetLargeText(), Font, mzSize);\n      return textSize;\n    }\n    SizeF GetSmallTextSizeF()\n    {\n      string s = GetSmallText();\n      if (s == \"\") return new SizeF(0, 0);\n      int x = LEFT_MARGIN + ARROW_WIDTH + 8; // <- indent small text slightly more\n      SizeF mzSize = new SizeF(Width - x - LEFT_MARGIN, 5000.0F);  // presume RIGHT_MARGIN = LEFT_MARGIN\n      Graphics g = Graphics.FromHwnd(Handle);\n      SizeF textSize = g.MeasureString(s, SmallFont, mzSize);\n      return textSize;\n    }\n    #endregion\n    //--------------------------------------------------------------------------------\n    #region OVERRIDEs\n    //--------------------------------------------------------------------------------\n    protected override void OnCreateControl()\n    {\n        base.OnCreateControl();\n        imgArrow1 = Resources.green_arrow1;\n        imgArrow2 = Resources.green_arrow2;\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnPaint(PaintEventArgs e)\n    {\n      e.Graphics.SmoothingMode = SmoothingMode.HighQuality;\n      e.Graphics.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;\n      LinearGradientBrush brush;\n      LinearGradientMode mode = LinearGradientMode.Vertical;\n      Rectangle newRect = new Rectangle(ClientRectangle.X, ClientRectangle.Y, ClientRectangle.Width - 1, ClientRectangle.Height - 1);\n      Color text_color = SystemColors.WindowText;\n      Image img = imgArrow1;\n      \n      if (Enabled)\n      {\n        switch (m_State)\n        {\n          case eButtonState.Normal:\n            e.Graphics.FillRectangle(SystemBrushes.Control, newRect);\n                e.Graphics.DrawRectangle(Focused ? new Pen(Color.Silver, 1) : new Pen(SystemColors.Control, 1), newRect);\n                text_color = Color.DarkBlue;\n            break;\n          case eButtonState.MouseOver:\n            brush = new LinearGradientBrush(newRect, SystemColors.Control, SystemColors.Control, mode);\n            e.Graphics.FillRectangle(brush, newRect);\n            e.Graphics.DrawRectangle(new Pen(Color.Silver, 1), newRect);\n            img = imgArrow2;\n            text_color = Color.Blue;\n            break;\n          case eButtonState.Down:\n            brush = new LinearGradientBrush(newRect, SystemColors.Control, SystemColors.Control, mode);\n            e.Graphics.FillRectangle(brush, newRect);\n            e.Graphics.DrawRectangle(new Pen(Color.DarkGray, 1), newRect);\n            text_color = Color.DarkBlue;\n            break;\n        }\n      }\n      else\n      {\n        brush = new LinearGradientBrush(newRect, SystemColors.Control, SystemColors.Control, mode);\n        e.Graphics.FillRectangle(brush, newRect);\n        e.Graphics.DrawRectangle(new Pen(Color.DarkGray, 1), newRect);\n        text_color = Color.DarkBlue;\n      }\n      string largetext = GetLargeText();\n      string smalltext = GetSmallText();\n      SizeF szL = GetLargeTextSizeF();\n      //e.Graphics.DrawString(largetext, base.Font, new SolidBrush(text_color), new RectangleF(new PointF(LEFT_MARGIN + imgArrow1.Width + 5, TOP_MARGIN), szL));\n      TextRenderer.DrawText(e.Graphics, largetext, Font, new Rectangle(LEFT_MARGIN + imgArrow1.Width + 5, TOP_MARGIN, (int)szL.Width, (int)szL.Height), text_color, TextFormatFlags.Default);\n      if (smalltext != \"\")\n      {\n        SizeF szS = GetSmallTextSizeF();\n        e.Graphics.DrawString(smalltext, SmallFont, new SolidBrush(text_color), new RectangleF(new PointF(LEFT_MARGIN + imgArrow1.Width + 8, TOP_MARGIN + (int)szL.Height), szS));\n      }\n      e.Graphics.DrawImage(img, new Point(LEFT_MARGIN, TOP_MARGIN + (int)(szL.Height / 2) - img.Height / 2));\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnMouseLeave(EventArgs e)\n    {\n      m_State = eButtonState.Normal;\n      Invalidate();\n      base.OnMouseLeave(e);\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnMouseEnter(EventArgs e)\n    {\n      m_State = eButtonState.MouseOver;\n      Invalidate();\n      base.OnMouseEnter(e);\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnMouseUp(MouseEventArgs e)\n    {\n      m_State = eButtonState.MouseOver;\n      Invalidate();\n      base.OnMouseUp(e);\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnMouseDown(MouseEventArgs e)\n    {\n      m_State = eButtonState.Down;\n      Invalidate();\n      base.OnMouseDown(e);\n    }\n    //--------------------------------------------------------------------------------\n    protected override void OnSizeChanged(EventArgs e)\n    {\n      if (m_autoHeight)\n      {\nNext line of code:\n",
        "prediction": "       SizeF szL = GetLargeTextSizeF();\n        SizeF szS = GetSmallTextSizeF();\n        SizeF sz = new SizeF(Width - LEFT_MARGIN - RIGHT_MARGIN - imgArrow1.Width - imgArrow",
        "gold": [
            "        int h = GetBestHeight();"
        ],
        "time": 3.3637633323669434
    },
    "10": {
        "origin_prompt": "Please complete the code given below. \n#\n# Copyright (C) 2019  Red Hat, Inc.\n#\n# This copyrighted material is made available to anyone wishing to use,\n# modify, copy, or redistribute it subject to the terms and conditions of\n# the GNU General Public License v.2, or (at your option) any later version.\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY expressed or implied, including the implied warranties of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General\n# Public License for more details.  You should have received a copy of the\n# GNU General Public License along with this program; if not, write to the\n# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the\n# source code or documentation are not subject to the GNU General Public\n# License and may only be used or replicated with the express permission of\n# Red Hat, Inc.\n#\nfrom collections import OrderedDict, namedtuple\nfrom pyanaconda.core.constants import PayloadRequirementType\nfrom pyanaconda.payload.errors import PayloadRequirementsMissingApply\nfrom pyanaconda.anaconda_loggers import get_module_logger\nlog = get_module_logger(__name__)\nPayloadRequirementReason = namedtuple('PayloadRequirementReason', ['reason', 'strong'])\n__all__ = [\"PayloadRequirements\", \"PayloadRequirement\"]\nclass PayloadRequirement(object):\n    \"\"\"An object to store a payload requirement with info about its reasons.\n    For each requirement multiple reasons together with their strength\n    can be stored in this object using the add_reason method.\n    A reason should be just a string with description (ie for tracking purposes).\n    Strength is a boolean flag that can be used to indicate whether missing the\n    requirement should be considered fatal. Strength of the requirement is\n    given by strength of all its reasons.\n    \"\"\"\n    def __init__(self, req_id, reasons=None):\n        self._id = req_id\n        self._reasons = reasons or []\n    @property\n    def id(self):\n        \"\"\"Identifier of the requirement (eg a package name)\"\"\"\n        return self._id\n    @property\n    def reasons(self):\n        \"\"\"List of reasons for the requirement\"\"\"\n        return [reason for reason, strong in self._reasons]\n    @property\n    def strong(self):\n        \"\"\"Strength of the requirement (ie should it be considered fatal?)\"\"\"\n        return any(strong for reason, strong in self._reasons)\n    def add_reason(self, reason, strong=False):\n        \"\"\"Adds a reason to the requirement with optional strength of the reason\"\"\"\n        self._reasons.append(PayloadRequirementReason(reason, strong))\n    def __str__(self):\n        return \"PayloadRequirement(id=%s, reasons=%s, strong=%s)\" % (self.id,\n                                                                     self.reasons,\n                                                                     self.strong)\n    def __repr__(self):\n        return 'PayloadRequirement(id=%s, reasons=%s)' % (self.id, self._reasons)\nclass PayloadRequirements(object):\n    \"\"\"A container for payload requirements imposed by installed functionality.\n    Stores names of packages and groups required by used installer features,\n    together with descriptions of reasons why the object is required and if the\n    requirement is strong. Not satisfying strong requirement would be fatal for\n    installation.\n    \"\"\"\n    def __init__(self):\n        self._apply_called_for_all_requirements = True\n        self._apply_cb = None\n        self._reqs = {}\n        for req_type in PayloadRequirementType:\n            self._reqs[req_type] = OrderedDict()\n    def add_packages(self, package_names, reason, strong=True):\n        \"\"\"Add packages required for the reason.\n        If a package is already required, the new reason will be\n        added and the strength of the requirement will be updated.\n        :param package_names: names of packages to be added\n        :type package_names: list of str\n        :param reason: description of reason for adding the packages\n        :type reason: str\n        :param strong: is the requirement strong (ie is not satisfying it fatal?)\n        :type strong: bool\n        \"\"\"\n        self._add(PayloadRequirementType.package, package_names, reason, strong)\n    def add_groups(self, group_ids, reason, strong=True):\n        \"\"\"Add groups required for the reason.\n        If a group is already required, the new reason will be\n        added and the strength of the requirement will be updated.\n        :param group_ids: ids of groups to be added\n        :type group_ids: list of str\n        :param reason: descripiton of reason for adding the groups\n        :type reason: str\n        :param strong: is the requirement strong\n        :type strong: bool\n        \"\"\"\n        self._add(PayloadRequirementType.group, group_ids, reason, strong)\n    def add_requirements(self, requirements):\n        \"\"\"Add requirements from a list of Requirement instances.\n        :param requirements: list of Requirement instances\n        \"\"\"\n        for requirement in requirements:\n            # check requirement type and add a payload requirement appropriately\n            if requirement.type == \"package\":\n                self.add_packages([requirement.name], reason=requirement.reason)\n            elif requirement.type == \"group\":\n                self.add_groups([requirement.name], reason=requirement.reason)\n            else:\n                log.warning(\"Unknown type: %s in requirement: %s, skipping.\", requirement.type, requirement)\n    def _add(self, req_type, ids, reason, strong):\n        if not ids:\n            log.debug(\"no %s requirement added for %s\", req_type.value, reason)\n        reqs = self._reqs[req_type]\n        for r_id in ids:\n            if r_id not in reqs:\n                reqs[r_id] = PayloadRequirement(r_id)\n            reqs[r_id].add_reason(reason, strong)\n            self._apply_called_for_all_requirements = False\n            log.debug(\"added %s requirement '%s' for %s, strong=%s\",\n                      req_type.value, r_id, reason, strong)\n    @property\n    def packages(self):\n        \"\"\"List of package requirements.\n        return: list of package requirements\n        rtype: list of PayloadRequirement\n        \"\"\"\n        return list(self._reqs[PayloadRequirementType.package].values())\n    @property\n    def groups(self):\n        \"\"\"List of group requirements.\n        return: list of group requirements\n        rtype: list of PayloadRequirement\n        \"\"\"\n        return list(self._reqs[PayloadRequirementType.group].values())\n    def set_apply_callback(self, callback):\n        \"\"\"Set the callback for applying requirements.\n        The callback will be called by apply() method.\n        param callback: callback function to be called by apply() method\n        type callback: a function taking one argument (requirements object)\n        \"\"\"\n        self._apply_cb = callback\n    def apply(self):\n        \"\"\"Apply requirements using callback function.\n        Calls the callback supplied via set_apply_callback() method. If no\n        callback was set, an axception is raised.\n        return: return value of the callback\n        rtype: type of the callback return value\n        raise PayloadRequirementsMissingApply: if there is no callback set\n        \"\"\"\n        if self._apply_cb:\n            self._apply_called_for_all_requirements = True\n            rv = self._apply_cb(self)\n            log.debug(\"apply with result %s called on requirements %s\", rv, self)\n            return rv\n        else:\n            raise PayloadRequirementsMissingApply\n    @property\n    def applied(self):\n        \"\"\"Was all requirements applied?\n        return: Was apply called for all current requirements?\n        rtype: bool\n        \"\"\"\n        return self.empty or self._apply_called_for_all_requirements\n    @property\n    def empty(self):\n        \"\"\"Are requirements empty?\n        return: True if there are no requirements, else False\n        rtype: bool\n        \"\"\"\nNext line of code:\n",
        "prediction": "   reqs = PayloadRequirements()\n    reqs.add_packages([\"foo\", \"bar\"], \"reason\", True)\n    reqs.add_groups([\"group1\", \"group2\"], \"reason\", True)\n    reqs.apply()\n    assert reqs",
        "gold": [
            "        return not any(self._reqs.values())"
        ],
        "time": 3.360574960708618
    },
    "11": {
        "origin_prompt": "Please complete the code given below. \n#!/usr/bin/python\n# -*-*- encoding: utf-8 -*-*-\n#\n# Copyright (C) 2006 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n__author__ = 'j.s@google.com (Jeff Scudder)'\nimport sys\nimport unittest\ntry:\n  from xml.etree import ElementTree\nexcept ImportError:\n  from elementtree import ElementTree\nimport atom\nfrom gdata import test_data\nimport gdata.test_config as conf\nclass AuthorTest(unittest.TestCase):\n  \n  def setUp(self):\n    self.author = atom.Author()\n    \n  def testEmptyAuthorShouldHaveEmptyExtensionsList(self):\n    self.assert_(isinstance(self.author.extension_elements, list))\n    self.assert_(len(self.author.extension_elements) == 0)\n    \n  def testNormalAuthorShouldHaveNoExtensionElements(self):\n    self.author.name = atom.Name(text='Jeff Scudder')\n    self.assert_(self.author.name.text == 'Jeff Scudder')\n    self.assert_(len(self.author.extension_elements) == 0)\n    new_author = atom.AuthorFromString(self.author.ToString())\n    self.assert_(len(self.author.extension_elements) == 0)\n    \n    self.author.extension_elements.append(atom.ExtensionElement(\n        'foo', text='bar'))\n    self.assert_(len(self.author.extension_elements) == 1)\n    self.assert_(self.author.name.text == 'Jeff Scudder')\n    new_author = atom.AuthorFromString(self.author.ToString())\n    self.assert_(len(self.author.extension_elements) == 1)\n    self.assert_(new_author.name.text == 'Jeff Scudder')\n  def testEmptyAuthorToAndFromStringShouldMatch(self):\n    string_from_author = self.author.ToString()\n    new_author = atom.AuthorFromString(string_from_author)\n    string_from_new_author = new_author.ToString()\n    self.assert_(string_from_author == string_from_new_author)\n    \n  def testAuthorWithNameToAndFromStringShouldMatch(self):\n    self.author.name = atom.Name()\n    self.author.name.text = 'Jeff Scudder'\n    string_from_author = self.author.ToString()\n    new_author = atom.AuthorFromString(string_from_author)\n    string_from_new_author = new_author.ToString()\n    self.assert_(string_from_author == string_from_new_author)\n    self.assert_(self.author.name.text == new_author.name.text)\n  \n  def testExtensionElements(self):\n    self.author.extension_attributes['foo1'] = 'bar'\n    self.author.extension_attributes['foo2'] = 'rab'\n    self.assert_(self.author.extension_attributes['foo1'] == 'bar')\n    self.assert_(self.author.extension_attributes['foo2'] == 'rab')\n    new_author = atom.AuthorFromString(self.author.ToString())\n    self.assert_(new_author.extension_attributes['foo1'] == 'bar')\n    self.assert_(new_author.extension_attributes['foo2'] == 'rab')\n    \n  def testConvertFullAuthorToAndFromString(self):\n    author = atom.AuthorFromString(test_data.TEST_AUTHOR)\n    self.assert_(author.name.text == 'John Doe')\n    self.assert_(author.email.text == 'johndoes@someemailadress.com')\n    self.assert_(author.uri.text == 'http://www.google.com')\n    \n    \nclass EmailTest(unittest.TestCase):\n  \n  def setUp(self):\n    self.email = atom.Email()\n    \n  def testEmailToAndFromString(self):\n    self.email.text = 'This is a test'\n    new_email = atom.EmailFromString(self.email.ToString())\n    self.assert_(self.email.text == new_email.text)\n    self.assert_(self.email.extension_elements == \n        new_email.extension_elements)\n    \n  \nclass NameTest(unittest.TestCase):\n  def setUp(self):\n    self.name = atom.Name()\n    \n  def testEmptyNameToAndFromStringShouldMatch(self):\n    string_from_name = self.name.ToString()\n    new_name = atom.NameFromString(string_from_name)\n    string_from_new_name = new_name.ToString()\n    self.assert_(string_from_name == string_from_new_name)\n    \n  def testText(self):\n    self.assert_(self.name.text is None)\n    self.name.text = 'Jeff Scudder'\n    self.assert_(self.name.text == 'Jeff Scudder')\n    new_name = atom.NameFromString(self.name.ToString())\n    self.assert_(new_name.text == self.name.text)\n    \n  def testExtensionElements(self):\n    self.name.extension_attributes['foo'] = 'bar'\n    self.assert_(self.name.extension_attributes['foo'] == 'bar')\n    new_name = atom.NameFromString(self.name.ToString())\n    self.assert_(new_name.extension_attributes['foo'] == 'bar')\n    \n    \nclass ExtensionElementTest(unittest.TestCase):\n  \n  def setUp(self):\n    self.ee = atom.ExtensionElement('foo')\n    \n  def testEmptyEEShouldProduceEmptyString(self):\n    pass\n    \n  def testEEParsesTreeCorrectly(self):\n    deep_tree = atom.ExtensionElementFromString(test_data.EXTENSION_TREE)\n    self.assert_(deep_tree.tag == 'feed')\n    self.assert_(deep_tree.namespace == 'http://www.w3.org/2005/Atom')\n    self.assert_(deep_tree.children[0].tag == 'author')\n    self.assert_(deep_tree.children[0].namespace == 'http://www.google.com')\n    self.assert_(deep_tree.children[0].children[0].tag == 'name')\n    self.assert_(deep_tree.children[0].children[0].namespace == \n        'http://www.google.com')\n    self.assert_(deep_tree.children[0].children[0].text.strip() == 'John Doe')\n    self.assert_(deep_tree.children[0].children[0].children[0].text.strip() ==\n        'Bar')\n    foo = deep_tree.children[0].children[0].children[0]\n    self.assert_(foo.tag == 'foo')\n    self.assert_(foo.namespace == 'http://www.google.com')\n    self.assert_(foo.attributes['up'] == 'down')\n    self.assert_(foo.attributes['yes'] == 'no')\n    self.assert_(foo.children == [])\n  \n  def testEEToAndFromStringShouldMatch(self):\n    string_from_ee = self.ee.ToString()\n    new_ee = atom.ExtensionElementFromString(string_from_ee)\n    string_from_new_ee = new_ee.ToString()\n    self.assert_(string_from_ee == string_from_new_ee)\n    \n    deep_tree = atom.ExtensionElementFromString(test_data.EXTENSION_TREE)    \n    string_from_deep_tree = deep_tree.ToString()\n    new_deep_tree = atom.ExtensionElementFromString(string_from_deep_tree)\n    string_from_new_deep_tree = new_deep_tree.ToString()\n    self.assert_(string_from_deep_tree == string_from_new_deep_tree)\n    \n    \nclass LinkTest(unittest.TestCase):\n  \n  def setUp(self):\n    self.link = atom.Link()\n    \n  def testLinkToAndFromString(self):\n    self.link.href = 'test href'\n    self.link.hreflang = 'english'\n    self.link.type = 'text/html'\n    self.link.extension_attributes['foo'] = 'bar'\n    self.assert_(self.link.href == 'test href')\n    self.assert_(self.link.hreflang == 'english')\n    self.assert_(self.link.type == 'text/html')\n    self.assert_(self.link.extension_attributes['foo'] == 'bar')\n    new_link = atom.LinkFromString(self.link.ToString())\n    self.assert_(self.link.href == new_link.href)\n    self.assert_(self.link.type == new_link.type)\n    self.assert_(self.link.hreflang == new_link.hreflang)\n    self.assert_(self.link.extension_attributes['foo'] == \n        new_link.extension_attributes['foo'])\n  def testLinkType(self):\n    test_link = atom.Link(link_type='text/html')\n    self.assert_(test_link.type == 'text/html')\nclass GeneratorTest(unittest.TestCase):\n  def setUp(self):\n    self.generator = atom.Generator()\n  def testGeneratorToAndFromString(self):\n    self.generator.uri = 'www.google.com'\n    self.generator.version = '1.0'\n    self.generator.extension_attributes['foo'] = 'bar'\n    self.assert_(self.generator.uri == 'www.google.com')\n    self.assert_(self.generator.version == '1.0')\n    self.assert_(self.generator.extension_attributes['foo'] == 'bar')\n    new_generator = atom.GeneratorFromString(self.generator.ToString())\n    self.assert_(self.generator.uri == new_generator.uri)\n    self.assert_(self.generator.version == new_generator.version)\n    self.assert_(self.generator.extension_attributes['foo'] ==\n        new_generator.extension_attributes['foo'])\nclass TitleTest(unittest.TestCase):\n  def setUp(self):\n    self.title = atom.Title()\n  def testTitleToAndFromString(self):\n    self.title.type = 'text'\n    self.title.text = 'Less: &lt;'\n    self.assert_(self.title.type == 'text')\n    self.assert_(self.title.text == 'Less: &lt;')\n    new_title = atom.TitleFromString(self.title.ToString())\n    self.assert_(self.title.type == new_title.type)\n    self.assert_(self.title.text == new_title.text)\nclass SubtitleTest(unittest.TestCase):\n  def setUp(self):\n    self.subtitle = atom.Subtitle()\n  def testTitleToAndFromString(self):\n    self.subtitle.type = 'text'\n    self.subtitle.text = 'sub & title'\n    self.assert_(self.subtitle.type == 'text')\n    self.assert_(self.subtitle.text == 'sub & title')\n    new_subtitle = atom.SubtitleFromString(self.subtitle.ToString())\n    self.assert_(self.subtitle.type == new_subtitle.type)\n    self.assert_(self.subtitle.text == new_subtitle.text)\nclass SummaryTest(unittest.TestCase):\n  def setUp(self):\n    self.summary = atom.Summary()\n  def testTitleToAndFromString(self):\n    self.summary.type = 'text'\n    self.summary.text = 'Less: &lt;'\n    self.assert_(self.summary.type == 'text')\n    self.assert_(self.summary.text == 'Less: &lt;')\n    new_summary = atom.SummaryFromString(self.summary.ToString())\n    self.assert_(self.summary.type == new_summary.type)\n    self.assert_(self.summary.text == new_summary.text)\nclass CategoryTest(unittest.TestCase):\n  def setUp(self):\nNext line of code:\n",
        "prediction": "   self.category = atom.Category()\n  def testCategoryToAndFromString(self):\n    self.category.term = 'test'\n    self.category.scheme = 'http://www.example.com/test'\n    self.category.label = 'test label'",
        "gold": [
            "    self.category = atom.Category()"
        ],
        "time": 3.359083652496338
    },
    "12": {
        "origin_prompt": "Please complete the code given below. \n\"\"\"\nBuilds out filesystem trees/data based on the object tree.\nThis is the code behind 'cobbler sync'.\nCopyright 2006-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\nimport os\nimport os.path\nimport glob\nimport shutil\nimport time\nimport yaml # Howell-Clark version\nimport sys\nimport glob\nimport traceback\nimport errno\nimport utils\nfrom cexceptions import *\nimport templar \nimport pxegen\nimport item_distro\nimport item_profile\nimport item_repo\nimport item_system\nfrom Cheetah.Template import Template\nimport clogger\nfrom utils import _\nimport cobbler.module_loader as module_loader\nclass BootSync:\n    \"\"\"\n    Handles conversion of internal state to the tftpboot tree layout\n    \"\"\"\n    def __init__(self,config,verbose=True,dhcp=None,dns=None,logger=None,tftpd=None):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.logger         = logger\n        if logger is None:\n            self.logger     = clogger.Logger()\n        self.verbose      = verbose\n        self.config       = config\n        self.api          = config.api\n        self.distros      = config.distros()\n        self.profiles     = config.profiles()\n        self.systems      = config.systems()\n        self.settings     = config.settings()\n        self.repos        = config.repos()\n        self.templar      = templar.Templar(config, self.logger)\n        self.pxegen       = pxegen.PXEGen(config, self.logger)\n        self.dns          = dns\n        self.dhcp         = dhcp\n        self.tftpd        = tftpd\n        self.bootloc      = utils.tftpboot_location()\n        self.pxegen.verbose = verbose\n        self.dns.verbose    = verbose\n        self.dhcp.verbose   = verbose\n        self.pxelinux_dir = os.path.join(self.bootloc, \"pxelinux.cfg\")\n        self.grub_dir = os.path.join(self.bootloc, \"grub\")\n        self.images_dir = os.path.join(self.bootloc, \"images\")\n        self.yaboot_bin_dir = os.path.join(self.bootloc, \"ppc\")\n        self.yaboot_cfg_dir = os.path.join(self.bootloc, \"etc\")\n        self.s390_dir = os.path.join(self.bootloc, \"s390x\")\n        self.rendered_dir = os.path.join(self.settings.webdir, \"rendered\")\n    def run(self):\n        \"\"\"\n        Syncs the current configuration file with the config tree.\n        Using the Check().run_ functions previously is recommended\n        \"\"\"\n        if not os.path.exists(self.bootloc):\n            utils.die(self.logger,\"cannot find directory: %s\" % self.bootloc)\n        self.logger.info(\"running pre-sync triggers\")\n        # run pre-triggers...\n        utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/sync/pre/*\")\n        self.distros  = self.config.distros()\n        self.profiles = self.config.profiles()\n        self.systems  = self.config.systems()\n        self.settings = self.config.settings()\n        self.repos    = self.config.repos()\n        # execute the core of the sync operation\n        self.logger.info(\"cleaning trees\")\n        self.clean_trees()\n        # Have the tftpd module handle copying bootloaders,\n        # distros, images, and all_system_files\n        self.tftpd.sync(self.verbose)\n        # Copy distros to the webdir\n        # Adding in the exception handling to not blow up if files have\n        # been moved (or the path references an NFS directory that's no longer\n        # mounted)\n\tfor d in self.distros:\n            try:\n                self.logger.info(\"copying files for distro: %s\" % d.name)\n                self.pxegen.copy_single_distro_files(d,\n                                                     self.settings.webdir,True)\n                self.pxegen.write_templates(d,write_file=True)\n            except CX, e:\n                self.logger.error(e.value)\n        # make the default pxe menu anyway...\n        self.pxegen.make_pxe_menu()\n        if self.settings.manage_dhcp:\n            self.write_dhcp()\n        if self.settings.manage_dns:\n            self.logger.info(\"rendering DNS files\")\n            self.dns.regen_hosts()\n            self.dns.write_dns_files()\n        if self.settings.manage_tftpd:\n           # xinetd.d/tftpd, basically\n           self.logger.info(\"rendering TFTPD files\")\n           self.tftpd.write_tftpd_files()\n           # copy in boot_files\n           self.tftpd.write_boot_files()\n        self.logger.info(\"cleaning link caches\")\n        self.clean_link_cache()\n        if self.settings.manage_rsync:\n           self.logger.info(\"rendering Rsync files\")\n           self.rsync_gen()\n        # run post-triggers\n        self.logger.info(\"running post-sync triggers\")\n        utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/sync/post/*\", logger=self.logger)\n        utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/change/*\", logger=self.logger)\n        return True\n    def make_tftpboot(self):\n        \"\"\"\n        Make directories for tftpboot images\n        \"\"\"\n        if not os.path.exists(self.pxelinux_dir):\n            utils.mkdir(self.pxelinux_dir,logger=self.logger)\n        if not os.path.exists(self.grub_dir):\n            utils.mkdir(self.grub_dir,logger=self.logger)\n        grub_images_link = os.path.join(self.grub_dir, \"images\")\n        if not os.path.exists(grub_images_link):\n            os.symlink(\"../images\", grub_images_link)\n        if not os.path.exists(self.images_dir):\n            utils.mkdir(self.images_dir,logger=self.logger)\n        if not os.path.exists(self.s390_dir):\n            utils.mkdir(self.s390_dir,logger=self.logger)\n        if not os.path.exists(self.rendered_dir):\n            utils.mkdir(self.rendered_dir,logger=self.logger)\n        if not os.path.exists(self.yaboot_bin_dir):\n            utils.mkdir(self.yaboot_bin_dir,logger=self.logger)\n        if not os.path.exists(self.yaboot_cfg_dir):\n            utils.mkdir(self.yaboot_cfg_dir,logger=self.logger)\n    def clean_trees(self):\n        \"\"\"\n        Delete any previously built pxelinux.cfg tree and virt tree info and then create\n        directories.\n        Note: for SELinux reasons, some information goes in /tftpboot, some in /var/www/cobbler\n        and some must be duplicated in both.  This is because PXE needs tftp, and auto-kickstart\n        and Virt operations need http.   Only the kernel and initrd images are duplicated, which is\n        unfortunate, though SELinux won't let me give them two contexts, so symlinks are not\n        a solution.  *Otherwise* duplication is minimal.\n        \"\"\"\n        # clean out parts of webdir and all of /tftpboot/images and /tftpboot/pxelinux.cfg\n        for x in os.listdir(self.settings.webdir):\n            path = os.path.join(self.settings.webdir,x)\n            if os.path.isfile(path):\n                if not x.endswith(\".py\"):\n                    utils.rmfile(path,logger=self.logger)\n            if os.path.isdir(path):\n                if not x in [\"aux\", \"web\", \"webui\", \"localmirror\",\"repo_mirror\",\"ks_mirror\",\"images\",\"links\",\"pub\",\"repo_profile\",\"repo_system\",\"svc\",\"rendered\",\".link_cache\"] :\n                    # delete directories that shouldn't exist\n                    utils.rmtree(path,logger=self.logger)\n                if x in [\"kickstarts\",\"kickstarts_sys\",\"images\",\"systems\",\"distros\",\"profiles\",\"repo_profile\",\"repo_system\",\"rendered\"]:\n                    # clean out directory contents\n                    utils.rmtree_contents(path,logger=self.logger)\n        #\n        self.make_tftpboot()\n        utils.rmtree_contents(self.pxelinux_dir,logger=self.logger)\n        utils.rmtree_contents(self.grub_dir,logger=self.logger)\n        utils.rmtree_contents(self.images_dir,logger=self.logger)\n        utils.rmtree_contents(self.s390_dir,logger=self.logger)\n        utils.rmtree_contents(self.yaboot_bin_dir,logger=self.logger)\n        utils.rmtree_contents(self.yaboot_cfg_dir,logger=self.logger)\n        utils.rmtree_contents(self.rendered_dir,logger=self.logger)\n    def write_dhcp(self):\n        self.logger.info(\"rendering DHCP files\")\n        self.dhcp.write_dhcp_file()\n        self.dhcp.regen_ethers()\n    def sync_dhcp(self):\n        restart_dhcp = str(self.settings.restart_dhcp).lower()\n        which_dhcp_module = module_loader.get_module_from_file(\"dhcp\",\"module\",just_name=True).strip()\n        if self.settings.manage_dhcp:\n            self.write_dhcp()\n            if which_dhcp_module == \"manage_isc\":\n                service_name = utils.dhcp_service_name(self.api)\n                if restart_dhcp != \"0\":\n                    rc = utils.subprocess_call(self.logger, \"dhcpd -t -q\", shell=True)\n                    if rc != 0:\n                       self.logger.error(\"dhcpd -t failed\")\n                       return False\n                    service_restart = \"service %s restart\" % service_name\n                    rc = utils.subprocess_call(self.logger, service_restart, shell=True)\n                    if rc != 0:\nNext line of code:\n",
        "prediction": "   return False\n    else:\n        self.logger.error(\"dhcpd -t failed\")\n        return False\n    else:\n        self.logger.error(\"dhcpd -t failed\")\n        return False\n    else:\n        self.logger.error(\"dhcpd",
        "gold": [
            "                       self.logger.error(\"%s failed\" % service_name)"
        ],
        "time": 3.365341901779175
    },
    "13": {
        "origin_prompt": "Please complete the code given below. \n/*\nBullet Continuous Collision Detection and Physics Library\nCopyright (c) 2003-2008 Erwin Coumans  http://bulletphysics.com\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose, \nincluding commercial applications, and to alter it and redistribute it freely, \nsubject to the following restrictions:\n1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n*/\n#include <stdio.h>\n#include \"LinearMath/btIDebugDraw.h\"\n#include \"BulletCollision/CollisionDispatch/btGhostObject.h\"\n#include \"BulletCollision/CollisionShapes/btMultiSphereShape.h\"\n#include \"BulletCollision/BroadphaseCollision/btOverlappingPairCache.h\"\n#include \"BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h\"\n#include \"BulletCollision/CollisionDispatch/btCollisionWorld.h\"\n#include \"LinearMath/btDefaultMotionState.h\"\n#include \"btKinematicCharacterController.h\"\n// static helper method\nstatic btVector3\ngetNormalizedVector(ref btVector3 v)\n{\n\tbtVector3 n(0, 0, 0);\n\tif (v.length() > SIMD_EPSILON) {\n\t\tn = v.normalized();\n\t}\n\treturn n;\n}\n///@todo Interact with dynamic objects,\n///Ride kinematicly animated platforms properly\n///More realistic (or maybe just a config option) falling\n/// . Should integrate falling velocity manually and use that in stepDown()\n///Support jumping\n///Support ducking\nclass btKinematicClosestNotMeRayResultCallback : btCollisionWorld::ClosestRayResultCallback\n{\npublic:\n\tbtKinematicClosestNotMeRayResultCallback (btCollisionObject me) : btCollisionWorld::ClosestRayResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))\n\t{\n\t\tm_me = me;\n\t}\n\tvirtual double addSingleResult(btCollisionWorld::LocalRayResult& rayResult,bool normalInWorldSpace)\n\t{\n\t\tif (rayResult.m_collisionObject == m_me)\n\t\t\treturn 1.0;\n\t\treturn ClosestRayResultCallback::addSingleResult (rayResult, normalInWorldSpace);\n\t}\nprotected:\n\tbtCollisionObject m_me;\n};\nclass btKinematicClosestNotMeConvexResultCallback : btCollisionWorld::ClosestConvexResultCallback\n{\npublic:\n\tbtKinematicClosestNotMeConvexResultCallback (btCollisionObject me, ref btVector3 up, double minSlopeDot)\n\t: btCollisionWorld::ClosestConvexResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))\n\t, m_me(me)\n\t, m_up(up)\n\t, m_minSlopeDot(minSlopeDot)\n\t{\n\t}\n\tvirtual double addSingleResult(btCollisionWorld::LocalConvexResult& convexResult,bool normalInWorldSpace)\n\t{\n\t\tif (convexResult.m_hitCollisionObject == m_me)\n\t\t\treturn (double)(1.0);\n\t\tif (!convexResult.m_hitCollisionObject.hasContactResponse())\n\t\t\treturn (double)(1.0);\n\t\tbtVector3 hitNormalWorld;\n\t\tif (normalInWorldSpace)\n\t\t{\n\t\t\thitNormalWorld = convexResult.m_hitNormalLocal;\n\t\t} else\n\t\t{\n\t\t\t///need to transform normal into worldspace\n\t\t\thitNormalWorld = convexResult.m_hitCollisionObject.getWorldTransform().getBasis()*convexResult.m_hitNormalLocal;\n\t\t}\n\t\tdouble dotUp = m_up.dot(hitNormalWorld);\n\t\tif (dotUp < m_minSlopeDot) {\n\t\t\treturn (double)(1.0);\n\t\t}\n\t\treturn ClosestConvexResultCallback::addSingleResult (convexResult, normalInWorldSpace);\n\t}\nprotected:\n\tbtCollisionObject m_me;\n\tbtVector3 m_up;\n\tdouble m_minSlopeDot;\n};\n/*\n * Returns the reflection direction of a ray going 'direction' hitting a surface with normal 'normal'\n *\n * from: http://www-cs-students.stanford.edu/~adityagp/final/node3.html\n */\nbtVector3 btKinematicCharacterController::computeReflectionDirection (ref btVector3 direction, ref btVector3 normal)\n{\n\treturn direction - ((double)(2.0) * direction.dot(normal)) * normal;\n}\n/*\n * Returns the portion of 'direction' that is parallel to 'normal'\n */\nbtVector3 btKinematicCharacterController::parallelComponent (ref btVector3 direction, ref btVector3 normal)\n{\n\tdouble magnitude = direction.dot(normal);\n\treturn normal * magnitude;\n}\n/*\n * Returns the portion of 'direction' that is perpindicular to 'normal'\n */\nbtVector3 btKinematicCharacterController::perpindicularComponent (ref btVector3 direction, ref btVector3 normal)\n{\n\treturn direction - parallelComponent(direction, normal);\n}\nbtKinematicCharacterController::btKinematicCharacterController (btPairCachingGhostObject* ghostObject,btConvexShape* convexShape,double stepHeight, int upAxis)\n{\n\tm_upAxis = upAxis;\n\tm_addedMargin = 0.02;\n\tm_walkDirection.setValue(0,0,0);\n\tm_useGhostObjectSweepTest = true;\n\tm_ghostObject = ghostObject;\n\tm_stepHeight = stepHeight;\n\tm_turnAngle = (double)(0.0);\n\tm_convexShape=convexShape;\t\n\tm_useWalkDirection = true;\t// use walk direction by default, legacy behavior\n\tm_velocityTimeInterval = 0.0;\n\tm_verticalVelocity = 0.0;\n\tm_verticalOffset = 0.0;\n\tm_gravity = 9.8 * 3 ; // 3G acceleration.\n\tm_fallSpeed = 55.0; // Terminal velocity of a sky diver in m/s.\n\tm_jumpSpeed = 10.0; // ?\n\tm_wasOnGround = false;\n\tm_wasJumping = false;\n\tm_interpolateUp = true;\n\tsetMaxSlope(btRadians(45.0));\n\tm_currentStepOffset = 0;\n\tfull_drop = false;\n\tbounce_fix = false;\n}\nbtKinematicCharacterController::~btKinematicCharacterController ()\n{\n}\nbtPairCachingGhostObject* btKinematicCharacterController::getGhostObject()\n{\n\treturn m_ghostObject;\n}\nbool btKinematicCharacterController::recoverFromPenetration ( btCollisionWorld* collisionWorld)\n{\n\t// Here we must refresh the overlapping paircache as the penetrating movement itself or the\n\t// previous recovery iteration might have used setWorldTransform and pushed us into an object\n\t// that is not in the previous cache contents from the last timestep, as will happen if we\n\t// are pushed into a new AABB overlap. Unhandled this means the next convex sweep gets stuck.\n\t//\n\t// Do this by calling the broadphase's setAabb with the moved AABB, this will update the broadphase\n\t// paircache and the ghostobject's internal paircache at the same time.    /BW\n\tbtVector3 minAabb, maxAabb;\n\tm_convexShape.getAabb(m_ghostObject.getWorldTransform(), minAabb,maxAabb);\n\tcollisionWorld.getBroadphase().setAabb(m_ghostObject.getBroadphaseHandle(), \n\t\t\t\t\t\t minAabb, \n\t\t\t\t\t\t maxAabb, \n\t\t\t\t\t\t collisionWorld.getDispatcher());\n\t\t\t\t\t\t \n\tbool penetration = false;\n\tcollisionWorld.getDispatcher().dispatchAllCollisionPairs(m_ghostObject.getOverlappingPairCache(), collisionWorld.getDispatchInfo(), collisionWorld.getDispatcher());\n\tm_currentPosition = m_ghostObject.getWorldTransform().getOrigin();\n\t\n\tdouble maxPen = (double)(0.0);\n\tfor (int i = 0; i < m_ghostObject.getOverlappingPairCache().getNumOverlappingPairs(); i++)\n\t{\n\t\tm_manifoldArray.resize(0);\n\t\tbtBroadphasePair* collisionPair = &m_ghostObject.getOverlappingPairCache().getOverlappingPairArray()[i];\n\t\tbtCollisionObject obj0 = static_cast<btCollisionObject>(collisionPair.m_pProxy0.m_clientObject);\n                btCollisionObject obj1 = static_cast<btCollisionObject>(collisionPair.m_pProxy1.m_clientObject);\n\t\tif ((obj0 && !obj0.hasContactResponse()) || (obj1 && !obj1.hasContactResponse()))\n\t\t\tcontinue;\n\t\t\n\t\tif (collisionPair.m_algorithm)\n\t\t\tcollisionPair.m_algorithm.getAllContactManifolds(m_manifoldArray);\n\t\t\n\t\tfor (int j=0;j<m_manifoldArray.Count;j++)\n\t\t{\n\t\t\tbtPersistentManifold* manifold = m_manifoldArray[j];\n\t\t\tdouble directionSign = manifold.getBody0() == m_ghostObject ? (double)(-1.0) : (double)(1.0);\n\t\t\tfor (int p=0;p<manifold.getNumContacts();p++)\n\t\t\t{\n\t\t\t\tbtManifoldPointpt = manifold.getContactPoint(p);\n\t\t\t\tdouble dist = pt.getDistance();\n\t\t\t\tif (dist < 0.0)\n\t\t\t\t{\n\t\t\t\t\tif (dist < maxPen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxPen = dist;\n\t\t\t\t\t\tm_touchingNormal = pt.m_normalWorldOnB * directionSign;//??\n\t\t\t\t\t}\n\t\t\t\t\tm_currentPosition += pt.m_normalWorldOnB * directionSign * dist * (double)(0.2);\n\t\t\t\t\tpenetration = true;\n\t\t\t\t} else {\n\t\t\t\t\t//Console.WriteLine(\"touching %f\\n\", dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//manifold.clearManifold();\n\t\t}\n\t}\n\tbtTransform newTrans = m_ghostObject.getWorldTransform();\n\tnewTrans.setOrigin(m_currentPosition);\n\tm_ghostObject.setWorldTransform(newTrans);\n//\tConsole.WriteLine(\"m_touchingNormal = %f,%f,%f\\n\",m_touchingNormal,m_touchingNormal[1],m_touchingNormal[2]);\n\treturn penetration;\n}\nvoid btKinematicCharacterController::stepUp ( btCollisionWorld* world)\n{\n\t// phase 1: up\n\tbtTransform start, end;\n\tm_targetPosition = m_currentPosition + getUpAxisDirections()[m_upAxis] * (m_stepHeight + (m_verticalOffset > 0?m_verticalOffset:0));\n\tstart.setIdentity ();\n\tend.setIdentity ();\n\t/* FIXME: Handle penetration properly */\n\tstart.setOrigin (m_currentPosition + getUpAxisDirections()[m_upAxis] * (m_convexShape.getMargin() + m_addedMargin));\n\tend.setOrigin (m_targetPosition);\n\tbtKinematicClosestNotMeConvexResultCallback callback (m_ghostObject, -getUpAxisDirections()[m_upAxis], (double)(0.7071));\n\tcallback.m_collisionFilterGroup = getGhostObject().getBroadphaseHandle().m_collisionFilterGroup;\n\tcallback.m_collisionFilterMask = getGhostObject().getBroadphaseHandle().m_collisionFilterMask;\n\t\n\tif (m_useGhostObjectSweepTest)\n\t{\n\t\tm_ghostObject.convexSweepTest (m_convexShape, start, end, callback, world.getDispatchInfo().m_allowedCcdPenetration);\n\t}\n\telse\n\t{\n\t\tworld.convexSweepTest (m_convexShape, start, end, callback);\n\t}\n\t\n\tif (callback.hasHit())\n\t{\n\t\t// Only modify the position if the hit was a slope and not a wall or ceiling.\n\t\tif(callback.m_hitNormalWorld.dot(getUpAxisDirections()[m_upAxis]) > 0.0)\n\t\t{\n\t\t\t// we moved up only a fraction of the step height\n\t\t\tm_currentStepOffset = m_stepHeight * callback.m_closestHitFraction;\n\t\t\tif (m_interpolateUp == true)\n\t\t\t\tm_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);\n\t\t\telse\n\t\t\t\tm_currentPosition = m_targetPosition;\n\t\t}\n\t\tm_verticalVelocity = 0.0;\n\t\tm_verticalOffset = 0.0;\n\t} else {\n\t\tm_currentStepOffset = m_stepHeight;\n\t\tm_currentPosition = m_targetPosition;\n\t}\n}\nvoid btKinematicCharacterController::updateTargetPositionBasedOnCollision (ref btVector3 hitNormal, double tangentMag, double normalMag)\n{\n\tbtVector3 movementDirection = m_targetPosition - m_currentPosition;\n\tdouble movementLength = movementDirection.length();\n\tif (movementLength>SIMD_EPSILON)\n\t{\n\t\tmovementDirection.normalize();\n\t\tbtVector3 reflectDir = computeReflectionDirection (movementDirection, hitNormal);\n\t\treflectDir.normalize();\n\t\tbtVector3 parallelDir, perpindicularDir;\n\t\tparallelDir = parallelComponent (reflectDir, hitNormal);\n\t\tperpindicularDir = perpindicularComponent (reflectDir, hitNormal);\n\t\tm_targetPosition = m_currentPosition;\n\t\tif (0)//tangentMag != 0.0)\n\t\t{\n\t\t\tbtVector3 parComponent = parallelDir * double (tangentMag*movementLength);\n//\t\t\tConsole.WriteLine(\"parComponent=%f,%f,%f\\n\",parComponent[0],parComponent[1],parComponent[2]);\n\t\t\tm_targetPosition +=  parComponent;\n\t\t}\n\t\tif (normalMag != 0.0)\n\t\t{\n\t\t\tbtVector3 perpComponent = perpindicularDir * double (normalMag*movementLength);\n//\t\t\tConsole.WriteLine(\"perpComponent=%f,%f,%f\\n\",perpComponent[0],perpComponent[1],perpComponent[2]);\n\t\t\tm_targetPosition += perpComponent;\n\t\t}\n\t} else\n\t{\n//\t\tConsole.WriteLine(\"movementLength don't normalize a zero vector\\n\");\n\t}\n}\nvoid btKinematicCharacterController::stepForwardAndStrafe ( btCollisionWorld* collisionWorld, ref btVector3 walkMove)\n{\n\t// Console.WriteLine(\"m_normalizedDirection=%f,%f,%f\\n\",\n\t// \tm_normalizedDirection[0],m_normalizedDirection[1],m_normalizedDirection[2]);\n\t// phase 2: forward and strafe\n\tbtTransform start, end;\n\tm_targetPosition = m_currentPosition + walkMove;\n\tstart.setIdentity ();\n\tend.setIdentity ();\n\t\n\tdouble fraction = 1.0;\n\tdouble distance2 = (m_currentPosition-m_targetPosition).length2();\n//\tConsole.WriteLine(\"distance2=%f\\n\",distance2);\n\tif (m_touchingContact)\n\t{\n\t\tif (m_normalizedDirection.dot(m_touchingNormal) > (double)(0.0))\n\t\t{\n\t\t\t//interferes with step movement\n\t\t\t//updateTargetPositionBasedOnCollision (m_touchingNormal);\n\t\t}\n\t}\n\tint maxIter = 10;\n\twhile (fraction > (double)(0.01) && maxIter-- > 0)\n\t{\n\t\tstart.setOrigin (m_currentPosition);\n\t\tend.setOrigin (m_targetPosition);\n\t\tbtVector3 sweepDirNegative(m_currentPosition - m_targetPosition);\n\t\tbtKinematicClosestNotMeConvexResultCallback callback (m_ghostObject, sweepDirNegative, (double)(0.0));\n\t\tcallback.m_collisionFilterGroup = getGhostObject().getBroadphaseHandle().m_collisionFilterGroup;\n\t\tcallback.m_collisionFilterMask = getGhostObject().getBroadphaseHandle().m_collisionFilterMask;\n\t\tdouble margin = m_convexShape.getMargin();\n\t\tm_convexShape.setMargin(margin + m_addedMargin);\n\t\tif (m_useGhostObjectSweepTest)\n\t\t{\n\t\t\tm_ghostObject.convexSweepTest (m_convexShape, start, end, callback, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t} else\n\t\t{\n\t\t\tcollisionWorld.convexSweepTest (m_convexShape, start, end, callback, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t}\n\t\t\n\t\tm_convexShape.setMargin(margin);\n\t\t\n\t\tfraction -= callback.m_closestHitFraction;\n\t\tif (callback.hasHit())\n\t\t{\t\n\t\t\t// we moved only a fraction\n\t\t\t//double hitDistance;\n\t\t\t//hitDistance = (callback.m_hitPointWorld - m_currentPosition).length();\n//\t\t\tm_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);\n\t\t\tupdateTargetPositionBasedOnCollision (callback.m_hitNormalWorld);\n\t\t\tbtVector3 currentDir = m_targetPosition - m_currentPosition;\n\t\t\tdistance2 = currentDir.length2();\n\t\t\tif (distance2 > SIMD_EPSILON)\n\t\t\t{\n\t\t\t\tcurrentDir.normalize();\n\t\t\t\t/* See Quake2: \"If velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners.\" */\n\t\t\t\tif (currentDir.dot(m_normalizedDirection) <= (double)(0.0))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n//\t\t\t\tConsole.WriteLine(\"currentDir: don't normalize a zero vector\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t// we moved whole way\n\t\t\tm_currentPosition = m_targetPosition;\n\t\t}\n\t//\tif (callback.m_closestHitFraction == 0)\n\t//\t\tbreak;\n\t}\n}\nvoid btKinematicCharacterController::stepDown ( btCollisionWorld* collisionWorld, double dt)\n{\n\tbtTransform start, end, end_double;\n\tbool runonce = false;\n\t// phase 3: down\n\t/*double additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;\n\tbtVector3 step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + additionalDownStep);\n\tdouble downVelocity = (additionalDownStep == 0.0 && m_verticalVelocity<0.0?-m_verticalVelocity:0.0) * dt;\n\tbtVector3 gravity_drop = getUpAxisDirections()[m_upAxis] * downVelocity; \n\tm_targetPosition -= (step_drop + gravity_drop);*/\n\tbtVector3 orig_position = m_targetPosition;\n\t\n\tdouble downVelocity = (m_verticalVelocity<0?-m_verticalVelocity:0) * dt;\n\tif(downVelocity > 0.0 && downVelocity > m_fallSpeed\n\t\t&& (m_wasOnGround || !m_wasJumping))\n\t\tdownVelocity = m_fallSpeed;\n\tbtVector3 step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);\n\tm_targetPosition -= step_drop;\n\tbtKinematicClosestNotMeConvexResultCallback callback (m_ghostObject, getUpAxisDirections()[m_upAxis], m_maxSlopeCosine);\n        callback.m_collisionFilterGroup = getGhostObject().getBroadphaseHandle().m_collisionFilterGroup;\n        callback.m_collisionFilterMask = getGhostObject().getBroadphaseHandle().m_collisionFilterMask;\n        btKinematicClosestNotMeConvexResultCallback callback2 (m_ghostObject, getUpAxisDirections()[m_upAxis], m_maxSlopeCosine);\n        callback2.m_collisionFilterGroup = getGhostObject().getBroadphaseHandle().m_collisionFilterGroup;\n        callback2.m_collisionFilterMask = getGhostObject().getBroadphaseHandle().m_collisionFilterMask;\n\twhile (1)\n\t{\n\t\tstart.setIdentity ();\n\t\tend.setIdentity ();\n\t\tend_double.setIdentity ();\n\t\tstart.setOrigin (m_currentPosition);\n\t\tend.setOrigin (m_targetPosition);\n\t\t//set double test for 2x the step drop, to check for a large drop vs small drop\n\t\tend_double.setOrigin (m_targetPosition - step_drop);\n\t\tif (m_useGhostObjectSweepTest)\n\t\t{\n\t\t\tm_ghostObject.convexSweepTest (m_convexShape, start, end, callback, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t\tif (!callback.hasHit())\n\t\t\t{\n\t\t\t\t//test a double fall height, to see if the character should interpolate it's fall (full) or not (partial)\n\t\t\t\tm_ghostObject.convexSweepTest (m_convexShape, start, end_double, callback2, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tcollisionWorld.convexSweepTest (m_convexShape, start, end, callback, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t\tif (!callback.hasHit())\n\t\t\t\t\t{\n\t\t\t\t\t\t\t//test a double fall height, to see if the character should interpolate it's fall (large) or not (small)\n\t\t\t\t\t\t\tcollisionWorld.convexSweepTest (m_convexShape, start, end_double, callback2, collisionWorld.getDispatchInfo().m_allowedCcdPenetration);\n\t\t\t\t\t}\n\t\t}\n\t\n\t\tdouble downVelocity2 = (m_verticalVelocity<0?-m_verticalVelocity:0) * dt;\n\t\tbool has_hit = false;\n\t\tif (bounce_fix == true)\n\t\t\thas_hit = callback.hasHit() || callback2.hasHit();\n\t\telse\n\t\t\thas_hit = callback2.hasHit();\n\t\tif(downVelocity2 > 0.0 && downVelocity2 < m_stepHeight && has_hit == true && runonce == false\n\t\t\t\t\t&& (m_wasOnGround || !m_wasJumping))\n\t\t{\n\t\t\t//redo the velocity calculation when falling a small amount, for fast stairs motion\n\t\t\t//for larger falls, use the smoother/slower interpolated movement by not touching the target position\n\t\t\tm_targetPosition = orig_position;\n\t\t\t\t\tdownVelocity = m_stepHeight;\n\t\t\t\tbtVector3 step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);\n\t\t\tm_targetPosition -= step_drop;\n\t\t\trunonce = true;\n\t\t\tcontinue; //re-run previous tests\n\t\t}\n\t\tbreak;\n\t}\n\tif (callback.hasHit() || runonce == true)\n\t{\n\t\t// we dropped a fraction of the height . hit floor\n\t\tdouble fraction = (m_currentPosition.y - callback.m_hitPointWorld.y) / 2;\n\t\t//Console.WriteLine(\"hitpoint: %g - pos %g\\n\", callback.m_hitPointWorld.y, m_currentPosition.y);\n\t\tif (bounce_fix == true)\n\t\t{\n\t\t\tif (full_drop == true)\n                                m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);\n                        else\n                                //due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually\n                                m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, fraction);\n\t\t}\n\t\telse\n\t\t\tm_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);\n\t\tfull_drop = false;\n\t\tm_verticalVelocity = 0.0;\n\t\tm_verticalOffset = 0.0;\n\t\tm_wasJumping = false;\n\t} else {\n\t\t// we dropped the full height\n\t\t\n\t\tfull_drop = true;\n\t\tif (bounce_fix == true)\n\t\t{\n\t\t\tdownVelocity = (m_verticalVelocity<0?-m_verticalVelocity:0) * dt;\n\t\t\tif (downVelocity > m_fallSpeed && (m_wasOnGround || !m_wasJumping))\n\t\t\t{\n\t\t\t\tm_targetPosition += step_drop; //undo previous target change\n\t\t\t\tdownVelocity = m_fallSpeed;\n\t\t\t\tstep_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);\n\t\t\t\tm_targetPosition -= step_drop;\n\t\t\t}\n\t\t}\n\t\t//Console.WriteLine(\"full drop - %g, %g\\n\", m_currentPosition.y, m_targetPosition.y);\n\t\tm_currentPosition = m_targetPosition;\n\t}\n}\nvoid btKinematicCharacterController::setWalkDirection\n(\nref btVector3 walkDirection\n)\n{\n\tm_useWalkDirection = true;\n\tm_walkDirection = walkDirection;\n\tm_normalizedDirection = getNormalizedVector(m_walkDirection);\n}\nvoid btKinematicCharacterController::setVelocityForTimeInterval\n(\nref btVector3 velocity,\ndouble timeInterval\n)\n{\n//\tConsole.WriteLine(\"setVelocity!\\n\");\n//\tConsole.WriteLine(\"  interval: %f\\n\", timeInterval);\n//\tConsole.WriteLine(\"  velocity: (%f, %f, %f)\\n\",\n//\t\t velocity.x, velocity.y, velocity.z);\n\tm_useWalkDirection = false;\n\tm_walkDirection = velocity;\n\tm_normalizedDirection = getNormalizedVector(m_walkDirection);\n\tm_velocityTimeInterval += timeInterval;\n}\nvoid btKinematicCharacterController::reset ( btCollisionWorld* collisionWorld )\n{\n        m_verticalVelocity = 0.0;\n        m_verticalOffset = 0.0;\n        m_wasOnGround = false;\n        m_wasJumping = false;\n        m_walkDirection.setValue(0,0,0);\n        m_velocityTimeInterval = 0.0;\n        //clear pair cache\n        btHashedOverlappingPairCache *cache = m_ghostObject.getOverlappingPairCache();\n        while (cache.getOverlappingPairArray().Count > 0)\n        {\n                cache.removeOverlappingPair(cache.getOverlappingPairArray()[0].m_pProxy0, cache.getOverlappingPairArray()[0].m_pProxy1, collisionWorld.getDispatcher());\n        }\n}\nvoid btKinematicCharacterController::warp (ref btVector3 origin)\n{\n\tbtTransform xform;\n\txform.setIdentity();\n\txform.setOrigin (origin);\n\tm_ghostObject.setWorldTransform (xform);\n}\nvoid btKinematicCharacterController::preStep (  btCollisionWorld* collisionWorld)\n{\n\t\n\tint numPenetrationLoops = 0;\n\tm_touchingContact = false;\n\twhile (recoverFromPenetration (collisionWorld))\n\t{\n\t\tnumPenetrationLoops++;\n\t\tm_touchingContact = true;\n\t\tif (numPenetrationLoops > 4)\n\t\t{\n\t\t\t//Console.WriteLine(\"character could not recover from penetration = %d\\n\", numPenetrationLoops);\n\t\t\tbreak;\n\t\t}\n\t}\n\tm_currentPosition = m_ghostObject.getWorldTransform().getOrigin();\n\tm_targetPosition = m_currentPosition;\n//\tConsole.WriteLine(\"m_targetPosition=%f,%f,%f\\n\",m_targetPosition[0],m_targetPosition[1],m_targetPosition[2]);\n\t\n}\n#include <stdio.h>\nvoid btKinematicCharacterController::playerStep (  btCollisionWorld* collisionWorld, double dt)\n{\n//\tConsole.WriteLine(\"playerStep(): \");\n//\tConsole.WriteLine(\"  dt = %f\", dt);\n\t// quick check...\n\tif (!m_useWalkDirection & (m_velocityTimeInterval <= 0.0 || m_walkDirection.fuzzyZero())) {\n//\t\tConsole.WriteLine(\"\\n\");\n\t\treturn;\t\t// no motion\n\t}\n\tm_wasOnGround = onGround();\n\t// Update fall velocity.\n\tm_verticalVelocity -= m_gravity * dt;\n\tif(m_verticalVelocity > 0.0 && m_verticalVelocity > m_jumpSpeed)\n\t{\n\t\tm_verticalVelocity = m_jumpSpeed;\n\t}\n\tif(m_verticalVelocity < 0.0 && btFabs(m_verticalVelocity) > btFabs(m_fallSpeed))\n\t{\n\t\tm_verticalVelocity = -btFabs(m_fallSpeed);\n\t}\n\tm_verticalOffset = m_verticalVelocity * dt;\n\tbtTransform xform;\n\txform = m_ghostObject.getWorldTransform ();\n//\tConsole.WriteLine(\"walkDirection(%f,%f,%f)\\n\",walkDirection,walkDirection[1],walkDirection[2]);\n//\tConsole.WriteLine(\"walkSpeed=%f\\n\",walkSpeed);\n\tstepUp (collisionWorld);\n\tif (m_useWalkDirection) {\n\t\tstepForwardAndStrafe (collisionWorld, m_walkDirection);\n\t} else {\n\t\t//Console.WriteLine(\"  time: %f\", m_velocityTimeInterval);\n\t\t// still have some time left for moving!\n\t\tdouble dtMoving =\n\t\t\t(dt < m_velocityTimeInterval) ? dt : m_velocityTimeInterval;\n\t\tm_velocityTimeInterval -= dt;\n\t\t// how far will we move while we are moving?\n\t\tbtVector3 move = m_walkDirection * dtMoving;\n\t\t//Console.WriteLine(\"  dtMoving: %f\", dtMoving);\n\t\t// okay, step\n\t\tstepForwardAndStrafe(collisionWorld, move);\n\t}\n\tstepDown (collisionWorld, dt);\n\t// Console.WriteLine(\"\\n\");\n\txform.setOrigin (m_currentPosition);\n\tm_ghostObject.setWorldTransform (xform);\n}\nvoid btKinematicCharacterController::setFallSpeed (double fallSpeed)\n{\n\tm_fallSpeed = fallSpeed;\n}\nvoid btKinematicCharacterController::setJumpSpeed (double jumpSpeed)\n{\n\tm_jumpSpeed = jumpSpeed;\n}\nvoid btKinematicCharacterController::setMaxJumpHeight (double maxJumpHeight)\n{\n\tm_maxJumpHeight = maxJumpHeight;\n}\nbool btKinematicCharacterController::canJump ()\n{\n\treturn onGround();\n}\nvoid btKinematicCharacterController::jump ()\n{\n\tif (!canJump())\n\t\treturn;\n\tm_verticalVelocity = m_jumpSpeed;\n\tm_wasJumping = true;\n#if 0\n\tcurrently no jumping.\n\tbtTransform xform;\n\tm_rigidBody.getMotionState().getWorldTransform (xform);\n\tbtVector3 up = xform.getBasis()[1];\n\tup.normalize ();\n\tdouble magnitude = ((double)(1.0)/m_rigidBody.getInvMass()) * (double)(8.0);\n\tm_rigidBody.applyCentralImpulse (up * magnitude);\n#endif\n}\nvoid btKinematicCharacterController::setGravity(double gravity)\n{\n\tm_gravity = gravity;\n}\ndouble btKinematicCharacterController::getGravity()\n{\n\treturn m_gravity;\n}\nvoid btKinematicCharacterController::setMaxSlope(double slopeRadians)\n{\n\tm_maxSlopeRadians = slopeRadians;\nNext line of code:\n",
        "prediction": "\tbtTransform xform;\n\tm_rigidBody.getMotionState().getWorldTransform (xform);\n\tbtVector3 up = xform.getBasis()[1];\n\tup.normalize ();\n\tdouble magnitude = ((double)(1.0)/m_",
        "gold": [
            "\tm_maxSlopeCosine = btCos(slopeRadians);"
        ],
        "time": 3.3642733097076416
    },
    "14": {
        "origin_prompt": "Please complete the code given below. \nfrom django import forms\nfrom django.forms import ValidationError\nfrom django.contrib.auth.models import Group\nfrom common.forms import ModelFormWithHelper\nfrom common.helpers import SubmitCancelFormHelper\nfrom community.constants import COMMUNITY_ADMIN, COMMUNITY_PRESENCE_CHOICES\nfrom community.models import Community, CommunityPage, RequestCommunity\nfrom community.utils import get_groups\nfrom users.models import SystersUser\nclass AddCommunityForm(ModelFormWithHelper):\n    \"\"\" Form to create a new Community by admin. \"\"\"\n    class Meta:\n        model = Community\n        fields = ('name', 'slug', 'order', 'location', 'email', 'mailing_list',\n                  'parent_community', 'website', 'facebook', 'googleplus',\n                  'twitter')\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'index' %}\"\n    def __init__(self, *args, **kwargs):\n        self.admin = kwargs.pop('admin')\n        super(AddCommunityForm, self).__init__(*args, **kwargs)\n    def save(self, commit=True):\n        \"\"\"Override save to add admin to the instance\"\"\"\n        instance = super(AddCommunityForm, self).save(commit=False)\n        instance.admin = self.admin\n        if commit:\n            instance.save()\n        return instance\nclass RequestCommunityForm(ModelFormWithHelper):\n    \"\"\"Form to request a new Community\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Makes some fields required and modifies a field to use widget\"\"\"\n        self.user = kwargs.pop('user')\n        super(RequestCommunityForm, self).__init__(*args, **kwargs)\n        self.fields['social_presence'] = forms.MultipleChoiceField(\n            choices=COMMUNITY_PRESENCE_CHOICES, label=\"Check off all \\\n            the social media accounts you can manage for your proposed community:\",\n            required=False, widget=forms.CheckboxSelectMultiple)\n        self.fields['email'].required = True\n        self.fields['demographic_target_count'].required = True\n        self.fields['purpose'].required = True\n        self.fields['content_developer'].required = True\n        self.fields['selection_criteria'].required = True\n        self.fields['is_real_time'].required = True\n    class Meta:\n        model = RequestCommunity\n        fields = ('is_member', 'email_id', 'email', 'name', 'slug', 'order', 'location',\n                  'type_community', 'other_community_type', 'parent_community',\n                  'community_channel', 'mailing_list', 'website', 'facebook',\n                  'googleplus', 'twitter', 'social_presence', 'other_account',\n                  'demographic_target_count',\n                  'purpose', 'is_avail_volunteer', 'count_avail_volunteer', 'content_developer',\n                  'selection_criteria', 'is_real_time')\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'index' %}\"\n    def clean_social_presence(self):\n        \"\"\"Converts the checkbox input into char to save it to the instance's field.\"\"\"\n        social_presence = ', '.join(\n            map(str, self.cleaned_data['social_presence']))\n        return social_presence\n    def save(self, commit=True):\n        \"\"\"Override save to add user to the instance\"\"\"\n        instance = super(RequestCommunityForm, self).save(commit=False)\n        instance.user = SystersUser.objects.get(user=self.user)\n        if commit:\n            instance.save()\n        return instance\nclass EditCommunityRequestForm(ModelFormWithHelper):\n    \"\"\"Form to edit a community request\"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Makes some fields required and modifies a field to use widget\"\"\"\n        super(EditCommunityRequestForm, self).__init__(*args, **kwargs)\n        self.fields['social_presence'] = forms.MultipleChoiceField(\n            choices=COMMUNITY_PRESENCE_CHOICES, label=\"Check off all \\\n            the social media accounts you can manage for your proposed community:\",\n            required=False, widget=forms.CheckboxSelectMultiple)\n        self.fields['email'].required = True\n        self.fields['demographic_target_count'].required = True\n        self.fields['purpose'].required = True\n        self.fields['content_developer'].required = True\n        self.fields['selection_criteria'].required = True\n        self.fields['is_real_time'].required = True\n    class Meta:\n        model = RequestCommunity\n        fields = ('is_member', 'email_id', 'email', 'name', 'slug', 'order', 'location',\n                  'type_community', 'other_community_type', 'parent_community',\n                  'community_channel', 'mailing_list', 'website', 'facebook',\n                  'googleplus', 'twitter', 'social_presence', 'other_account',\n                  'demographic_target_count',\n                  'purpose', 'is_avail_volunteer', 'count_avail_volunteer', 'content_developer',\n                  'selection_criteria', 'is_real_time')\n        widgets = {'social_presence': forms.CheckboxSelectMultiple}\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'view_community_request' community_request.slug %}\"\n    def clean_social_presence(self):\n        \"\"\"Converts the checkbox input into char to save it to the instance's field.\"\"\"\n        social_presence = ', '.join(\n            map(str, self.cleaned_data['social_presence']))\n        return social_presence\n    def clean_slug(self):\n        \"\"\"Checks if the slug exists in the Community objects' slug\"\"\"\n        slug = self.cleaned_data['slug']\n        slug_community_values = Community.objects.all().values_list('order', flat=True)\n        if slug in slug_community_values:\n            msg = \"Slug by this value already exists. Please choose a different slug\\\n                   other than {0}!\"\n            string_slug_values = ', '.join(map(str, slug_community_values))\n            raise ValidationError(msg.format(string_slug_values))\n        else:\n            return slug\n    def clean_order(self):\n        \"\"\"Checks if the order exists in the Community objects' order\"\"\"\n        order = self.cleaned_data['order']\n        order_community_values = list(\n            Community.objects.all().values_list('order', flat=True))\n        order_community_values.sort()\n        if order is None:\n            raise ValidationError(\"Order must not be None.\")\n        elif order in order_community_values:\n            msg = \"Choose order value other than {0}\"\n            string_order_values = ', '.join(map(str, order_community_values))\n            raise ValidationError(msg.format(string_order_values))\n        else:\n            return order\nclass EditCommunityForm(ModelFormWithHelper):\n    \"\"\"Form to edit Community profile\"\"\"\n    class Meta:\n        model = Community\n        fields = ('name', 'slug', 'order', 'location', 'email', 'mailing_list',\n                  'parent_community', 'website', 'facebook', 'googleplus',\n                  'twitter')\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'view_community_profile' \" \\\n                             \"community.slug %}\"\nclass AddCommunityPageForm(ModelFormWithHelper):\n    \"\"\"Form to create new CommunityPage. The author and the community of the\n    page are expected to be provided when initializing the form:\n    * author - currently logged in user, aka the author of the page\n    * community - to which Community the CommunityPage belongs\n    \"\"\"\n    class Meta:\n        model = CommunityPage\n        fields = ('title', 'slug', 'order', 'content')\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'view_community_landing' \" \\\n                             \"community.slug %}\"\n    def __init__(self, *args, **kwargs):\n        self.author = kwargs.pop('author')\n        self.community = kwargs.pop('community')\n        super(AddCommunityPageForm, self).__init__(*args, **kwargs)\n    def save(self, commit=True):\n        \"\"\"Override save to add author and community to the instance\"\"\"\n        instance = super(AddCommunityPageForm, self).save(commit=False)\n        instance.author = SystersUser.objects.get(user=self.author)\n        instance.community = self.community\n        if commit:\n            instance.save()\n        return instance\nclass EditCommunityPageForm(ModelFormWithHelper):\n    \"\"\"Form to edit a CommunityPage.\"\"\"\n    class Meta:\n        model = CommunityPage\n        fields = ('slug', 'title', 'order', 'content')\n        helper_class = SubmitCancelFormHelper\n        helper_cancel_href = \"{% url 'view_community_page' community.slug \" \\\n                             \"object.slug %}\"\nclass PermissionGroupsForm(forms.Form):\n    \"\"\"Form to manage (select/deselect) user permission groups\"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user')\n        community = kwargs.pop('community')\n        super(PermissionGroupsForm, self).__init__(*args, **kwargs)\n        # get all community groups and remove community admin group\n        # from the list of choices\n        self.groups = list(get_groups(community.name))\n        admin_group = Group.objects.get(\n            name=COMMUNITY_ADMIN.format(community.name))\n        self.groups.remove(admin_group)\n        choices = [(group.pk, group.name) for group in self.groups]\n        self.fields['groups'] = forms. \\\n            MultipleChoiceField(choices=choices, label=\"\", required=False,\n                                widget=forms.CheckboxSelectMultiple)\nNext line of code:\n",
        "prediction": "\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user')\n        community = kwargs.pop('community')\n        super(PermissionGroupsForm, self).__init__(*args, **kwargs)\n        # get all community groups",
        "gold": [
            "        self.member_groups = self.user.get_member_groups(self.groups)"
        ],
        "time": 3.362874984741211
    },
    "15": {
        "origin_prompt": "Please complete the code given below. \n/*\n * Copyright (C) 2006-2010 - Frictional Games\n *\n * This file is part of HPL1 Engine.\n *\n * HPL1 Engine is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * HPL1 Engine is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with HPL1 Engine.  If not, see <http://www.gnu.org/licenses/>.\n */\nusing System;\nusing System.Drawing;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.Windows.Forms;\nnamespace Mapeditor\n{\n\t/// <summary>\n\t/// Summary description for PropertiesLightForm.\n\t/// </summary>\n\tpublic class frmPropertiesArea : System.Windows.Forms.Form\n\t{\n\t\tpublic bool mbOkWasPressed=false;\n\t\tcArea mArea;\n        private System.Windows.Forms.Label objNameLabel;\n\t\tprivate System.Windows.Forms.Label label1;\n\t\tpublic System.Windows.Forms.Button objOkButton;\n\t\tpublic System.Windows.Forms.Button objCancelButtom;\n\t\tpublic System.Windows.Forms.TextBox objNameText;\n\t\tprivate System.Windows.Forms.Label label6;\n\t\tpublic System.Windows.Forms.ComboBox objActiveBox;\n\t\tpublic System.Windows.Forms.TextBox objXText;\n\t\tprivate System.Windows.Forms.Label objXLabel;\n\t\tprivate System.Windows.Forms.Label objYLabel;\n\t\tprivate System.Windows.Forms.Label label3;\n\t\tpublic System.Windows.Forms.TextBox objZText;\n\t\tprivate System.Windows.Forms.Label label4;\n\t\tpublic System.Windows.Forms.ComboBox objTypeBox;\n\t\tprivate System.Windows.Forms.Label label5;\n\t\tpublic System.Windows.Forms.TextBox objYText;\n\t\tprivate System.Windows.Forms.Label objZLabel;\n\t\tpublic System.Windows.Forms.TextBox objWidthText;\n\t\tprivate System.Windows.Forms.Label label7;\n\t\tpublic System.Windows.Forms.TextBox objHeightText;\n\t\tprivate System.Windows.Forms.Label label8;\n\t\t/// <summary>\n\t\t/// Required designer variable.\n\t\t/// </summary>\n\t\tprivate System.ComponentModel.Container components = null;\n\t\tpublic frmPropertiesArea(cArea aArea)\n\t\t{\n\t\t\t//\n\t\t\t// Required for Windows Form Designer support\n\t\t\t//\n\t\t\tInitializeComponent();\n\t\t\t//\n\t\t\t// TODO: Add any constructor code after InitializeComponent call\n\t\t\t//\n\t\t\tmArea = aArea;\n\t\t\tobjNameText.Text = aArea.msName;\n\t\t\tobjActiveBox.SelectedIndex = aArea.mbActive?1:0;\n\t\t\t\n\t\t\tobjHeightText.Text = aArea.mfHeight.ToString();\n\t\t\tobjWidthText.Text = aArea.mfWidth.ToString();\n\t\t\t\n\t\t\tobjXLabel.Text = ((cAreaType)aArea.mAForm.mlstTypes[aArea.mlTypeNum]).msDesc[0];\n\t\t\tobjXText.Text = aArea.mfSizeX.ToString();\n\t\t\t\n\t\t\tobjYLabel.Text = ((cAreaType)aArea.mAForm.mlstTypes[aArea.mlTypeNum]).msDesc[1];\n\t\t\tobjYText.Text = aArea.mfSizeY.ToString();\n\t\t\t\n\t\t\tobjZLabel.Text = ((cAreaType)aArea.mAForm.mlstTypes[aArea.mlTypeNum]).msDesc[2];\n\t\t\tobjZText.Text = aArea.mfSizeZ.ToString();\n\t\t\t\n\t\t\tforeach(string sN in aArea.mAForm.objTypeList.Items)\n\t\t\t{\n\t\t\t\tobjTypeBox.Items.Add(sN);\n\t\t\t}\n\t\t\tobjTypeBox.SelectedIndex = aArea.mlTypeNum;\n\t   }\n\t\t/// <summary>\n\t\t/// Clean up any resources being used.\n\t\t/// </summary>\n\t\tprotected override void Dispose( bool disposing )\n\t\t{\n\t\t\tif( disposing )\n\t\t\t{\n\t\t\t\tif(components != null)\n\t\t\t\t{\n\t\t\t\t\tcomponents.Dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.Dispose( disposing );\n\t\t}\n\t\t#region Windows Form Designer generated code\n\t\t/// <summary>\n\t\t/// Required method for Designer support - do not modify\n\t\t/// the contents of this method with the code editor.\n\t\t/// </summary>\n\t\tprivate void InitializeComponent()\n\t\t{\n\t\t\tthis.objNameLabel = new System.Windows.Forms.Label();\n\t\t\tthis.label1 = new System.Windows.Forms.Label();\n\t\t\tthis.objNameText = new System.Windows.Forms.TextBox();\n\t\t\tthis.objXText = new System.Windows.Forms.TextBox();\n\t\t\tthis.objOkButton = new System.Windows.Forms.Button();\n\t\t\tthis.objCancelButtom = new System.Windows.Forms.Button();\n\t\t\tthis.objXLabel = new System.Windows.Forms.Label();\n\t\t\tthis.label6 = new System.Windows.Forms.Label();\n\t\t\tthis.objActiveBox = new System.Windows.Forms.ComboBox();\n\t\t\tthis.objYLabel = new System.Windows.Forms.Label();\n\t\t\tthis.objYText = new System.Windows.Forms.TextBox();\n\t\t\tthis.label3 = new System.Windows.Forms.Label();\n\t\t\tthis.objZLabel = new System.Windows.Forms.Label();\n\t\t\tthis.objZText = new System.Windows.Forms.TextBox();\n\t\t\tthis.label4 = new System.Windows.Forms.Label();\n\t\t\tthis.objTypeBox = new System.Windows.Forms.ComboBox();\n\t\t\tthis.label5 = new System.Windows.Forms.Label();\n\t\t\tthis.objWidthText = new System.Windows.Forms.TextBox();\n\t\t\tthis.label7 = new System.Windows.Forms.Label();\n\t\t\tthis.objHeightText = new System.Windows.Forms.TextBox();\n\t\t\tthis.label8 = new System.Windows.Forms.Label();\n\t\t\tthis.SuspendLayout();\n\t\t\t// \n\t\t\t// objNameLabel\n\t\t\t// \n\t\t\tthis.objNameLabel.Location = new System.Drawing.Point(16, 16);\n\t\t\tthis.objNameLabel.Name = \"objNameLabel\";\n\t\t\tthis.objNameLabel.Size = new System.Drawing.Size(64, 16);\n\t\t\tthis.objNameLabel.TabIndex = 0;\n\t\t\tthis.objNameLabel.Text = \"Name:\";\n\t\t\t// \n\t\t\t// label1\n\t\t\t// \n\t\t\tthis.label1.Location = new System.Drawing.Point(16, 200);\n\t\t\tthis.label1.Name = \"label1\";\n\t\t\tthis.label1.Size = new System.Drawing.Size(48, 16);\n\t\t\tthis.label1.TabIndex = 1;\n\t\t\tthis.label1.Text = \"Var X:\";\n\t\t\t// \n\t\t\t// objNameText\n\t\t\t// \n\t\t\tthis.objNameText.Location = new System.Drawing.Point(104, 16);\n\t\t\tthis.objNameText.MaxLength = 40;\n\t\t\tthis.objNameText.Name = \"objNameText\";\n\t\t\tthis.objNameText.Size = new System.Drawing.Size(104, 20);\n\t\t\tthis.objNameText.TabIndex = 3;\n\t\t\tthis.objNameText.Text = \"\";\n\t\t\t// \n\t\t\t// objXText\n\t\t\t// \n\t\t\tthis.objXText.Location = new System.Drawing.Point(104, 192);\n\t\t\tthis.objXText.MaxLength = 40;\n\t\t\tthis.objXText.Name = \"objXText\";\n\t\t\tthis.objXText.Size = new System.Drawing.Size(104, 20);\n\t\t\tthis.objXText.TabIndex = 4;\n\t\t\tthis.objXText.Text = \"\";\n\t\t\t// \n\t\t\t// objOkButton\n\t\t\t// \n\t\t\tthis.objOkButton.Location = new System.Drawing.Point(24, 432);\n\t\t\tthis.objOkButton.Name = \"objOkButton\";\n\t\t\tthis.objOkButton.Size = new System.Drawing.Size(72, 24);\n\t\t\tthis.objOkButton.TabIndex = 7;\n\t\t\tthis.objOkButton.Text = \"OK\";\n\t\t\tthis.objOkButton.Click += new System.EventHandler(this.objOkButton_Click);\n\t\t\t// \n\t\t\t// objCancelButtom\n\t\t\t// \n\t\t\tthis.objCancelButtom.Location = new System.Drawing.Point(120, 432);\n\t\t\tthis.objCancelButtom.Name = \"objCancelButtom\";\n\t\t\tthis.objCancelButtom.Size = new System.Drawing.Size(72, 24);\n\t\t\tthis.objCancelButtom.TabIndex = 8;\n\t\t\tthis.objCancelButtom.Text = \"Cancel\";\n\t\t\tthis.objCancelButtom.Click += new System.EventHandler(this.objCancelButtom_Click);\n\t\t\t// \n\t\t\t// objXLabel\n\t\t\t// \n\t\t\tthis.objXLabel.Font = new System.Drawing.Font(\"Microsoft Sans Serif\", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));\n\t\t\tthis.objXLabel.Location = new System.Drawing.Point(16, 160);\n\t\t\tthis.objXLabel.Name = \"objXLabel\";\n\t\t\tthis.objXLabel.Size = new System.Drawing.Size(200, 32);\n\t\t\tthis.objXLabel.TabIndex = 12;\n\t\t\tthis.objXLabel.Text = \"Description...\";\n\t\t\t// \n\t\t\t// label6\n\t\t\t// \n\t\t\tthis.label6.Location = new System.Drawing.Point(16, 48);\n\t\t\tthis.label6.Name = \"label6\";\n\t\t\tthis.label6.Size = new System.Drawing.Size(48, 16);\n\t\t\tthis.label6.TabIndex = 15;\n\t\t\tthis.label6.Text = \"Active:\";\n\t\t\t// \n\t\t\t// objActiveBox\n\t\t\t// \n\t\t\tthis.objActiveBox.Items.AddRange(new object[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"False\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"True\"});\n\t\t\tthis.objActiveBox.Location = new System.Drawing.Point(104, 48);\n\t\t\tthis.objActiveBox.Name = \"objActiveBox\";\n\t\t\tthis.objActiveBox.Size = new System.Drawing.Size(104, 21);\n\t\t\tthis.objActiveBox.TabIndex = 16;\n\t\t\t// \n\t\t\t// objYLabel\n\t\t\t// \n\t\t\tthis.objYLabel.Font = new System.Drawing.Font(\"Microsoft Sans Serif\", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));\n\t\t\tthis.objYLabel.Location = new System.Drawing.Point(16, 224);\n\t\t\tthis.objYLabel.Name = \"objYLabel\";\nNext line of code:\n",
        "prediction": "\t\t\tthis.objYLabel.Size = new System.Drawing.Size(200, 32);\n\t\t\tthis.objYLabel.TabIndex = 17;\n\t\t\tthis.objYLabel.Text = \"Y:\";\n\t\t\t//",
        "gold": [
            "\t\t\tthis.objYLabel.Size = new System.Drawing.Size(200, 32);"
        ],
        "time": 3.361168622970581
    },
    "16": {
        "origin_prompt": "Please complete the code given below. \n// CommonSecurityDescriptorTest.cs - NUnit Test Cases for CommonSecurityDescriptor\n//\n// Authors:\n//\tJames Bellinger  <jfb@zer7.com>\n//\n// Copyright (C) 2012 James Bellinger\nusing System;\nusing System.Collections.Generic;\nusing System.Security.AccessControl;\nusing System.Security.Principal;\nusing NUnit.Framework;\nnamespace MonoTests.System.Security.AccessControl\n{\n\t[TestFixture]\n\tpublic class CommonSecurityDescriptorTest\n\t{\n\t\t[Test]\n\t\tpublic void DefaultOwnerAndGroup ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(false, false, ControlFlags.None, null, null, null, null);\n\t\t\tAssert.IsNull (csd.Owner);\n\t\t\tAssert.IsNull (csd.Group);\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent\n\t\t\t                 | ControlFlags.SelfRelative, csd.ControlFlags);\n\t\t}\n\t\t[Test]\n\t\tpublic void GetBinaryForm ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(false, false, ControlFlags.None, null, null, null, null);\n\t\t\tAssert.AreEqual (20, csd.BinaryLength);\n\t\t\tbyte[] binaryForm = new byte[csd.BinaryLength];\n\t\t\tcsd.GetBinaryForm (binaryForm, 0);\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent | ControlFlags.SelfRelative,\n\t\t\t                 csd.ControlFlags);\n\t\t\t// The default 'Allow Everyone Full Access' serializes as NOT having a\n\t\t\t// DiscretionaryAcl, as the above demonstrates (byte 3 is 0 not 4).\n\t\t\tAssert.AreEqual (new byte[20] {\n\t\t\t\t1, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n\t\t\t}, binaryForm);\n\t\t\t// Changing SystemAcl protection does nothing special.\n\t\t\tcsd.SetSystemAclProtection (true, true);\n\t\t\tAssert.AreEqual (20, csd.BinaryLength);\n\t\t\t// Modifying the DiscretionaryAcl (even effective no-ops like this) causes serialization.\n\t\t\tcsd.SetDiscretionaryAclProtection (false, true);\n\t\t\tAssert.AreEqual (48, csd.BinaryLength);\n\t\t}\n\t\t[Test, ExpectedException (typeof (ArgumentOutOfRangeException))]\n\t\tpublic void GetBinaryFormOffset ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(false, false, ControlFlags.None, null, null, null, null);\n\t\t\tcsd.GetBinaryForm (new byte[csd.BinaryLength], 1);\n\t\t}\n\t\t[Test, ExpectedException (typeof (ArgumentNullException))]\n\t\tpublic void GetBinaryFormNull ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(false, false, ControlFlags.None, null, null, null, null);\n\t\t\tcsd.GetBinaryForm (null, 0);\n\t\t}\n\t\t[Test]\n\t\tpublic void AefaModifiedFlagIsStoredOnDiscretionaryAcl ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd1, csd2;\n\t\t\t// Incidentally this shows the DiscretionaryAcl is NOT cloned.\n\t\t\tcsd1 = new CommonSecurityDescriptor (false, false, ControlFlags.None, null, null, null, null);\n\t\t\tcsd2 = new CommonSecurityDescriptor (false, false, ControlFlags.None, null, null, null, csd1.DiscretionaryAcl);\n\t\t\tAssert.AreSame (csd1.DiscretionaryAcl, csd2.DiscretionaryAcl);\n\t\t\tAssert.AreEqual (\"\", csd1.GetSddlForm (AccessControlSections.Access));\n\t\t\tcsd2.SetDiscretionaryAclProtection (false, true);\n\t\t\tAssert.AreEqual (\"D:(A;;0xffffffff;;;WD)\", csd1.GetSddlForm (AccessControlSections.Access));\n\t\t\tAssert.AreEqual (\"D:(A;;0xffffffff;;;WD)\", csd2.GetSddlForm (AccessControlSections.Access));\n\t\t}\n\t\t[Test]\n\t\tpublic void AefaRoundtrip ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd;\n\t\t\tcsd = new CommonSecurityDescriptor (false, false, ControlFlags.None, null, null, null, null);\n\t\t\tAssert.AreEqual (20, csd.BinaryLength);\n\t\t\tbyte[] binaryForm1 = new byte[csd.BinaryLength];\n\t\t\tcsd.GetBinaryForm (binaryForm1, 0);\n\t\t\tcsd = new CommonSecurityDescriptor (false, false, new RawSecurityDescriptor (binaryForm1, 0));\n\t\t\tbyte[] binaryForm2 = new byte[csd.BinaryLength];\n\t\t\tcsd.GetBinaryForm (binaryForm2, 0);\n\t\t\tAssert.AreEqual (binaryForm1, binaryForm2);\n\t\t}\n\t\t[Test]\n\t\tpublic void GetSddlFormAefaRemovesDacl ()\n\t\t{\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(false, false, ControlFlags.None, null, null, null, null);\n\t\t\tAssert.AreEqual (1, csd.DiscretionaryAcl.Count);\n\t\t\tAssert.AreEqual (\"\", csd.GetSddlForm (AccessControlSections.Access));\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent\n\t\t\t                 | ControlFlags.SelfRelative,\n\t\t\t                 csd.ControlFlags);\n\t\t\tAssert.AreSame (csd.DiscretionaryAcl, csd.DiscretionaryAcl);\n\t\t\tAssert.AreNotSame (csd.DiscretionaryAcl[0], csd.DiscretionaryAcl[0]);\n\t\t\tAssert.AreEqual (\"\", csd.GetSddlForm (AccessControlSections.Access));\n\t\t\tcsd.SetDiscretionaryAclProtection (false, true);\n\t\t\tAssert.AreEqual (\"D:(A;;0xffffffff;;;WD)\", csd.GetSddlForm (AccessControlSections.Access));\n\t\t\tAssert.AreSame (csd.DiscretionaryAcl, csd.DiscretionaryAcl);\n\t\t\tAssert.AreNotSame (csd.DiscretionaryAcl[0], csd.DiscretionaryAcl[0]);\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent\n\t\t\t                 | ControlFlags.SelfRelative,\n\t\t\t                 csd.ControlFlags);\n\t\t\tcsd.SetDiscretionaryAclProtection (true, true);\n\t\t\tAssert.AreEqual (1, csd.DiscretionaryAcl.Count);\n\t\t\tAssert.AreEqual (\"D:P(A;;0xffffffff;;;WD)\", csd.GetSddlForm (AccessControlSections.Access));\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent\n\t\t\t                 | ControlFlags.DiscretionaryAclProtected\n\t\t\t                 | ControlFlags.SelfRelative,\n\t\t\t                 csd.ControlFlags);\n\t\t\tcsd.SetDiscretionaryAclProtection (false, false);\n\t\t\tAssert.AreEqual (1, csd.DiscretionaryAcl.Count);\n\t\t\tAssert.AreEqual (\"D:(A;;0xffffffff;;;WD)\", csd.GetSddlForm (AccessControlSections.Access));\n\t\t\tAssert.AreEqual (ControlFlags.DiscretionaryAclPresent\n\t\t\t                 | ControlFlags.SelfRelative,\n\t\t\t                 csd.ControlFlags);\n\t\t}\n\t\t[Test, ExpectedException (typeof (ArgumentException))]\n\t\tpublic void ContainerAndDSConsistencyEnforcedA ()\n\t\t{\n\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (WellKnownSidType.LocalSystemSid, null);\n\t\t\tSecurityIdentifier groupSid = new SecurityIdentifier (WellKnownSidType.BuiltinAdministratorsSid, null);\n\t\t\tDiscretionaryAcl dacl = new DiscretionaryAcl (true, true, 0);\n\t\t\tnew CommonSecurityDescriptor (true, false, ControlFlags.None, userSid, groupSid, null, dacl);\n\t\t}\n\t\t[Test, ExpectedException (typeof (ArgumentException))]\n\t\tpublic void ContainerAndDSConsistencyEnforcedB ()\n\t\t{\n\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (WellKnownSidType.LocalSystemSid, null);\n\t\t\tSecurityIdentifier groupSid = new SecurityIdentifier (WellKnownSidType.BuiltinAdministratorsSid, null);\n\t\t\tSystemAcl sacl = new SystemAcl (false, false, 0);\n\t\t\tnew CommonSecurityDescriptor (true, false, ControlFlags.None, userSid, groupSid, sacl, null);\n\t\t}\n\t\t[Test, ExpectedException (typeof (ArgumentException))]\n\t\tpublic void ContainerAndDSConsistencyEnforcedInSetter ()\n\t\t{\n\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (WellKnownSidType.LocalSystemSid, null);\n\t\t\tSecurityIdentifier groupSid = new SecurityIdentifier (WellKnownSidType.BuiltinAdministratorsSid, null);\n\t\t\tCommonSecurityDescriptor csd = new CommonSecurityDescriptor\n\t\t\t\t(true, false, ControlFlags.None, userSid, groupSid, null, null);\n\t\t\tcsd.DiscretionaryAcl = new DiscretionaryAcl (true, true, 0);\n\t\t}\n\t\t[Test]\n\t\tpublic void DefaultDaclIsAllowEveryoneFullAccess ()\n\t\t{\n\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (\"SY\");\n\t\t\tSecurityIdentifier groupSid = new SecurityIdentifier (\"BA\");\n\t\t\tSecurityIdentifier everyoneSid = new SecurityIdentifier (\"WD\");\n\t\t\tCommonSecurityDescriptor csd; DiscretionaryAcl dacl; CommonAce ace;\n\t\t\tcsd = new CommonSecurityDescriptor (false, false, ControlFlags.None, userSid, groupSid, null, null);\n\t\t\tdacl = csd.DiscretionaryAcl;\n\t\t\tAssert.AreEqual (1, dacl.Count);\n\t\t\tace = (CommonAce)dacl [0];\n\t\t\tAssert.AreEqual (-1, ace.AccessMask);\n\t\t\tAssert.AreEqual (AceFlags.None, ace.AceFlags);\n\t\t\tAssert.AreEqual (AceType.AccessAllowed, ace.AceType);\n\t\t\tAssert.AreEqual (20, ace.BinaryLength);\n\t\t\tAssert.IsFalse (ace.IsCallback);\n\t\t\tAssert.IsFalse (ace.IsInherited);\n\t\t\tAssert.AreEqual (0, ace.OpaqueLength);\n\t\t\tAssert.AreEqual (ace.SecurityIdentifier, everyoneSid);\n\t\t\tcsd = new CommonSecurityDescriptor (true, false, ControlFlags.None, userSid, groupSid, null, null);\n\t\t\tdacl = csd.DiscretionaryAcl;\n\t\t\tAssert.AreEqual (1, dacl.Count);\n\t\t\tace = (CommonAce)dacl [0];\n\t\t\tAssert.AreEqual (-1, ace.AccessMask);\n\t\t\tAssert.AreEqual (AceFlags.ObjectInherit | AceFlags.ContainerInherit, ace.AceFlags);\n\t\t\tAssert.AreEqual (AceType.AccessAllowed, ace.AceType);\n\t\t\tAssert.AreEqual (20, ace.BinaryLength);\n\t\t\tAssert.IsFalse (ace.IsCallback);\n\t\t\tAssert.IsFalse (ace.IsInherited);\n\t\t\tAssert.AreEqual (0, ace.OpaqueLength);\n\t\t\tAssert.AreEqual (ace.SecurityIdentifier, everyoneSid);\n\t\t}\n\t\t[Test]\n\t\tpublic void PurgeDefaultDacl ()\n\t\t{\nNext line of code:\n",
        "prediction": "\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (\"SY\");\n\t\t\tSecurityIdentifier groupSid = new SecurityIdentifier (\"BA\");\n\t\t\tSecurityIdentifier everyoneSid = new SecurityIdentifier (\"WD\");\n\t\t\tCommonSecurityDescriptor csd; DiscretionaryAcl d",
        "gold": [
            "\t\t\tSecurityIdentifier userSid = new SecurityIdentifier (\"SY\");"
        ],
        "time": 3.366156578063965
    },
    "17": {
        "origin_prompt": "Please complete the code given below. \n/**\n * Copyright (c) 2002-2012 \"Neo Technology,\"\n * Network Engine for Objects in Lund AB [http://neotechnology.com]\n *\n * This file is part of Neo4j.\n *\n * Neo4j is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.neo4j.graphmatching;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.neo4j.graphdb.Node;\nimport org.neo4j.graphmatching.filter.AbstractFilterExpression;\nimport org.neo4j.graphmatching.filter.FilterBinaryNode;\nimport org.neo4j.graphmatching.filter.FilterExpression;\nimport org.neo4j.graphmatching.filter.FilterValueGetter;\nimport org.neo4j.helpers.Predicate;\nimport org.neo4j.helpers.collection.FilteringIterable;\n/**\n * The PatternMatcher is the engine that performs the matching of a graph\n * pattern with the actual graph.\n */\n@Deprecated\npublic class PatternMatcher\n{\n\tprivate static PatternMatcher matcher = new PatternMatcher();\n\tprivate PatternMatcher()\n\t{\n\t}\n    /**\n     * Get the sole instance of the {@link PatternMatcher}.\n     *\n     * @return the instance of {@link PatternMatcher}.\n     */\n\tpublic static PatternMatcher getMatcher()\n\t{\n\t\treturn matcher;\n\t}\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param startNode the {@link Node} to start matching at.\n     * @return all matching instances of the pattern.\n     */\n    public Iterable<PatternMatch> match( PatternNode start,\n        Node startNode )\n    {\n        return match( start, startNode, null );\n    }\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param startNode the {@link Node} to start matching at.\n     * @param objectVariables mapping from names to {@link PatternNode}s.\n     * @return all matching instances of the pattern.\n     */\n\tpublic Iterable<PatternMatch> match( PatternNode start,\n\t\tNode startNode, Map<String, PatternNode> objectVariables )\n\t{\n\t\treturn match( start, startNode, objectVariables,\n\t\t    ( Collection<PatternNode> ) null );\n\t}\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param objectVariables mapping from names to {@link PatternNode}s.\n     * @param optional nodes that form sub-patterns connected to this pattern.\n     * @return all matching instances of the pattern.\n     */\n    public Iterable<PatternMatch> match( PatternNode start,\n            Map<String, PatternNode> objectVariables,\n            PatternNode... optional )\n    {\n        return match( start, objectVariables,\n            Arrays.asList( optional ) );\n    }\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param objectVariables mapping from names to {@link PatternNode}s.\n     * @param optional nodes that form sub-patterns connected to this pattern.\n     * @return all matching instances of the pattern.\n     */\n\tpublic Iterable<PatternMatch> match( PatternNode start,\n\t        Map<String, PatternNode> objectVariables,\n\t        Collection<PatternNode> optional )\n    {\n\t    Node startNode = start.getAssociation();\n        if ( startNode == null )\n        {\n            throw new IllegalStateException(\n                    \"Associating node for start pattern node is null\" );\n        }\n\t    return match( start, startNode, objectVariables, optional );\n    }\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param startNode the {@link Node} to start matching at.\n     * @param objectVariables mapping from names to {@link PatternNode}s.\n     * @param optional nodes that form sub-patterns connected to this pattern.\n     * @return all matching instances of the pattern.\n     */\n\tpublic Iterable<PatternMatch> match( PatternNode start,\n\t\tNode startNode, Map<String, PatternNode> objectVariables,\n\t\tCollection<PatternNode> optional )\n\t{\n        Node currentStartNode = start.getAssociation();\n        if ( currentStartNode != null && !currentStartNode.equals( startNode ) )\n        {\n            throw new IllegalStateException(\n                    \"Start patter node already has associated \" +\n                    currentStartNode + \", can not start with \" + startNode );\n        }\n\t    Iterable<PatternMatch> result = null;\n\t\tif ( optional == null || optional.size() < 1 )\n\t\t{\n\t\t\tresult = new PatternFinder( this, start, startNode );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = new PatternFinder( this, start, startNode, false,\n\t\t\t    optional );\n\t\t}\n\t\tif ( objectVariables != null )\n\t\t{\n    \t\t// Uses the FILTER expressions\n    \t\tresult = new FilteredPatternFinder( result, objectVariables );\n\t\t}\n\t\treturn result;\n\t}\n    /**\n     * Find occurrences of the pattern defined by the given {@link PatternNode}\n     * where the given {@link PatternNode} starts matching at the given\n     * {@link Node}.\n     *\n     * @param start the {@link PatternNode} to start matching at.\n     * @param startNode the {@link Node} to start matching at.\n     * @param objectVariables mapping from names to {@link PatternNode}s.\n     * @param optional nodes that form sub-patterns connected to this pattern.\n     * @return all matching instances of the pattern.\n     */\n\tpublic Iterable<PatternMatch> match( PatternNode start,\n\t\tNode startNode, Map<String, PatternNode> objectVariables,\n\t\tPatternNode... optional )\n\t{\n\t\treturn match( start, startNode, objectVariables,\n\t\t    Arrays.asList( optional ) );\n\t}\n\tprivate static class SimpleRegexValueGetter implements FilterValueGetter\n\t{\n\t    private PatternMatch match;\n\t    private Map<String, PatternNode> labelToNode =\n\t        new HashMap<String, PatternNode>();\n\t    private Map<String, String> labelToProperty =\n\t        new HashMap<String, String>();\n\t    SimpleRegexValueGetter( Map<String, PatternNode> objectVariables,\n\t        PatternMatch match, FilterExpression[] expressions )\n\t    {\n            this.match = match;\n            for ( FilterExpression expression : expressions )\n            {\n                mapFromExpression( expression );\n            }\n            this.labelToNode = objectVariables;\n\t    }\n\t    private void mapFromExpression( FilterExpression expression )\n\t    {\n\t        if ( expression instanceof FilterBinaryNode )\n\t        {\n\t            FilterBinaryNode node = ( FilterBinaryNode ) expression;\n\t            mapFromExpression( node.getLeftExpression() );\n\t            mapFromExpression( node.getRightExpression() );\n\t        }\n\t        else\n\t        {\n\t            AbstractFilterExpression pattern =\n\t                ( AbstractFilterExpression ) expression;\n\t            labelToProperty.put( pattern.getLabel(),\n\t                pattern.getProperty() );\n\t        }\n\t    }\n        public String[] getValues( String label )\n        {\n            PatternNode pNode = labelToNode.get( label );\n            if ( pNode == null )\n            {\n                throw new RuntimeException( \"No node for label '\" + label +\n                    \"'\" );\n            }\n            Node node = this.match.getNodeFor( pNode );\n            String propertyKey = labelToProperty.get( label );\n            if ( propertyKey == null )\n            {\n                throw new RuntimeException( \"No property key for label '\" +\n                    label + \"'\" );\n            }\n            Object rawValue = node.getProperty( propertyKey, null );\n            if ( rawValue == null )\n            {\n                return new String[ 0 ];\n            }\n            Collection<Object> values =\n                ArrayPropertyUtil.propertyValueToCollection( rawValue );\n            String[] result = new String[ values.size() ];\n            int counter = 0;\n            for ( Object value : values )\n            {\n                result[ counter++ ] = ( String ) value;\n            }\n            return result;\n        }\n\t}\n\tprivate static class FilteredPatternFinder\n\t    extends FilteringIterable<PatternMatch>\n\t{\n        public FilteredPatternFinder( Iterable<PatternMatch> source,\n            final Map<String, PatternNode> objectVariables )\n        {\nNext line of code:\n",
        "prediction": "           super( source );\n            this.objectVariables = objectVariables;\n        }\n        private Map<String, PatternNode> objectVariables;\n        private Map<String, String> labelToProperty;\n        private Map<String, PatternNode> labelToNode;\n        private",
        "gold": [
            "            super( source, new Predicate<PatternMatch>()"
        ],
        "time": 3.3579087257385254
    },
    "18": {
        "origin_prompt": "Please complete the code given below. \nimport os\nimport zmq\nimport warnings\nTIMEOUT = 1000  # milliseconds\nVERBOSE = False\nRETRY = True  # Should we try to get another server if we can't connect?\nSERVERFILE = \"serverlist.dat\" # Base name of the file containing  server names\nif __name__ == '__main__':\n    VERBOSE = True\ndef printV(*args):\n    if VERBOSE:\n        for arg in args:\n            print arg,\n        print ''\ndef getBasePath(): # Get the base directory of this script\n    return __file__[:__file__.rfind(\"clientBase.py\")]\ndef getServerFile(): # Return the full path the the server list file\n    return os.path.join(getBasePath(), SERVERFILE)\ndef generateConfig(): # generates the config and server files if not found\n    serverFile = getServerFile()\n    if os.path.isfile(serverFile):\n        printV(\"Server List Found at %s\" % serverFile)\n    else:\n        printV(\"No Server List Found\")\n        printV(\"Generating New Server List at %s\" % serverFile)\n        with open(serverFile,'wb') as f:\n            f.write(\"echidna tcp://108.52.218.107:5001\")\nclass SDSSError(Exception):  # custom SDSSError that relates to serverside issues\n    def __init__(self, message, errors=None):\n        super(SDSSError, self).__init__(message)\n        self.errors = errors\nclass ServerList(dict):  # dictionary like class that manages the possible servers\n    def __init__(self, *args, **kwargs):\n        super(ServerList, self).__init__(*args, **kwargs)\n        self.best = None\n        self.priority = {}\n    def addServer(self, name, address, priority):  # add a server to our list of servers\n        server = {\"address\": address, \"priority\": priority}\n        self[name] = server\n        self.priority[priority] = name\n    def addServersFromFile(self, filename):\n        servers = []\n        priority = 0\n        with open(filename, 'rb') as f:\n            for line in f:\n                name, address = line.strip().split()\n                self.addServer(name, address, priority)\n                priority += 1\n    def saveServersToFile(self, filename):\n        lines = []\n        for p in sorted(self.priority.keys()):\n            name = self.priority[p]\n            address = self[name]['address']\n            lines.append(' '.join((name, address)))\n        with open(filename, 'wb') as f:\n            f.write('\\n'.join(lines))\n    def testServer(self, server):\n        try:\n            context = zmq.Context()\n            socket = context.socket(zmq.REQ)\n            socket.LINGER = False\n            socket.connect(server['address'])\n            socket.send(b\"ping\\n\", flags=zmq.NOBLOCK)\n            if socket.poll(timeout=1000, flags=zmq.POLLIN):\n                return True\n            else:\n                return False\n        except zmq.ZMQError as e:\n            raise SDSSError(e.message, e.errno)\n    def getBestServer(self):  # determine the best server\n        for key, server in sorted(self.items(), key=lambda x: x[1]['priority']):\n            isGood = self.testServer(server)\n            if isGood:\n                printV(\"Best Server is %s\" % key)\n                self.best = server['address']\n                break\n        else:\n            self.best = None\n            raise SDSSError(\"No good servers available at the moment\", self.best)\n    def setBestServer(self, server):  # manually override the best server\n        printV(\"Testing Server %s\" % server)\n        isGood = self.testServer(self[server])\n        if isGood:\n            self.best = self[server]['address']\n            printV(\"%s is now connected\" % server)\n        else:\n            raise SDSSError(\"Bad Server: %s\" % server, server)\ngenerateConfig() # Setup the server list and config if needed\nservers = ServerList() # Instantiate a new server list\nservers.addServersFromFile(getServerFile()) # Add servers from our server list\nservers.getBestServer() # Find the best server based on priority and availability\ndef getSocket():\n    context = zmq.Context()\n    socket = context.socket(zmq.REQ)\n    socket.LINGER = False\n    socket.connect(servers.best)\n    return socket\ndef zmqSocketDecorator(func):  # a decorator that handles the zmq sockets and raises SDSS exceptions\n    def wrapper(*args, **kwargs):\n        try:\n            socket = getSocket()\n            return func(socket, *args, **kwargs)\n        except zmq.ZMQError as e:\n            raise SDSSError(e.message, e.errno)\n    return wrapper\n@zmqSocketDecorator\ndef getCommandResult(socket, cmd):  # send a command to the server and return the result\n    global RETRY\n    socket.send(cmd)\n    if socket.poll(timeout=TIMEOUT, flags=zmq.POLLIN):\n        result = socket.recv_pyobj(flags=zmq.NOBLOCK)\n    else:\n        if RETRY:\n            printV(\"Server Disconnected.  Attempting to Connect to Another Server\")\n            servers.getBestServer()\n            RETRY = False\n            result = getCommandResult(cmd)\n            RETRY = True\n            return result\n        else:\n            raise SDSSError(\"Socket timed out\", TIMEOUT)\n    if isinstance(result, Exception):\n        raise SDSSError(*result.args)\n    return result\ndef createCommand(server_func, *args):  # get the command string for a function and it's arguments\n    if len(args):\n        args = \" \".join(map(str, args))\n    else:\n        args = ''\n    cmd = b\"%s\\n%s\" % (server_func, args)\n    return cmd\ndef isValid(server_func):  # checks if a server_func is valid\n    cmd = createCommand('isValid', server_func)\n    result = getCommandResult(cmd)\n    return result\ndef commandArgCount(server_func):  # gets information about the server func\n    cmd = createCommand('argCount', server_func)\n    result = getCommandResult(cmd)\n    return result\ndef _createFunction(server_func, docstr=None):\n    # Create a function object that acts on a server side func with name 'server_func'\n    if isValid(server_func):\n        nargs = commandArgCount(server_func) - 1\n    else:\n        raise SDSSError(\"Invalid Function: %s\" % server_func, server_func)\n    def Func(*args):\n        if len(args) != nargs:\n            message = \"%s takes exactly %i arguments (%i given)\" % (server_func, nargs, len(args))\n            raise TypeError(message)\n        if docstr is not None:\n            Func.__doc__ = docstr\n        cmd = createCommand(server_func, *args)\n        result = getCommandResult(cmd)\n        return result\n    return Func\ndef createFunction(server_func, docstr=None):\n    def initialFunc(*args):\n        initalFunc = _createFunction(server_func, docstr)\n        return initalFunc(*args)\n    return initialFunc\n# define our client-side functions below\ngetRandLC = createFunction(\"randLC\",\n                           \"\"\"\nargs: None\nreturns:\n    filename, redshift, data (tuple):\n        filename (str): name of the file on disk\n        redshift (float): redshift of the object\n        data (numpy structure array): structured array of the data from the LC file\n\"\"\")\ngetLC = createFunction(\"getLC\",\n                       \"\"\"\nargs:\n    ID (str): SDSS J2000 name\nreturns:\n    filename, redshift, data (tuple):\n        filename (str): name of the file on disk\n        redshift (float): redshift of the object\n        data (numpy structure array): structured array of the data from the LC file\n\"\"\")\ngetIDList = createFunction(\"IDList\",\n                           \"\"\"\nargs: None\nreturns:\n    IDList (list): List of strings of SDSS Objects names on disk\n\"\"\")\ngetNearestLC = createFunction('getNearestLC',\n                              \"\"\"\nargs:\n    ID (str): SDSS J200 name\n    tol (float): matching tolerance in degrees\nreturns:\n    filename, reshift, data (tuple):\n        see above\n\"\"\")\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) == 1:\n        print \"Test\"\n    if sys.argv[1] == '--check':\n        for name in sys.argv[2:]:\n            try:\n                getNearestLC(name, 2/60.0/60.0)\n            except SDSSError as e:\n                if 'No objects in list' in e.message:\n                    print \"LC does not exist in data base\", 0, name\n            except IndexError as e:\n                print \"No File Specified\"\n            else:\n                print \"LC does exist in database     \", 1, name\n    elif sys.argv[1] == '--rand':\n        print getRandLC()\nNext line of code:\n",
        "prediction": "   if sys.argv[1] == '--check':\n        for name in sys.argv[2:]:\n            try:\n                getNearestLC(name, 2/60.0/60.0)\n            except SDSSError as e:\n                if",
        "gold": [
            "    elif sys.argv[1] == '--list':"
        ],
        "time": 3.3611323833465576
    },
    "19": {
        "origin_prompt": "Please complete the code given below. \n/*******************************************************************************\n *     ___                  _   ____  ____\n *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n *\n *  Copyright (c) 2014-2019 Appsicle\n *  Copyright (c) 2019-2022 QuestDB\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\npackage io.questdb.cutlass.text;\nimport io.questdb.cairo.ColumnType;\nimport io.questdb.cutlass.json.JsonException;\nimport io.questdb.cutlass.json.JsonLexer;\nimport io.questdb.cutlass.json.JsonParser;\nimport io.questdb.cutlass.text.types.TypeAdapter;\nimport io.questdb.cutlass.text.types.TypeManager;\nimport io.questdb.griffin.SqlKeywords;\nimport io.questdb.log.Log;\nimport io.questdb.log.LogFactory;\nimport io.questdb.std.*;\nimport io.questdb.std.datetime.DateLocale;\nimport io.questdb.std.datetime.DateLocaleFactory;\nimport io.questdb.std.datetime.microtime.TimestampFormatFactory;\nimport io.questdb.std.datetime.millitime.DateFormatFactory;\nimport io.questdb.std.str.AbstractCharSequence;\nimport java.io.Closeable;\npublic class TextMetadataParser implements JsonParser, Mutable, Closeable {\n    private static final Log LOG = LogFactory.getLog(TextMetadataParser.class);\n    private static final int S_NEED_ARRAY = 1;\n    private static final int S_NEED_OBJECT = 2;\n    private static final int S_NEED_PROPERTY = 3;\n    private static final int P_NAME = 1;\n    private static final int P_TYPE = 2;\n    private static final int P_PATTERN = 3;\n    private static final int P_LOCALE = 4;\n    private static final int P_UTF8 = 5;\n    private static final int P_INDEX = 6;\n    private static final CharSequenceIntHashMap propertyNameMap = new CharSequenceIntHashMap();\n    private final DateLocaleFactory dateLocaleFactory;\n    private final ObjectPool<FloatingCharSequence> csPool;\n    private final DateFormatFactory dateFormatFactory;\n    private final TimestampFormatFactory timestampFormatFactory;\n    private final ObjList<CharSequence> columnNames;\n    private final ObjList<TypeAdapter> columnTypes;\n    private final TypeManager typeManager;\n    private final DateLocale dateLocale;\n    private int state = S_NEED_ARRAY;\n    private CharSequence name;\n    private int type = -1;\n    private CharSequence pattern;\n    private CharSequence locale;\n    private int propertyIndex;\n    private long buf;\n    private long bufCapacity = 0;\n    private int bufSize = 0;\n    private CharSequence tableName;\n    private int localePosition;\n    private boolean utf8 = false;\n    private boolean index = false;\n    public TextMetadataParser(TextConfiguration textConfiguration, TypeManager typeManager) {\n        this.columnNames = new ObjList<>();\n        this.columnTypes = new ObjList<>();\n        this.csPool = new ObjectPool<>(FloatingCharSequence::new, textConfiguration.getMetadataStringPoolCapacity());\n        this.dateLocaleFactory = typeManager.getInputFormatConfiguration().getDateLocaleFactory();\n        this.dateFormatFactory = typeManager.getInputFormatConfiguration().getDateFormatFactory();\n        this.timestampFormatFactory = typeManager.getInputFormatConfiguration().getTimestampFormatFactory();\n        this.typeManager = typeManager;\n        this.dateLocale = textConfiguration.getDefaultDateLocale();\n    }\n    @Override\n    public void clear() {\n        bufSize = 0;\n        state = S_NEED_ARRAY;\n        columnNames.clear();\n        columnTypes.clear();\n        csPool.clear();\n        clearStage();\n    }\n    @Override\n    public void close() {\n        clear();\n        if (bufCapacity > 0) {\n            Unsafe.free(buf, bufCapacity, MemoryTag.NATIVE_DEFAULT);\n            bufCapacity = 0;\n        }\n    }\n    public ObjList<CharSequence> getColumnNames() {\n        return columnNames;\n    }\n    public ObjList<TypeAdapter> getColumnTypes() {\n        return columnTypes;\n    }\n    @Override\n    public void onEvent(int code, CharSequence tag, int position) throws JsonException {\n        switch (code) {\n            case JsonLexer.EVT_ARRAY_START:\n                if (state != S_NEED_ARRAY) {\n                    throw JsonException.$(position, \"Unexpected array\");\n                }\n                state = S_NEED_OBJECT;\n                break;\n            case JsonLexer.EVT_OBJ_START:\n                if (state != S_NEED_OBJECT) {\n                    throw JsonException.$(position, \"Unexpected object\");\n                }\n                state = S_NEED_PROPERTY;\n                break;\n            case JsonLexer.EVT_NAME:\n                this.propertyIndex = propertyNameMap.get(tag);\n                if (this.propertyIndex == -1) {\n                    LOG.info().$(\"unknown [table=\").$(tableName).$(\", tag=\").$(tag).$(']').$();\n                }\n                break;\n            case JsonLexer.EVT_VALUE:\n                switch (propertyIndex) {\n                    case P_NAME:\n                        name = copy(tag);\n                        break;\n                    case P_TYPE:\n                        type = ColumnType.tagOf(tag);\n                        if (type == -1) {\n                            throw JsonException.$(position, \"Invalid type\");\n                        }\n                        break;\n                    case P_PATTERN:\n                        pattern = copy(tag);\n                        break;\n                    case P_LOCALE:\n                        locale = copy(tag);\n                        localePosition = position;\n                        break;\n                    case P_UTF8:\n                        utf8 = SqlKeywords.isTrueKeyword(tag);\n                        break;\n                    case P_INDEX:\n                        index = SqlKeywords.isTrueKeyword(tag);\n                        break;\n                    default:\n                        LOG.info().$(\"ignoring [table=\").$(tableName).$(\", value=\").$(tag).$(']').$();\n                        break;\n                }\n                break;\n            case JsonLexer.EVT_OBJ_END:\n                state = S_NEED_OBJECT;\n                createImportedType(position);\n                break;\n            case JsonLexer.EVT_ARRAY_VALUE:\n                throw JsonException.$(position, \"Must be an object\");\n            default:\n                break;\n        }\n    }\n    private static void strcpyw(final CharSequence value, final int len, final long address) {\n        for (int i = 0; i < len; i++) {\n            Unsafe.getUnsafe().putChar(address + ((long) i << 1), value.charAt(i));\n        }\n    }\n    private static void checkInputs(int position, CharSequence name, int type) throws JsonException {\n        if (name == null) {\n            throw JsonException.$(position, \"Missing 'name' property\");\n        }\n        if (type == -1) {\n            throw JsonException.$(position, \"Missing 'type' property\");\n        }\n    }\n    private void clearStage() {\n        name = null;\n        type = -1;\n        pattern = null;\n        locale = null;\n        localePosition = 0;\n        utf8 = false;\n        index = false;\n    }\n    private CharSequence copy(CharSequence tag) {\n        final int l = tag.length() * 2;\n        final long n = bufSize + l;\n        if (n > bufCapacity) {\n            long ptr = Unsafe.malloc(n * 2, MemoryTag.NATIVE_DEFAULT);\n            Vect.memcpy(ptr, buf, bufSize);\n            if (bufCapacity > 0) {\n                Unsafe.free(buf, bufCapacity, MemoryTag.NATIVE_DEFAULT);\n            }\n            buf = ptr;\n            bufCapacity = n * 2;\n        }\n        strcpyw(tag, l / 2, buf + bufSize);\n        CharSequence cs = csPool.next().of(bufSize, l / 2);\n        bufSize += l;\n        return cs;\n    }\n    private void createImportedType(int position) throws JsonException {\n        checkInputs(position, name, type);\n        columnNames.add(name);\n        switch (ColumnType.tagOf(type)) {\n            case ColumnType.DATE:\n                DateLocale dateLocale = locale == null ? this.dateLocale : dateLocaleFactory.getLocale(locale);\n                if (dateLocale == null) {\n                    throw JsonException.$(localePosition, \"Invalid date locale\");\n                }\n                // date pattern is required\n                if (pattern == null) {\n                    throw JsonException.$(0, \"DATE format pattern is required\");\n                }\n                columnTypes.add(typeManager.nextDateAdapter().of(dateFormatFactory.get(pattern), dateLocale));\n                break;\n            case ColumnType.TIMESTAMP:\n                DateLocale timestampLocale =\n                        locale == null ?\n                                this.dateLocale\n                                : dateLocaleFactory.getLocale(locale);\n                if (timestampLocale == null) {\n                    throw JsonException.$(localePosition, \"Invalid timestamp locale\");\n                }\n                // timestamp pattern is required\nNext line of code:\n",
        "prediction": "               if (pattern == null) {\n                    throw JsonException.$(0, \"TIMESTAMP format pattern is required\");\n                }\n                columnTypes.add(typeManager.nextTimestampAdapter().of(timestampFormatFactory.get(pattern), timestampLocale));\n                break;\n           ",
        "gold": [
            "                if (pattern == null) {"
        ],
        "time": 3.3574788570404053
    },
    "20": {
        "origin_prompt": "Please complete the code given below. \n# pylint: disable=no-member\n\"\"\"\nUnit tests for the Mixed Modulestore, with DDT for the various stores (Split, Draft, XML)\n\"\"\"\nfrom collections import namedtuple\nimport datetime\nimport logging\nimport ddt\nimport itertools\nimport mimetypes\nfrom unittest import skip\nfrom uuid import uuid4\nfrom contextlib import contextmanager\nfrom mock import patch\n# Mixed modulestore depends on django, so we'll manually configure some django settings\n# before importing the module\n# TODO remove this import and the configuration -- xmodule should not depend on django!\nfrom django.conf import settings\n# This import breaks this test file when run separately. Needs to be fixed! (PLAT-449)\nfrom mock_django import mock_signal_receiver\nfrom nose.plugins.attrib import attr\nimport pymongo\nfrom pytz import UTC\nfrom shutil import rmtree\nfrom tempfile import mkdtemp\nfrom xmodule.x_module import XModuleMixin\nfrom xmodule.modulestore.edit_info import EditInfoMixin\nfrom xmodule.modulestore.inheritance import InheritanceMixin\nfrom xmodule.modulestore.tests.test_cross_modulestore_import_export import MongoContentstoreBuilder\nfrom xmodule.contentstore.content import StaticContent\nfrom opaque_keys.edx.keys import CourseKey\nfrom xmodule.modulestore.xml_importer import import_course_from_xml\nfrom xmodule.modulestore.xml_exporter import export_course_to_xml\nfrom xmodule.modulestore.django import SignalHandler\nif not settings.configured:\n    settings.configure()\nfrom opaque_keys.edx.locations import SlashSeparatedCourseKey\nfrom opaque_keys.edx.locator import BlockUsageLocator, CourseLocator, LibraryLocator\nfrom xmodule.exceptions import InvalidVersionError\nfrom xmodule.modulestore import ModuleStoreEnum\nfrom xmodule.modulestore.draft_and_published import UnsupportedRevisionError, DIRECT_ONLY_CATEGORIES\nfrom xmodule.modulestore.exceptions import ItemNotFoundError, DuplicateCourseError, ReferentialIntegrityError, NoPathToItem\nfrom xmodule.modulestore.mixed import MixedModuleStore\nfrom xmodule.modulestore.search import path_to_location, navigation_index\nfrom xmodule.modulestore.tests.factories import check_mongo_calls, check_exact_number_of_calls, \\\n    mongo_uses_error_check\nfrom xmodule.modulestore.tests.utils import create_modulestore_instance, LocationMixin, mock_tab_from_json\nfrom xmodule.modulestore.tests.mongo_connection import MONGO_PORT_NUM, MONGO_HOST\nfrom xmodule.tests import DATA_DIR, CourseComparisonTest\nlog = logging.getLogger(__name__)\nclass CommonMixedModuleStoreSetup(CourseComparisonTest):\n    \"\"\"\n    Quasi-superclass which tests Location based apps against both split and mongo dbs (Locator and\n    Location-based dbs)\n    \"\"\"\n    HOST = MONGO_HOST\n    PORT = MONGO_PORT_NUM\n    DB = 'test_mongo_%s' % uuid4().hex[:5]\n    COLLECTION = 'modulestore'\n    ASSET_COLLECTION = 'assetstore'\n    FS_ROOT = DATA_DIR\n    DEFAULT_CLASS = 'xmodule.raw_module.RawDescriptor'\n    RENDER_TEMPLATE = lambda t_n, d, ctx=None, nsp='main': ''\n    MONGO_COURSEID = 'MITx/999/2013_Spring'\n    XML_COURSEID1 = 'edX/toy/2012_Fall'\n    XML_COURSEID2 = 'edX/simple/2012_Fall'\n    BAD_COURSE_ID = 'edX/simple'\n    modulestore_options = {\n        'default_class': DEFAULT_CLASS,\n        'fs_root': DATA_DIR,\n        'render_template': RENDER_TEMPLATE,\n        'xblock_mixins': (EditInfoMixin, InheritanceMixin, LocationMixin, XModuleMixin),\n    }\n    DOC_STORE_CONFIG = {\n        'host': HOST,\n        'port': PORT,\n        'db': DB,\n        'collection': COLLECTION,\n        'asset_collection': ASSET_COLLECTION,\n    }\n    MAPPINGS = {\n        XML_COURSEID1: 'xml',\n        XML_COURSEID2: 'xml',\n        BAD_COURSE_ID: 'xml',\n    }\n    OPTIONS = {\n        'stores': [\n            {\n                'NAME': 'draft',\n                'ENGINE': 'xmodule.modulestore.mongo.draft.DraftModuleStore',\n                'DOC_STORE_CONFIG': DOC_STORE_CONFIG,\n                'OPTIONS': modulestore_options\n            },\n            {\n                'NAME': 'split',\n                'ENGINE': 'xmodule.modulestore.split_mongo.split_draft.DraftVersioningModuleStore',\n                'DOC_STORE_CONFIG': DOC_STORE_CONFIG,\n                'OPTIONS': modulestore_options\n            },\n            {\n                'NAME': 'xml',\n                'ENGINE': 'xmodule.modulestore.xml.XMLModuleStore',\n                'OPTIONS': {\n                    'data_dir': DATA_DIR,\n                    'default_class': 'xmodule.hidden_module.HiddenDescriptor',\n                    'xblock_mixins': modulestore_options['xblock_mixins'],\n                }\n            },\n        ],\n        'xblock_mixins': modulestore_options['xblock_mixins'],\n    }\n    def _compare_ignore_version(self, loc1, loc2, msg=None):\n        \"\"\"\n        AssertEqual replacement for CourseLocator\n        \"\"\"\n        if loc1.for_branch(None) != loc2.for_branch(None):\n            self.fail(self._formatMessage(msg, u\"{} != {}\".format(unicode(loc1), unicode(loc2))))\n    def setUp(self):\n        \"\"\"\n        Set up the database for testing\n        \"\"\"\n        super(CommonMixedModuleStoreSetup, self).setUp()\n        self.exclude_field(None, 'wiki_slug')\n        self.exclude_field(None, 'xml_attributes')\n        self.exclude_field(None, 'parent')\n        self.ignore_asset_key('_id')\n        self.ignore_asset_key('uploadDate')\n        self.ignore_asset_key('content_son')\n        self.ignore_asset_key('thumbnail_location')\n        self.options = getattr(self, 'options', self.OPTIONS)\n        self.connection = pymongo.MongoClient(\n            host=self.HOST,\n            port=self.PORT,\n            tz_aware=True,\n        )\n        self.connection.drop_database(self.DB)\n        self.addCleanup(self.connection.drop_database, self.DB)\n        self.addCleanup(self.connection.close)\n        self.addTypeEqualityFunc(BlockUsageLocator, '_compare_ignore_version')\n        self.addTypeEqualityFunc(CourseLocator, '_compare_ignore_version')\n        # define attrs which get set in initdb to quell pylint\n        self.writable_chapter_location = self.store = self.fake_location = self.xml_chapter_location = None\n        self.course_locations = {}\n        self.user_id = ModuleStoreEnum.UserID.test\n    # pylint: disable=invalid-name\n    def _create_course(self, course_key):\n        \"\"\"\n        Create a course w/ one item in the persistence store using the given course & item location.\n        \"\"\"\n        # create course\n        with self.store.bulk_operations(course_key):\n            self.course = self.store.create_course(course_key.org, course_key.course, course_key.run, self.user_id)\n            if isinstance(self.course.id, CourseLocator):\n                self.course_locations[self.MONGO_COURSEID] = self.course.location\n            else:\n                self.assertEqual(self.course.id, course_key)\n            # create chapter\n            chapter = self.store.create_child(self.user_id, self.course.location, 'chapter', block_id='Overview')\n            self.writable_chapter_location = chapter.location\n    def _create_block_hierarchy(self):\n        \"\"\"\n        Creates a hierarchy of blocks for testing\n        Each block's (version_agnostic) location is assigned as a field of the class and can be easily accessed\n        \"\"\"\n        BlockInfo = namedtuple('BlockInfo', 'field_name, category, display_name, sub_tree')\n        trees = [\n            BlockInfo(\n                'chapter_x', 'chapter', 'Chapter_x', [\n                    BlockInfo(\n                        'sequential_x1', 'sequential', 'Sequential_x1', [\n                            BlockInfo(\n                                'vertical_x1a', 'vertical', 'Vertical_x1a', [\n                                    BlockInfo('problem_x1a_1', 'problem', 'Problem_x1a_1', []),\n                                    BlockInfo('problem_x1a_2', 'problem', 'Problem_x1a_2', []),\n                                    BlockInfo('problem_x1a_3', 'problem', 'Problem_x1a_3', []),\n                                    BlockInfo('html_x1a_1', 'html', 'HTML_x1a_1', []),\n                                ]\n                            ),\n                            BlockInfo(\n                                'vertical_x1b', 'vertical', 'Vertical_x1b', []\n                            )\n                        ]\n                    ),\n                    BlockInfo(\n                        'sequential_x2', 'sequential', 'Sequential_x2', []\n                    )\n                ]\n            ),\n            BlockInfo(\n                'chapter_y', 'chapter', 'Chapter_y', [\n                    BlockInfo(\n                        'sequential_y1', 'sequential', 'Sequential_y1', [\n                            BlockInfo(\n                                'vertical_y1a', 'vertical', 'Vertical_y1a', [\n                                    BlockInfo('problem_y1a_1', 'problem', 'Problem_y1a_1', []),\n                                    BlockInfo('problem_y1a_2', 'problem', 'Problem_y1a_2', []),\n                                    BlockInfo('problem_y1a_3', 'problem', 'Problem_y1a_3', []),\n                                ]\n                            )\n                        ]\n                    )\n                ]\n            )\n        ]\n        def create_sub_tree(parent, block_info):\n            \"\"\"\n            recursive function that creates the given block and its descendants\n            \"\"\"\n            block = self.store.create_child(\n                self.user_id, parent.location,\n                block_info.category, block_id=block_info.display_name,\n                fields={'display_name': block_info.display_name},\n            )\n            for tree in block_info.sub_tree:\n                create_sub_tree(block, tree)\n            setattr(self, block_info.field_name, block.location)\n        with self.store.bulk_operations(self.course.id):\n            for tree in trees:\n                create_sub_tree(self.course, tree)\n    def _course_key_from_string(self, string):\n        \"\"\"\n        Get the course key for the given course string\n        \"\"\"\n        return self.course_locations[string].course_key\n    def _has_changes(self, location):\n        \"\"\"\n        Helper function that loads the item before calling has_changes\n        \"\"\"\n        return self.store.has_changes(self.store.get_item(location))\n    # pylint: disable=dangerous-default-value\n    def _initialize_mixed(self, mappings=MAPPINGS, contentstore=None):\n        \"\"\"\n        initializes the mixed modulestore.\n        \"\"\"\n        self.store = MixedModuleStore(\n            contentstore, create_modulestore_instance=create_modulestore_instance,\n            mappings=mappings,\n            **self.options\n        )\n        self.addCleanup(self.store.close_all_connections)\n    def initdb(self, default):\n        \"\"\"\n        Initialize the database and create one test course in it\n        \"\"\"\n        # set the default modulestore\n        store_configs = self.options['stores']\n        for index in range(len(store_configs)):\n            if store_configs[index]['NAME'] == default:\n                if index > 0:\n                    store_configs[index], store_configs[0] = store_configs[0], store_configs[index]\n                break\n        self._initialize_mixed()\n        # convert to CourseKeys\n        self.course_locations = {\n            course_id: CourseLocator.from_string(course_id)\n            for course_id in [self.MONGO_COURSEID, self.XML_COURSEID1, self.XML_COURSEID2]\n        }\n        # and then to the root UsageKey\n        self.course_locations = {\n            course_id: course_key.make_usage_key('course', course_key.run)\n            for course_id, course_key in self.course_locations.iteritems()  # pylint: disable=maybe-no-member\n        }\n        mongo_course_key = self.course_locations[self.MONGO_COURSEID].course_key\n        self.fake_location = self.store.make_course_key(mongo_course_key.org, mongo_course_key.course, mongo_course_key.run).make_usage_key('vertical', 'fake')\n        self.xml_chapter_location = self.course_locations[self.XML_COURSEID1].replace(\n            category='chapter', name='Overview'\n        )\n        self._create_course(self.course_locations[self.MONGO_COURSEID].course_key)\n@ddt.ddt\n@attr('mongo')\nclass TestMixedModuleStore(CommonMixedModuleStoreSetup):\n    \"\"\"\n    Tests of the MixedModulestore interface methods.\n    \"\"\"\n    @ddt.data('draft', 'split')\n    def test_get_modulestore_type(self, default_ms):\n        \"\"\"\n        Make sure we get back the store type we expect for given mappings\n        \"\"\"\n        self.initdb(default_ms)\n        self.assertEqual(self.store.get_modulestore_type(\n            self._course_key_from_string(self.XML_COURSEID1)), ModuleStoreEnum.Type.xml\n        )\n        self.assertEqual(self.store.get_modulestore_type(\n            self._course_key_from_string(self.XML_COURSEID2)), ModuleStoreEnum.Type.xml\n        )\n        mongo_ms_type = ModuleStoreEnum.Type.mongo if default_ms == 'draft' else ModuleStoreEnum.Type.split\n        self.assertEqual(self.store.get_modulestore_type(\n            self._course_key_from_string(self.MONGO_COURSEID)), mongo_ms_type\n        )\n        # try an unknown mapping, it should be the 'default' store\n        self.assertEqual(self.store.get_modulestore_type(\n            SlashSeparatedCourseKey('foo', 'bar', '2012_Fall')), mongo_ms_type\n        )\n    @ddt.data('draft', 'split')\n    def test_get_modulestore_cache(self, default_ms):\n        \"\"\"\n        Make sure we cache discovered course mappings\n        \"\"\"\n        self.initdb(default_ms)\n        # unset mappings\n        self.store.mappings = {}\n        course_key = self.course_locations[self.MONGO_COURSEID].course_key\n        with check_exact_number_of_calls(self.store.default_modulestore, 'has_course', 1):\n            self.assertEqual(self.store.default_modulestore, self.store._get_modulestore_for_courselike(course_key))  # pylint: disable=protected-access\n            self.assertIn(course_key, self.store.mappings)\n            self.assertEqual(self.store.default_modulestore, self.store._get_modulestore_for_courselike(course_key))  # pylint: disable=protected-access\n    @ddt.data(*itertools.product(\n        (ModuleStoreEnum.Type.mongo, ModuleStoreEnum.Type.split),\n        (True, False)\n    ))\n    @ddt.unpack\n    def test_duplicate_course_error(self, default_ms, reset_mixed_mappings):\n        \"\"\"\n        Make sure we get back the store type we expect for given mappings\n        \"\"\"\n        self._initialize_mixed(mappings={})\n        with self.store.default_store(default_ms):\n            self.store.create_course('org_x', 'course_y', 'run_z', self.user_id)\n            if reset_mixed_mappings:\n                self.store.mappings = {}\n            with self.assertRaises(DuplicateCourseError):\n                self.store.create_course('org_x', 'course_y', 'run_z', self.user_id)\n    # Draft:\n    #    problem: One lookup to locate an item that exists\n    #    fake: one w/ wildcard version\n    # split has one lookup for the course and then one for the course items\n    @ddt.data(('draft', [1, 1], 0), ('split', [2, 2], 0))\n    @ddt.unpack\n    def test_has_item(self, default_ms, max_find, max_send):\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        self.assertTrue(self.store.has_item(self.course_locations[self.XML_COURSEID1]))\n        with check_mongo_calls(max_find.pop(0), max_send):\n            self.assertTrue(self.store.has_item(self.problem_x1a_1))\n        # try negative cases\n        self.assertFalse(self.store.has_item(\n            self.course_locations[self.XML_COURSEID1].replace(name='not_findable', category='problem')\n        ))\n        with check_mongo_calls(max_find.pop(0), max_send):\n            self.assertFalse(self.store.has_item(self.fake_location))\n        # verify that an error is raised when the revision is not valid\n        with self.assertRaises(UnsupportedRevisionError):\n            self.store.has_item(self.fake_location, revision=ModuleStoreEnum.RevisionOption.draft_preferred)\n    # draft queries:\n    #   problem: find draft item, find all items pertinent to inheritance computation, find parent\n    #   non-existent problem: find draft, find published\n    # split:\n    #   problem: active_versions, structure\n    #   non-existent problem: ditto\n    @ddt.data(('draft', [3, 2], 0), ('split', [2, 2], 0))\n    @ddt.unpack\n    def test_get_item(self, default_ms, max_find, max_send):\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        self.assertIsNotNone(self.store.get_item(self.course_locations[self.XML_COURSEID1]))\n        with check_mongo_calls(max_find.pop(0), max_send):\n            self.assertIsNotNone(self.store.get_item(self.problem_x1a_1))\n        # try negative cases\n        with self.assertRaises(ItemNotFoundError):\n            self.store.get_item(\n                self.course_locations[self.XML_COURSEID1].replace(name='not_findable', category='problem')\n            )\n        with check_mongo_calls(max_find.pop(0), max_send):\n            with self.assertRaises(ItemNotFoundError):\n                self.store.get_item(self.fake_location)\n        # verify that an error is raised when the revision is not valid\n        with self.assertRaises(UnsupportedRevisionError):\n            self.store.get_item(self.fake_location, revision=ModuleStoreEnum.RevisionOption.draft_preferred)\n    # Draft:\n    #    wildcard query, 6! load pertinent items for inheritance calls, load parents, course root fetch (why)\n    # Split:\n    #    active_versions (with regex), structure, and spurious active_versions refetch\n    @ddt.data(('draft', 14, 0), ('split', 3, 0))\n    @ddt.unpack\n    def test_get_items(self, default_ms, max_find, max_send):\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        course_locn = self.course_locations[self.XML_COURSEID1]\n        # NOTE: use get_course if you just want the course. get_items is expensive\n        modules = self.store.get_items(course_locn.course_key, qualifiers={'category': 'course'})\n        self.assertEqual(len(modules), 1)\n        self.assertEqual(modules[0].location, course_locn)\n        course_locn = self.course_locations[self.MONGO_COURSEID]\n        with check_mongo_calls(max_find, max_send):\n            modules = self.store.get_items(course_locn.course_key, qualifiers={'category': 'problem'})\n        self.assertEqual(len(modules), 6)\n        # verify that an error is raised when the revision is not valid\n        with self.assertRaises(UnsupportedRevisionError):\n            self.store.get_items(\n                self.course_locations[self.MONGO_COURSEID].course_key,\n                revision=ModuleStoreEnum.RevisionOption.draft_preferred\n            )\n    # draft: get draft, get ancestors up to course (2-6), compute inheritance\n    #    sends: update problem and then each ancestor up to course (edit info)\n    # split: active_versions, definitions (calculator field), structures\n    #  2 sends to update index & structure (note, it would also be definition if a content field changed)\n    @ddt.data(('draft', 7, 5), ('split', 3, 2))\n    @ddt.unpack\n    def test_update_item(self, default_ms, max_find, max_send):\n        \"\"\"\n        Update should fail for r/o dbs and succeed for r/w ones\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        course = self.store.get_course(self.course_locations[self.XML_COURSEID1].course_key)\n        # if following raised, then the test is really a noop, change it\n        self.assertFalse(course.show_calculator, \"Default changed making test meaningless\")\n        course.show_calculator = True\n        with self.assertRaises(NotImplementedError):  # ensure it doesn't allow writing\n            self.store.update_item(course, self.user_id)\n        # now do it for a r/w db\n        problem = self.store.get_item(self.problem_x1a_1)\n        # if following raised, then the test is really a noop, change it\n        self.assertNotEqual(problem.max_attempts, 2, \"Default changed making test meaningless\")\n        problem.max_attempts = 2\n        with check_mongo_calls(max_find, max_send):\n            problem = self.store.update_item(problem, self.user_id)\n        self.assertEqual(problem.max_attempts, 2, \"Update didn't persist\")\n    @ddt.data('draft', 'split')\n    def test_has_changes_direct_only(self, default_ms):\n        \"\"\"\n        Tests that has_changes() returns false when a new xblock in a direct only category is checked\n        \"\"\"\n        self.initdb(default_ms)\n        test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id)\n        # Create dummy direct only xblocks\n        chapter = self.store.create_item(\n            self.user_id,\n            test_course.id,\n            'chapter',\n            block_id='vertical_container'\n        )\n        # Check that neither xblock has changes\n        self.assertFalse(self.store.has_changes(test_course))\n        self.assertFalse(self.store.has_changes(chapter))\n    @ddt.data('draft', 'split')\n    def test_has_changes(self, default_ms):\n        \"\"\"\n        Tests that has_changes() only returns true when changes are present\n        \"\"\"\n        self.initdb(default_ms)\n        test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id)\n        # Create a dummy component to test against\n        xblock = self.store.create_item(\n            self.user_id,\n            test_course.id,\n            'vertical',\n            block_id='test_vertical'\n        )\n        # Not yet published, so changes are present\n        self.assertTrue(self.store.has_changes(xblock))\n        # Publish and verify that there are no unpublished changes\n        newXBlock = self.store.publish(xblock.location, self.user_id)\n        self.assertFalse(self.store.has_changes(newXBlock))\n        # Change the component, then check that there now are changes\n        component = self.store.get_item(xblock.location)\n        component.display_name = 'Changed Display Name'\n        component = self.store.update_item(component, self.user_id)\n        self.assertTrue(self.store.has_changes(component))\n        # Publish and verify again\n        component = self.store.publish(component.location, self.user_id)\n        self.assertFalse(self.store.has_changes(component))\n    @ddt.data('draft', 'split')\n    def test_unit_stuck_in_draft_mode(self, default_ms):\n        \"\"\"\n        After revert_to_published() the has_changes() should return false if draft has no changes\n        \"\"\"\n        self.initdb(default_ms)\n        test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id)\n        # Create a dummy component to test against\n        xblock = self.store.create_item(\n            self.user_id,\n            test_course.id,\n            'vertical',\n            block_id='test_vertical'\n        )\n        # Not yet published, so changes are present\n        self.assertTrue(self.store.has_changes(xblock))\n        # Publish and verify that there are no unpublished changes\n        component = self.store.publish(xblock.location, self.user_id)\n        self.assertFalse(self.store.has_changes(component))\n        self.store.revert_to_published(component.location, self.user_id)\n        component = self.store.get_item(component.location)\n        self.assertFalse(self.store.has_changes(component))\n        # Publish and verify again\n        component = self.store.publish(component.location, self.user_id)\n        self.assertFalse(self.store.has_changes(component))\n    @ddt.data('draft', 'split')\n    def test_unit_stuck_in_published_mode(self, default_ms):\n        \"\"\"\n        After revert_to_published() the has_changes() should return true if draft has changes\n        \"\"\"\n        self.initdb(default_ms)\n        test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id)\n        # Create a dummy component to test against\n        xblock = self.store.create_item(\n            self.user_id,\n            test_course.id,\n            'vertical',\n            block_id='test_vertical'\n        )\n        # Not yet published, so changes are present\n        self.assertTrue(self.store.has_changes(xblock))\n        # Publish and verify that there are no unpublished changes\n        component = self.store.publish(xblock.location, self.user_id)\n        self.assertFalse(self.store.has_changes(component))\n        # Discard changes and verify that there are no changes\n        self.store.revert_to_published(component.location, self.user_id)\n        component = self.store.get_item(component.location)\n        self.assertFalse(self.store.has_changes(component))\n        # Change the component, then check that there now are changes\n        component = self.store.get_item(component.location)\n        component.display_name = 'Changed Display Name'\n        self.store.update_item(component, self.user_id)\n        # Verify that changes are present\n        self.assertTrue(self.store.has_changes(component))\n    def setup_has_changes(self, default_ms):\n        \"\"\"\n        Common set up for has_changes tests below.\n        Returns a dictionary of useful location maps for testing.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        locations = {\n            'grandparent': self.chapter_x,\n            'parent_sibling': self.sequential_x2,\n            'parent': self.sequential_x1,\n            'child_sibling': self.vertical_x1b,\n            'child': self.vertical_x1a,\n        }\n        # Publish the vertical units\n        self.store.publish(locations['parent_sibling'], self.user_id)\n        self.store.publish(locations['parent'], self.user_id)\n        return locations\n    @ddt.data('draft', 'split')\n    def test_has_changes_ancestors(self, default_ms):\n        \"\"\"\n        Tests that has_changes() returns true on ancestors when a child is changed\n        \"\"\"\n        locations = self.setup_has_changes(default_ms)\n        # Verify that there are no unpublished changes\n        for key in locations:\n            self.assertFalse(self._has_changes(locations[key]))\n        # Change the child\n        child = self.store.get_item(locations['child'])\n        child.display_name = 'Changed Display Name'\n        self.store.update_item(child, self.user_id)\n        # All ancestors should have changes, but not siblings\n        self.assertTrue(self._has_changes(locations['grandparent']))\n        self.assertTrue(self._has_changes(locations['parent']))\n        self.assertTrue(self._has_changes(locations['child']))\n        self.assertFalse(self._has_changes(locations['parent_sibling']))\n        self.assertFalse(self._has_changes(locations['child_sibling']))\n        # Publish the unit with changes\n        self.store.publish(locations['parent'], self.user_id)\n        # Verify that there are no unpublished changes\n        for key in locations:\n            self.assertFalse(self._has_changes(locations[key]))\n    @ddt.data('draft', 'split')\n    def test_has_changes_publish_ancestors(self, default_ms):\n        \"\"\"\n        Tests that has_changes() returns false after a child is published only if all children are unchanged\n        \"\"\"\n        locations = self.setup_has_changes(default_ms)\n        # Verify that there are no unpublished changes\n        for key in locations:\n            self.assertFalse(self._has_changes(locations[key]))\n        # Change both children\n        child = self.store.get_item(locations['child'])\n        child_sibling = self.store.get_item(locations['child_sibling'])\n        child.display_name = 'Changed Display Name'\n        child_sibling.display_name = 'Changed Display Name'\n        self.store.update_item(child, user_id=self.user_id)\n        self.store.update_item(child_sibling, user_id=self.user_id)\n        # Verify that ancestors have changes\n        self.assertTrue(self._has_changes(locations['grandparent']))\n        self.assertTrue(self._has_changes(locations['parent']))\n        # Publish one child\n        self.store.publish(locations['child_sibling'], self.user_id)\n        # Verify that ancestors still have changes\n        self.assertTrue(self._has_changes(locations['grandparent']))\n        self.assertTrue(self._has_changes(locations['parent']))\n        # Publish the other child\n        self.store.publish(locations['child'], self.user_id)\n        # Verify that ancestors now have no changes\n        self.assertFalse(self._has_changes(locations['grandparent']))\n        self.assertFalse(self._has_changes(locations['parent']))\n    @ddt.data('draft', 'split')\n    def test_has_changes_add_remove_child(self, default_ms):\n        \"\"\"\n        Tests that has_changes() returns true for the parent when a child with changes is added\n        and false when that child is removed.\n        \"\"\"\n        locations = self.setup_has_changes(default_ms)\n        # Test that the ancestors don't have changes\n        self.assertFalse(self._has_changes(locations['grandparent']))\n        self.assertFalse(self._has_changes(locations['parent']))\n        # Create a new child and attach it to parent\n        self.store.create_child(\n            self.user_id,\n            locations['parent'],\n            'vertical',\n            block_id='new_child',\n        )\n        # Verify that the ancestors now have changes\n        self.assertTrue(self._has_changes(locations['grandparent']))\n        self.assertTrue(self._has_changes(locations['parent']))\n        # Remove the child from the parent\n        parent = self.store.get_item(locations['parent'])\n        parent.children = [locations['child'], locations['child_sibling']]\n        self.store.update_item(parent, user_id=self.user_id)\n        # Verify that ancestors now have no changes\n        self.assertFalse(self._has_changes(locations['grandparent']))\n        self.assertFalse(self._has_changes(locations['parent']))\n    @ddt.data('draft', 'split')\n    def test_has_changes_non_direct_only_children(self, default_ms):\n        \"\"\"\n        Tests that has_changes() returns true after editing the child of a vertical (both not direct only categories).\n        \"\"\"\n        self.initdb(default_ms)\n        parent = self.store.create_item(\n            self.user_id,\n            self.course.id,\n            'vertical',\n            block_id='parent',\n        )\n        child = self.store.create_child(\n            self.user_id,\n            parent.location,\n            'html',\n            block_id='child',\n        )\n        self.store.publish(parent.location, self.user_id)\n        # Verify that there are no changes\n        self.assertFalse(self._has_changes(parent.location))\n        self.assertFalse(self._has_changes(child.location))\n        # Change the child\n        child.display_name = 'Changed Display Name'\n        self.store.update_item(child, user_id=self.user_id)\n        # Verify that both parent and child have changes\n        self.assertTrue(self._has_changes(parent.location))\n        self.assertTrue(self._has_changes(child.location))\n    @ddt.data(*itertools.product(\n        ('draft', 'split'),\n        (ModuleStoreEnum.Branch.draft_preferred, ModuleStoreEnum.Branch.published_only)\n    ))\n    @ddt.unpack\n    def test_has_changes_missing_child(self, default_ms, default_branch):\n        \"\"\"\n        Tests that has_changes() does not throw an exception when a child doesn't exist.\n        \"\"\"\n        self.initdb(default_ms)\n        with self.store.branch_setting(default_branch, self.course.id):\n            # Create the parent and point it to a fake child\n            parent = self.store.create_item(\n                self.user_id,\n                self.course.id,\n                'vertical',\n                block_id='parent',\n            )\n            parent.children += [self.course.id.make_usage_key('vertical', 'does_not_exist')]\n            parent = self.store.update_item(parent, self.user_id)\n            # Check the parent for changes should return True and not throw an exception\n            self.assertTrue(self.store.has_changes(parent))\n    # Draft\n    #   Find: find parents (definition.children query), get parent, get course (fill in run?),\n    #         find parents of the parent (course), get inheritance items,\n    #         get item (to delete subtree), get inheritance again.\n    #   Sends: delete item, update parent\n    # Split\n    #   Find: active_versions, 2 structures (published & draft), definition (unnecessary)\n    #   Sends: updated draft and published structures and active_versions\n    @ddt.data(('draft', 7, 2), ('split', 4, 3))\n    @ddt.unpack\n    def test_delete_item(self, default_ms, max_find, max_send):\n        \"\"\"\n        Delete should reject on r/o db and work on r/w one\n        \"\"\"\n        self.initdb(default_ms)\n        if default_ms == 'draft' and mongo_uses_error_check(self.store):\n            max_find += 1\n        # r/o try deleting the chapter (is here to ensure it can't be deleted)\n        with self.assertRaises(NotImplementedError):\n            self.store.delete_item(self.xml_chapter_location, self.user_id)\n        with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, self.writable_chapter_location.course_key):\n            with check_mongo_calls(max_find, max_send):\n                self.store.delete_item(self.writable_chapter_location, self.user_id)\n            # verify it's gone\n            with self.assertRaises(ItemNotFoundError):\n                self.store.get_item(self.writable_chapter_location)\n        # verify it's gone from published too\n        with self.assertRaises(ItemNotFoundError):\n            self.store.get_item(self.writable_chapter_location, revision=ModuleStoreEnum.RevisionOption.published_only)\n    # Draft:\n    #    queries: find parent (definition.children), count versions of item, get parent, count grandparents,\n    #             inheritance items, draft item, draft child, inheritance\n    #    sends: delete draft vertical and update parent\n    # Split:\n    #    queries: active_versions, draft and published structures, definition (unnecessary)\n    #    sends: update published (why?), draft, and active_versions\n    @ddt.data(('draft', 9, 2), ('split', 2, 2))\n    @ddt.unpack\n    def test_delete_private_vertical(self, default_ms, max_find, max_send):\n        \"\"\"\n        Because old mongo treated verticals as the first layer which could be draft, it has some interesting\n        behavioral properties which this deletion test gets at.\n        \"\"\"\n        self.initdb(default_ms)\n        if default_ms == 'draft' and mongo_uses_error_check(self.store):\n            max_find += 1\n        # create and delete a private vertical with private children\n        private_vert = self.store.create_child(\n            # don't use course_location as it may not be the repr\n            self.user_id, self.course_locations[self.MONGO_COURSEID],\n            'vertical', block_id='private'\n        )\n        private_leaf = self.store.create_child(\n            # don't use course_location as it may not be the repr\n            self.user_id, private_vert.location, 'html', block_id='private_leaf'\n        )\n        # verify pre delete state (just to verify that the test is valid)\n        if hasattr(private_vert.location, 'version_guid'):\n            # change to the HEAD version\n            vert_loc = private_vert.location.for_version(private_leaf.location.version_guid)\n        else:\n            vert_loc = private_vert.location\n        self.assertTrue(self.store.has_item(vert_loc))\n        self.assertTrue(self.store.has_item(private_leaf.location))\n        course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key, 0)\n        self.assertIn(vert_loc, course.children)\n        # delete the vertical and ensure the course no longer points to it\n        with check_mongo_calls(max_find, max_send):\n            self.store.delete_item(vert_loc, self.user_id)\n        course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key, 0)\n        if hasattr(private_vert.location, 'version_guid'):\n            # change to the HEAD version\n            vert_loc = private_vert.location.for_version(course.location.version_guid)\n            leaf_loc = private_leaf.location.for_version(course.location.version_guid)\n        else:\n            vert_loc = private_vert.location\n            leaf_loc = private_leaf.location\n        self.assertFalse(self.store.has_item(vert_loc))\n        self.assertFalse(self.store.has_item(leaf_loc))\n        self.assertNotIn(vert_loc, course.children)\n    # Draft:\n    #   find: find parent (definition.children) 2x, find draft item, get inheritance items\n    #   send: one delete query for specific item\n    # Split:\n    #   find: active_version & structure (cached)\n    #   send: update structure and active_versions\n    @ddt.data(('draft', 4, 1), ('split', 2, 2))\n    @ddt.unpack\n    def test_delete_draft_vertical(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test deleting a draft vertical which has a published version.\n        \"\"\"\n        self.initdb(default_ms)\n        # reproduce bug STUD-1965\n        # create and delete a private vertical with private children\n        private_vert = self.store.create_child(\n            # don't use course_location as it may not be the repr\n            self.user_id, self.course_locations[self.MONGO_COURSEID], 'vertical', block_id='publish'\n        )\n        private_leaf = self.store.create_child(\n            self.user_id, private_vert.location, 'html', block_id='bug_leaf'\n        )\n        # verify that an error is raised when the revision is not valid\n        with self.assertRaises(UnsupportedRevisionError):\n            self.store.delete_item(\n                private_leaf.location,\n                self.user_id,\n                revision=ModuleStoreEnum.RevisionOption.draft_preferred\n            )\n        self.store.publish(private_vert.location, self.user_id)\n        private_leaf.display_name = 'change me'\n        private_leaf = self.store.update_item(private_leaf, self.user_id)\n        # test succeeds if delete succeeds w/o error\n        if default_ms == 'draft' and mongo_uses_error_check(self.store):\n            max_find += 1\n        with check_mongo_calls(max_find, max_send):\n            self.store.delete_item(private_leaf.location, self.user_id)\n    # Draft:\n    #   1) find all courses (wildcard),\n    #   2) get each course 1 at a time (1 course),\n    #   3) wildcard split if it has any (1) but it doesn't\n    # Split:\n    #   1) wildcard split search,\n    #   2-4) active_versions, structure, definition (s/b lazy; so, unnecessary)\n    #   5) wildcard draft mongo which has none\n    @ddt.data(('draft', 3, 0), ('split', 5, 0))\n    @ddt.unpack\n    def test_get_courses(self, default_ms, max_find, max_send):\n        self.initdb(default_ms)\n        # we should have 3 total courses across all stores\n        with check_mongo_calls(max_find, max_send):\n            courses = self.store.get_courses()\n            course_ids = [course.location for course in courses]\n            self.assertEqual(len(courses), 3, \"Not 3 courses: {}\".format(course_ids))\n            self.assertIn(self.course_locations[self.MONGO_COURSEID], course_ids)\n            self.assertIn(self.course_locations[self.XML_COURSEID1], course_ids)\n            self.assertIn(self.course_locations[self.XML_COURSEID2], course_ids)\n        with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred):\n            draft_courses = self.store.get_courses(remove_branch=True)\n        with self.store.branch_setting(ModuleStoreEnum.Branch.published_only):\n            published_courses = self.store.get_courses(remove_branch=True)\n        self.assertEquals([c.id for c in draft_courses], [c.id for c in published_courses])\n    @ddt.data('draft', 'split')\n    def test_create_child_detached_tabs(self, default_ms):\n        \"\"\"\n        test 'create_child' method with a detached category ('static_tab')\n        to check that new static tab is not a direct child of the course\n        \"\"\"\n        self.initdb(default_ms)\n        mongo_course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key)\n        self.assertEqual(len(mongo_course.children), 1)\n        # create a static tab of the course\n        self.store.create_child(\n            self.user_id,\n            self.course.location,\n            'static_tab'\n        )\n        # now check that the course has same number of children\n        mongo_course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key)\n        self.assertEqual(len(mongo_course.children), 1)\n    def test_xml_get_courses(self):\n        \"\"\"\n        Test that the xml modulestore only loaded the courses from the maps.\n        \"\"\"\n        self.initdb('draft')\n        xml_store = self.store._get_modulestore_by_type(ModuleStoreEnum.Type.xml)  # pylint: disable=protected-access\n        courses = xml_store.get_courses()\n        self.assertEqual(len(courses), 2)\n        course_ids = [course.id for course in courses]\n        self.assertIn(self.course_locations[self.XML_COURSEID1].course_key, course_ids)\n        self.assertIn(self.course_locations[self.XML_COURSEID2].course_key, course_ids)\n        # this course is in the directory from which we loaded courses but not in the map\n        self.assertNotIn(\"edX/toy/TT_2012_Fall\", course_ids)\n    def test_xml_no_write(self):\n        \"\"\"\n        Test that the xml modulestore doesn't allow write ops.\n        \"\"\"\n        self.initdb('draft')\n        xml_store = self.store._get_modulestore_by_type(ModuleStoreEnum.Type.xml)  # pylint: disable=protected-access\n        # the important thing is not which exception it raises but that it raises an exception\n        with self.assertRaises(AttributeError):\n            xml_store.create_course(\"org\", \"course\", \"run\", self.user_id)\n    # draft is 2: find out which ms owns course, get item\n    # split: active_versions, structure, definition (to load course wiki string)\n    @ddt.data(('draft', 2, 0), ('split', 3, 0))\n    @ddt.unpack\n    def test_get_course(self, default_ms, max_find, max_send):\n        \"\"\"\n        This test is here for the performance comparison not functionality. It tests the performance\n        of getting an item whose scope.content fields are looked at.\n        \"\"\"\n        self.initdb(default_ms)\n        with check_mongo_calls(max_find, max_send):\n            course = self.store.get_item(self.course_locations[self.MONGO_COURSEID])\n            self.assertEqual(course.id, self.course_locations[self.MONGO_COURSEID].course_key)\n        course = self.store.get_item(self.course_locations[self.XML_COURSEID1])\n        self.assertEqual(course.id, self.course_locations[self.XML_COURSEID1].course_key)\n    @ddt.data('draft', 'split')\n    def test_get_library(self, default_ms):\n        \"\"\"\n        Test that create_library and get_library work regardless of the default modulestore.\n        Other tests of MixedModulestore support are in test_libraries.py but this one must\n        be done here so we can test the configuration where Draft/old is the first modulestore.\n        \"\"\"\n        self.initdb(default_ms)\n        with self.store.default_store(ModuleStoreEnum.Type.split):  # The CMS also wraps create_library like this\n            library = self.store.create_library(\"org\", \"lib\", self.user_id, {\"display_name\": \"Test Library\"})\n        library_key = library.location.library_key\n        self.assertIsInstance(library_key, LibraryLocator)\n        # Now load with get_library and make sure it works:\n        library = self.store.get_library(library_key)\n        self.assertEqual(library.location.library_key, library_key)\n        # Clear the mappings so we can test get_library code path without mapping set:\n        self.store.mappings.clear()\n        library = self.store.get_library(library_key)\n        self.assertEqual(library.location.library_key, library_key)\n    # notice this doesn't test getting a public item via draft_preferred which draft would have 2 hits (split\n    # still only 2)\n    # Draft: get_parent\n    # Split: active_versions, structure\n    @ddt.data(('draft', 1, 0), ('split', 2, 0))\n    @ddt.unpack\n    def test_get_parent_locations(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test a simple get parent for a direct only category (i.e, always published)\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        with check_mongo_calls(max_find, max_send):\n            parent = self.store.get_parent_location(self.problem_x1a_1)\n            self.assertEqual(parent, self.vertical_x1a)\n        parent = self.store.get_parent_location(self.xml_chapter_location)\n        self.assertEqual(parent, self.course_locations[self.XML_COURSEID1])\n    def verify_get_parent_locations_results(self, expected_results):\n        \"\"\"\n        Verifies the results of calling get_parent_locations matches expected_results.\n        \"\"\"\n        for child_location, parent_location, revision in expected_results:\n            self.assertEqual(\n                parent_location,\n                self.store.get_parent_location(child_location, revision=revision)\n            )\n    @ddt.data('draft', 'split')\n    def test_get_parent_locations_moved_child(self, default_ms):\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        # publish the course\n        self.course = self.store.publish(self.course.location, self.user_id)\n        with self.store.bulk_operations(self.course.id):\n            # make drafts of verticals\n            self.store.convert_to_draft(self.vertical_x1a, self.user_id)\n            self.store.convert_to_draft(self.vertical_y1a, self.user_id)\n            # move child problem_x1a_1 to vertical_y1a\n            child_to_move_location = self.problem_x1a_1\n            new_parent_location = self.vertical_y1a\n            old_parent_location = self.vertical_x1a\n            with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred):\n                old_parent = self.store.get_item(child_to_move_location).get_parent()\n            self.assertEqual(old_parent_location, old_parent.location)\n            child_to_move_contextualized = child_to_move_location.map_into_course(old_parent.location.course_key)\n            old_parent.children.remove(child_to_move_contextualized)\n            self.store.update_item(old_parent, self.user_id)\n            new_parent = self.store.get_item(new_parent_location)\n            new_parent.children.append(child_to_move_location)\n            self.store.update_item(new_parent, self.user_id)\n            with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred):\n                self.assertEqual(new_parent_location, self.store.get_item(child_to_move_location).get_parent().location)\n            with self.store.branch_setting(ModuleStoreEnum.Branch.published_only):\n                self.assertEqual(old_parent_location, self.store.get_item(child_to_move_location).get_parent().location)\n            old_parent_published_location = old_parent_location.for_branch(ModuleStoreEnum.BranchName.published)\n            self.verify_get_parent_locations_results([\n                (child_to_move_location, new_parent_location, None),\n                (child_to_move_location, new_parent_location, ModuleStoreEnum.RevisionOption.draft_preferred),\n                (child_to_move_location, old_parent_published_location, ModuleStoreEnum.RevisionOption.published_only),\n            ])\n        # publish the course again\n        self.store.publish(self.course.location, self.user_id)\n        new_parent_published_location = new_parent_location.for_branch(ModuleStoreEnum.BranchName.published)\n        self.verify_get_parent_locations_results([\n            (child_to_move_location, new_parent_location, None),\n            (child_to_move_location, new_parent_location, ModuleStoreEnum.RevisionOption.draft_preferred),\n            (child_to_move_location, new_parent_published_location, ModuleStoreEnum.RevisionOption.published_only),\n        ])\n    @ddt.data('draft')\n    def test_get_parent_locations_deleted_child(self, default_ms):\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        # publish the course\n        self.store.publish(self.course.location, self.user_id)\n        # make draft of vertical\n        self.store.convert_to_draft(self.vertical_y1a, self.user_id)\n        # delete child problem_y1a_1\n        child_to_delete_location = self.problem_y1a_1\n        old_parent_location = self.vertical_y1a\n        self.store.delete_item(child_to_delete_location, self.user_id)\n        self.verify_get_parent_locations_results([\n            (child_to_delete_location, old_parent_location, None),\n            # Note: The following could be an unexpected result, but we want to avoid an extra database call\n            (child_to_delete_location, old_parent_location, ModuleStoreEnum.RevisionOption.draft_preferred),\n            (child_to_delete_location, old_parent_location, ModuleStoreEnum.RevisionOption.published_only),\n        ])\n        # publish the course again\n        self.store.publish(self.course.location, self.user_id)\n        self.verify_get_parent_locations_results([\n            (child_to_delete_location, None, None),\n            (child_to_delete_location, None, ModuleStoreEnum.RevisionOption.draft_preferred),\n            (child_to_delete_location, None, ModuleStoreEnum.RevisionOption.published_only),\n        ])\n    @ddt.data('draft')\n    def test_get_parent_location_draft(self, default_ms):\n        \"\"\"\n        Test that \"get_parent_location\" method returns first published parent\n        for a draft component, if it has many possible parents (including\n        draft parents).\n        \"\"\"\n        self.initdb(default_ms)\n        course_id = self.course_locations[self.MONGO_COURSEID].course_key\n        # create parented children\n        self._create_block_hierarchy()\n        self.store.publish(self.course.location, self.user_id)\n        mongo_store = self.store._get_modulestore_for_courselike(course_id)  # pylint: disable=protected-access\n        # add another parent (unit) \"vertical_x1b\" for problem \"problem_x1a_1\"\n        mongo_store.collection.update(\n            self.vertical_x1b.to_deprecated_son('_id.'),\n            {'$push': {'definition.children': unicode(self.problem_x1a_1)}}\n        )\n        # convert first parent (unit) \"vertical_x1a\" of problem \"problem_x1a_1\" to draft\n        self.store.convert_to_draft(self.vertical_x1a, self.user_id)\n        item = self.store.get_item(self.vertical_x1a)\n        self.assertTrue(self.store.has_published_version(item))\n        # now problem \"problem_x1a_1\" has 3 parents [vertical_x1a (draft),\n        # vertical_x1a (published), vertical_x1b (published)]\n        # check that \"get_parent_location\" method of draft branch returns first\n        # published parent \"vertical_x1a\" without raising \"AssertionError\" for\n        # problem location revision\n        with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course_id):\n            parent = mongo_store.get_parent_location(self.problem_x1a_1)\n            self.assertEqual(parent, self.vertical_x1a)\n    # Draft:\n    #   Problem path:\n    #    1. Get problem\n    #    2-6. get parent and rest of ancestors up to course\n    #    7-8. get sequential, compute inheritance\n    #    8-9. get vertical, compute inheritance\n    #    10-11. get other vertical_x1b (why?) and compute inheritance\n    # Split: active_versions & structure\n    @ddt.data(('draft', [12, 3], 0), ('split', [2, 2], 0))\n    @ddt.unpack\n    def test_path_to_location(self, default_ms, num_finds, num_sends):\n        \"\"\"\n        Make sure that path_to_location works\n        \"\"\"\n        self.initdb(default_ms)\n        course_key = self.course_locations[self.MONGO_COURSEID].course_key\n        with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_key):\n            self._create_block_hierarchy()\n            should_work = (\n                (self.problem_x1a_2,\n                 (course_key, u\"Chapter_x\", u\"Sequential_x1\", '1')),\n                (self.chapter_x,\n                 (course_key, \"Chapter_x\", None, None)),\n            )\n            for location, expected in should_work:\n                # each iteration has different find count, pop this iter's find count\n                with check_mongo_calls(num_finds.pop(0), num_sends):\n                    self.assertEqual(path_to_location(self.store, location), expected)\n        not_found = (\n            course_key.make_usage_key('video', 'WelcomeX'),\n            course_key.make_usage_key('course', 'NotHome'),\n        )\n        for location in not_found:\n            with self.assertRaises(ItemNotFoundError):\n                path_to_location(self.store, location)\n        # Orphaned items should not be found.\n        orphan = course_key.make_usage_key('chapter', 'OrphanChapter')\n        self.store.create_item(\n            self.user_id,\n            orphan.course_key,\n            orphan.block_type,\n            block_id=orphan.block_id\n        )\n        with self.assertRaises(NoPathToItem):\n            path_to_location(self.store, orphan)\n    def test_xml_path_to_location(self):\n        \"\"\"\n        Make sure that path_to_location works: should be passed a modulestore\n        with the toy and simple courses loaded.\n        \"\"\"\n        # only needs course_locations set\n        self.initdb('draft')\n        course_key = self.course_locations[self.XML_COURSEID1].course_key\n        should_work = (\n            (course_key.make_usage_key('video', 'Welcome'),\n             (course_key, \"Overview\", \"Welcome\", None)),\n            (course_key.make_usage_key('chapter', 'Overview'),\n             (course_key, \"Overview\", None, None)),\n        )\n        for location, expected in should_work:\n            self.assertEqual(path_to_location(self.store, location), expected)\n        not_found = (\n            course_key.make_usage_key('video', 'WelcomeX'),\n            course_key.make_usage_key('course', 'NotHome'),\n        )\n        for location in not_found:\n            with self.assertRaises(ItemNotFoundError):\n                path_to_location(self.store, location)\n    def test_navigation_index(self):\n        \"\"\"\n        Make sure that navigation_index correctly parses the various position values that we might get from calls to\n        path_to_location\n        \"\"\"\n        self.assertEqual(1, navigation_index(\"1\"))\n        self.assertEqual(10, navigation_index(\"10\"))\n        self.assertEqual(None, navigation_index(None))\n        self.assertEqual(1, navigation_index(\"1_2\"))\n        self.assertEqual(5, navigation_index(\"5_2\"))\n        self.assertEqual(7, navigation_index(\"7_3_5_6_\"))\n    @ddt.data('draft', 'split')\n    def test_revert_to_published_root_draft(self, default_ms):\n        \"\"\"\n        Test calling revert_to_published on draft vertical.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        vertical = self.store.get_item(self.vertical_x1a)\n        vertical_children_num = len(vertical.children)\n        self.store.publish(self.course.location, self.user_id)\n        self.assertFalse(self._has_changes(self.vertical_x1a))\n        # delete leaf problem (will make parent vertical a draft)\n        self.store.delete_item(self.problem_x1a_1, self.user_id)\n        self.assertTrue(self._has_changes(self.vertical_x1a))\n        draft_parent = self.store.get_item(self.vertical_x1a)\n        self.assertEqual(vertical_children_num - 1, len(draft_parent.children))\n        published_parent = self.store.get_item(\n            self.vertical_x1a,\n            revision=ModuleStoreEnum.RevisionOption.published_only\n        )\n        self.assertEqual(vertical_children_num, len(published_parent.children))\n        self.store.revert_to_published(self.vertical_x1a, self.user_id)\n        reverted_parent = self.store.get_item(self.vertical_x1a)\n        self.assertEqual(vertical_children_num, len(published_parent.children))\n        self.assertBlocksEqualByFields(reverted_parent, published_parent)\n        self.assertFalse(self._has_changes(self.vertical_x1a))\n    @ddt.data('draft', 'split')\n    def test_revert_to_published_root_published(self, default_ms):\n        \"\"\"\n        Test calling revert_to_published on a published vertical with a draft child.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        self.store.publish(self.course.location, self.user_id)\n        problem = self.store.get_item(self.problem_x1a_1)\n        orig_display_name = problem.display_name\n        # Change display name of problem and update just it (so parent remains published)\n        problem.display_name = \"updated before calling revert\"\n        self.store.update_item(problem, self.user_id)\n        self.store.revert_to_published(self.vertical_x1a, self.user_id)\n        reverted_problem = self.store.get_item(self.problem_x1a_1)\n        self.assertEqual(orig_display_name, reverted_problem.display_name)\n    @ddt.data('draft', 'split')\n    def test_revert_to_published_no_draft(self, default_ms):\n        \"\"\"\n        Test calling revert_to_published on vertical with no draft content does nothing.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        self.store.publish(self.course.location, self.user_id)\n        orig_vertical = self.store.get_item(self.vertical_x1a)\n        self.store.revert_to_published(self.vertical_x1a, self.user_id)\n        reverted_vertical = self.store.get_item(self.vertical_x1a)\n        self.assertBlocksEqualByFields(orig_vertical, reverted_vertical)\n    @ddt.data('draft', 'split')\n    def test_revert_to_published_no_published(self, default_ms):\n        \"\"\"\n        Test calling revert_to_published on vertical with no published version errors.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        with self.assertRaises(InvalidVersionError):\n            self.store.revert_to_published(self.vertical_x1a, self.user_id)\n    @ddt.data('draft', 'split')\n    def test_revert_to_published_direct_only(self, default_ms):\n        \"\"\"\n        Test calling revert_to_published on a direct-only item is a no-op.\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        num_children = len(self.store.get_item(self.sequential_x1).children)\n        self.store.revert_to_published(self.sequential_x1, self.user_id)\n        reverted_parent = self.store.get_item(self.sequential_x1)\n        # It does not discard the child vertical, even though that child is a draft (with no published version)\n        self.assertEqual(num_children, len(reverted_parent.children))\n    # Draft: get all items which can be or should have parents\n    # Split: active_versions, structure\n    @ddt.data(('draft', 1, 0), ('split', 2, 0))\n    @ddt.unpack\n    def test_get_orphans(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test finding orphans.\n        \"\"\"\n        self.initdb(default_ms)\n        course_id = self.course_locations[self.MONGO_COURSEID].course_key\n        # create parented children\n        self._create_block_hierarchy()\n        # orphans\n        orphan_locations = [\n            course_id.make_usage_key('chapter', 'OrphanChapter'),\n            course_id.make_usage_key('vertical', 'OrphanVertical'),\n            course_id.make_usage_key('problem', 'OrphanProblem'),\n            course_id.make_usage_key('html', 'OrphanHTML'),\n        ]\n        # detached items (not considered as orphans)\n        detached_locations = [\n            course_id.make_usage_key('static_tab', 'StaticTab'),\n            course_id.make_usage_key('course_info', 'updates'),\n        ]\n        for location in (orphan_locations + detached_locations):\n            self.store.create_item(\n                self.user_id,\n                location.course_key,\n                location.block_type,\n                block_id=location.block_id\n            )\n        with check_mongo_calls(max_find, max_send):\n            found_orphans = self.store.get_orphans(self.course_locations[self.MONGO_COURSEID].course_key)\n        self.assertItemsEqual(found_orphans, orphan_locations)\n    @ddt.data('draft')\n    def test_get_non_orphan_parents(self, default_ms):\n        \"\"\"\n        Test finding non orphan parents from many possible parents.\n        \"\"\"\n        self.initdb(default_ms)\n        course_id = self.course_locations[self.MONGO_COURSEID].course_key\n        # create parented children\n        self._create_block_hierarchy()\n        self.store.publish(self.course.location, self.user_id)\n        # test that problem \"problem_x1a_1\" has only one published parent\n        mongo_store = self.store._get_modulestore_for_courselike(course_id)  # pylint: disable=protected-access\n        with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_id):\n            parent = mongo_store.get_parent_location(self.problem_x1a_1)\n            self.assertEqual(parent, self.vertical_x1a)\n        # add some published orphans\n        orphan_sequential = course_id.make_usage_key('sequential', 'OrphanSequential')\n        orphan_vertical = course_id.make_usage_key('vertical', 'OrphanVertical')\n        orphan_locations = [orphan_sequential, orphan_vertical]\n        for location in orphan_locations:\n            self.store.create_item(\n                self.user_id,\n                location.course_key,\n                location.block_type,\n                block_id=location.block_id\n            )\n            self.store.publish(location, self.user_id)\n        found_orphans = mongo_store.get_orphans(course_id)\n        self.assertEqual(set(found_orphans), set(orphan_locations))\n        self.assertEqual(len(set(found_orphans)), 2)\n        # add orphan vertical and sequential as another parents of problem \"problem_x1a_1\"\n        mongo_store.collection.update(\n            orphan_sequential.to_deprecated_son('_id.'),\n            {'$push': {'definition.children': unicode(self.problem_x1a_1)}}\n        )\n        mongo_store.collection.update(\n            orphan_vertical.to_deprecated_son('_id.'),\n            {'$push': {'definition.children': unicode(self.problem_x1a_1)}}\n        )\n        # test that \"get_parent_location\" method of published branch still returns the correct non-orphan parent for\n        # problem \"problem_x1a_1\" since the two other parents are orphans\n        with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_id):\n            parent = mongo_store.get_parent_location(self.problem_x1a_1)\n            self.assertEqual(parent, self.vertical_x1a)\n        # now add valid published vertical as another parent of problem\n        mongo_store.collection.update(\n            self.sequential_x1.to_deprecated_son('_id.'),\n            {'$push': {'definition.children': unicode(self.problem_x1a_1)}}\n        )\n        # now check that \"get_parent_location\" method of published branch raises \"ReferentialIntegrityError\" for\n        # problem \"problem_x1a_1\" since it has now 2 valid published parents\n        with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_id):\n            self.assertTrue(self.store.has_item(self.problem_x1a_1))\n            with self.assertRaises(ReferentialIntegrityError):\n                self.store.get_parent_location(self.problem_x1a_1)\n    @ddt.data('draft')\n    def test_create_item_from_parent_location(self, default_ms):\n        \"\"\"\n        Test a code path missed by the above: passing an old-style location as parent but no\n        new location for the child\n        \"\"\"\n        self.initdb(default_ms)\n        self.store.create_child(\n            self.user_id,\n            self.course_locations[self.MONGO_COURSEID],\n            'problem',\n            block_id='orphan'\n        )\n        orphans = self.store.get_orphans(self.course_locations[self.MONGO_COURSEID].course_key)\n        self.assertEqual(len(orphans), 0, \"unexpected orphans: {}\".format(orphans))\n    @ddt.data('draft', 'split')\n    def test_create_item_populates_edited_info(self, default_ms):\n        self.initdb(default_ms)\n        block = self.store.create_item(\n            self.user_id,\n            self.course.location.course_key,\n            'problem'\n        )\n        self.assertEqual(self.user_id, block.edited_by)\n        self.assertGreater(datetime.datetime.now(UTC), block.edited_on)\n    @ddt.data('draft', 'split')\n    def test_create_item_populates_subtree_edited_info(self, default_ms):\n        self.initdb(default_ms)\n        block = self.store.create_item(\n            self.user_id,\n            self.course.location.course_key,\n            'problem'\n        )\n        self.assertEqual(self.user_id, block.subtree_edited_by)\n        self.assertGreater(datetime.datetime.now(UTC), block.subtree_edited_on)\n    # Draft: wildcard search of draft and split\n    # Split: wildcard search of draft and split\n    @ddt.data(('draft', 2, 0), ('split', 2, 0))\n    @ddt.unpack\n    def test_get_courses_for_wiki(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test the get_courses_for_wiki method\n        \"\"\"\n        self.initdb(default_ms)\n        # Test XML wikis\n        wiki_courses = self.store.get_courses_for_wiki('toy')\n        self.assertEqual(len(wiki_courses), 1)\n        self.assertIn(self.course_locations[self.XML_COURSEID1].course_key, wiki_courses)\n        wiki_courses = self.store.get_courses_for_wiki('simple')\n        self.assertEqual(len(wiki_courses), 1)\n        self.assertIn(self.course_locations[self.XML_COURSEID2].course_key, wiki_courses)\n        # Test Mongo wiki\n        with check_mongo_calls(max_find, max_send):\n            wiki_courses = self.store.get_courses_for_wiki('999')\n        self.assertEqual(len(wiki_courses), 1)\n        self.assertIn(\n            self.course_locations[self.MONGO_COURSEID].course_key.replace(branch=None),  # Branch agnostic\n            wiki_courses\n        )\n        self.assertEqual(len(self.store.get_courses_for_wiki('edX.simple.2012_Fall')), 0)\n        self.assertEqual(len(self.store.get_courses_for_wiki('no_such_wiki')), 0)\n    # Draft:\n    #    Find: find vertical, find children\n    #    Sends:\n    #      1. delete all of the published nodes in subtree\n    #      2. insert vertical as published (deleted in step 1) w/ the deleted problems as children\n    #      3-6. insert the 3 problems and 1 html as published\n    # Split: active_versions, 2 structures (pre & post published?)\n    # Sends:\n    #    - insert structure\n    #    - write index entry\n    @ddt.data(('draft', 2, 6), ('split', 3, 2))\n    @ddt.unpack\n    def test_unpublish(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test calling unpublish\n        \"\"\"\n        self.initdb(default_ms)\n        if default_ms == 'draft' and mongo_uses_error_check(self.store):\n            max_find += 1\n        self._create_block_hierarchy()\n        # publish\n        self.store.publish(self.course.location, self.user_id)\n        published_xblock = self.store.get_item(\n            self.vertical_x1a,\n            revision=ModuleStoreEnum.RevisionOption.published_only\n        )\n        self.assertIsNotNone(published_xblock)\n        # unpublish\n        with check_mongo_calls(max_find, max_send):\n            self.store.unpublish(self.vertical_x1a, self.user_id)\n        with self.assertRaises(ItemNotFoundError):\n            self.store.get_item(\n                self.vertical_x1a,\n                revision=ModuleStoreEnum.RevisionOption.published_only\n            )\n        # make sure draft version still exists\n        draft_xblock = self.store.get_item(\n            self.vertical_x1a,\n            revision=ModuleStoreEnum.RevisionOption.draft_only\n        )\n        self.assertIsNotNone(draft_xblock)\n    # Draft: specific query for revision None\n    # Split: active_versions, structure\n    @ddt.data(('draft', 1, 0), ('split', 2, 0))\n    @ddt.unpack\n    def test_has_published_version(self, default_ms, max_find, max_send):\n        \"\"\"\n        Test the has_published_version method\n        \"\"\"\n        self.initdb(default_ms)\n        self._create_block_hierarchy()\n        # start off as Private\n        item = self.store.create_child(self.user_id, self.writable_chapter_location, 'problem', 'test_compute_publish_state')\n        item_location = item.location\n        with check_mongo_calls(max_find, max_send):\n            self.assertFalse(self.store.has_published_version(item))\n        # Private -> Public\n        self.store.publish(item_location, self.user_id)\n        item = self.store.get_item(item_location)\n        self.assertTrue(self.store.has_published_version(item))\n        # Public -> Private\n        self.store.unpublish(item_location, self.user_id)\n        item = self.store.get_item(item_location)\n        self.assertFalse(self.store.has_published_version(item))\n        # Private -> Public\n        self.store.publish(item_location, self.user_id)\n        item = self.store.get_item(item_location)\n        self.assertTrue(self.store.has_published_version(item))\n        # Public -> Draft with NO changes\n        self.store.convert_to_draft(item_location, self.user_id)\n        item = self.store.get_item(item_location)\n        self.assertTrue(self.store.has_published_version(item))\n        # Draft WITH changes\n        item.display_name = 'new name'\n        item = self.store.update_item(item, self.user_id)\n        self.assertTrue(self.store.has_changes(item))\n        self.assertTrue(self.store.has_published_version(item))\n    @ddt.data('draft', 'split')\n    def test_update_edit_info_ancestors(self, default_ms):\n        \"\"\"\n        Tests that edited_on, edited_by, subtree_edited_on, and subtree_edited_by are set correctly during update\n        \"\"\"\n        self.initdb(default_ms)\n        test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id)\n        def check_node(location_key, after, before, edited_by, subtree_after, subtree_before, subtree_by):\n            \"\"\"\n            Checks that the node given by location_key matches the given edit_info constraints.\n            \"\"\"\n            node = self.store.get_item(location_key)\n            if after:\n                self.assertLess(after, node.edited_on)\n            self.assertLess(node.edited_on, before)\n            self.assertEqual(node.edited_by, edited_by)\n            if subtree_after:\n                self.assertLess(subtree_after, node.subtree_edited_on)\n            self.assertLess(node.subtree_edited_on, subtree_before)\n            self.assertEqual(node.subtree_edited_by, subtree_by)\n        with self.store.bulk_operations(test_course.id):\n            # Create a dummy vertical & html to test against\n            component = self.store.create_child(\n                self.user_id,\n                test_course.location,\n                'vertical',\n                block_id='test_vertical'\n            )\n            child = self.store.create_child(\n                self.user_id,\n                component.location,\n                'html',\n                block_id='test_html'\n            )\n            sibling = self.store.create_child(\n                self.user_id,\n                component.location,\n                'html',\n                block_id='test_html_no_change'\n            )\n        after_create = datetime.datetime.now(UTC)\n        # Verify that all nodes were last edited in the past by create_user\n        for block in [component, child, sibling]:\n            check_node(block.location, None, after_create, self.user_id, None, after_create, self.user_id)\n        # Change the component, then check that there now are changes\n        component.display_name = 'Changed Display Name'\n        editing_user = self.user_id - 2\n        with self.store.bulk_operations(test_course.id):  # TNL-764 bulk ops disabled ancestor updates\nNext line of code:\n",
        "prediction": "           self.store.update_item(component, editing_user)\n        after_update = datetime.datetime.now(UTC)\n        # Verify that all nodes were last edited in the past by create_user\n        for block in [component, child, sibling]:\n            check_",
        "gold": [
            "            component = self.store.update_item(component, editing_user)"
        ],
        "time": 3.3673770427703857
    },
    "21": {
        "origin_prompt": "Please complete the code given below. \n/*---------------------------------------------------------------------------*\\\n    Compiler Generator Coco/R,\n    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz\n    extended by M. Loeberbauer & A. Woess, Univ. of Linz\n    with improvements by Pat Terry, Rhodes University\n-------------------------------------------------------------------------------\nLicense\n    This file is part of Compiler Generator Coco/R\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by the\n    Free Software Foundation; either version 2, or (at your option) any\n    later version.\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    As an exception, it is allowed to write an extension of Coco/R that is\n    used as a plugin in non-free software.\n    If not otherwise stated, any source code generated by Coco/R (other than\n    Coco/R itself) does not fall under the GNU General Public License.\n\\*---------------------------------------------------------------------------*/\n// This file was generated with Coco/R C#, version: 20101106\nusing System.IO;\nusing System;\nnamespace at.jku.ssw.Coco {\n// ----------------------------------------------------------------------------\n// Parser\n// ----------------------------------------------------------------------------\n//! A Coco/R Parser\npublic class Parser\n{\n\tpublic const int _EOF = 0;\n\tpublic const int _ident = 1;\n\tpublic const int _number = 2;\n\tpublic const int _string = 3;\n\tpublic const int _badString = 4;\n\tpublic const int _char = 5;\n\tpublic const int maxT = 43;  //<! max term (w/o pragmas)\n\tpublic const int _ddtSym = 44;\n\tpublic const int _directive = 45;\n\tconst bool T = true;\n\tconst bool x = false;\n\tconst int minErrDist = 2;\n\tpublic Scanner scanner;\n\tpublic Errors  errors;\n\tpublic Token t;    //!< last recognized token\n\tpublic Token la;   //!< lookahead token\n\tint errDist = minErrDist;\nconst int isIdent   = 0;\n\tconst int isLiteral = 1;\n\tpublic Tab tab;             // other Coco objects referenced in this ATG\n\tpublic DFA dfa;\n\tpublic ParserGen pgen;\n\tbool   genScanner = false;\n\tstring tokenString;         // used in declarations of literal tokens\n\tstring noString = \"-none-\"; // used in declarations of literal tokens\n/*-------------------------------------------------------------------------*/\n\tpublic Parser(Scanner scanner) {\n\t\tthis.scanner = scanner;\n\t\terrors = new Errors();\n\t}\n\tvoid SynErr (int n) {\n\t\tif (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);\n\t\terrDist = 0;\n\t}\n\tpublic void SemErr (string msg) {\n\t\tif (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);\n\t\terrDist = 0;\n\t}\n\tvoid Get () {\n\t\tfor (;;) {\n\t\t\tt = la;\n\t\t\tla = scanner.Scan();\n\t\t\tif (la.kind <= maxT) { ++errDist; break; }\n\t\t\t\tif (la.kind == 44) {\n\t\t\t\ttab.SetDDT(la.val);\n\t\t\t\t}\n\t\t\t\tif (la.kind == 45) {\n\t\t\t\ttab.DispatchDirective(la.val);\n\t\t\t\t}\n\t\t\tla = t;\n\t\t}\n\t}\n\tvoid Expect (int n) {\n\t\tif (la.kind==n) Get(); else { SynErr(n); }\n\t}\n\tbool StartOf (int s) {\n\t\treturn set[s, la.kind];\n\t}\n\tvoid ExpectWeak (int n, int follow) {\n\t\tif (la.kind == n) Get();\n\t\telse {\n\t\t\tSynErr(n);\n\t\t\twhile (!StartOf(follow)) Get();\n\t\t}\n\t}\n\tbool WeakSeparator(int n, int syFol, int repFol) {\n\t\tint kind = la.kind;\n\t\tif (kind == n) {Get(); return true;}\n\t\telse if (StartOf(repFol)) {return false;}\n\t\telse {\n\t\t\tSynErr(n);\n\t\t\twhile (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {\n\t\t\t\tGet();\n\t\t\t\tkind = la.kind;\n\t\t\t}\n\t\t\treturn StartOf(syFol);\n\t\t}\n\t}\n\tvoid Coco() {\n\t\tSymbol sym; Graph g; string grammarName; CharSet s;\n\t\tif (la.kind == 6) {\n\t\t\tGet();\n\t\t\tint beg = t.pos + t.val.Length;\n\t\t\twhile (StartOf(1)) {\n\t\t\t\tGet();\n\t\t\t}\n\t\t\ttab.copyPos = new Position(beg, la.pos, 0);\n\t\t\tExpect(7);\n\t\t}\n\t\tif (StartOf(2)) {\n\t\t\tGet();\n\t\t\tint beg = t.pos;\n\t\t\twhile (StartOf(3)) {\n\t\t\t\tGet();\n\t\t\t}\n\t\t\tpgen.preamblePos = new Position(beg, la.pos, 0);\n\t\t}\n\t\tExpect(8);\n\t\tgenScanner = true;\n\t\tExpect(1);\n\t\tgrammarName = t.val;\n\t\tif (StartOf(4)) {\n\t\t\tGet();\n\t\t\tint beg = t.pos;\n\t\t\twhile (StartOf(4)) {\n\t\t\t\tGet();\n\t\t\t}\n\t\t\tpgen.semDeclPos = new Position(beg, la.pos, 0);\n\t\t}\n\t\tif (la.kind == 9) {\n\t\t\tGet();\n\t\t\tdfa.ignoreCase = true;\n\t\t}\n\t\tif (la.kind == 10) {\n\t\t\tGet();\n\t\t\twhile (la.kind == 1) {\n\t\t\t\tSetDecl();\n\t\t\t}\n\t\t}\n\t\tif (la.kind == 11) {\n\t\t\tGet();\n\t\t\twhile (la.kind == 1 || la.kind == 3 || la.kind == 5) {\n\t\t\t\tTokenDecl(Node.t);\n\t\t\t}\n\t\t}\n\t\tif (la.kind == 12) {\n\t\t\tGet();\n\t\t\twhile (la.kind == 1 || la.kind == 3 || la.kind == 5) {\n\t\t\t\tTokenDecl(Node.pr);\n\t\t\t}\n\t\t}\n\t\twhile (la.kind == 13) {\n\t\t\tGet();\n\t\t\tGraph g1, g2; bool nested = false;\n\t\t\tExpect(14);\n\t\t\tTokenExpr(out g1);\n\t\t\tExpect(15);\n\t\t\tTokenExpr(out g2);\n\t\t\tif (la.kind == 16) {\n\t\t\t\tGet();\n\t\t\t\tnested = true;\n\t\t\t}\n\t\t\tdfa.NewComment(g1.l, g2.l, nested);\n\t\t}\n\t\twhile (la.kind == 17) {\n\t\t\tGet();\n\t\t\tSet(out s);\n\t\t\ttab.ignored.Or(s);\n\t\t}\n\t\twhile (!(la.kind == 0 || la.kind == 18)) {SynErr(44); Get();}\n\t\tExpect(18);\n\t\tif (genScanner) dfa.MakeDeterministic();\n\t\ttab.DeleteNodes();\n\t\twhile (la.kind == 1) {\n\t\t\tGet();\n\t\t\tsym = tab.FindSym(t.val);\n\t\t\tbool undef = (sym == null);\n\t\t\tif (undef) sym = tab.NewSym(Node.nt, t.val, t.line);\n\t\t\telse {\n\t\t\t  if (sym.typ == Node.nt) {\n\t\t\t    if (sym.graph != null)\n\t\t\t      SemErr(\"name declared twice\");\n\t\t\t  } else SemErr(\"this symbol kind not allowed on left side of production\");\n\t\t\t  sym.line = t.line;\n\t\t\t}\n\t\t\tbool noAttrs = (sym.attrPos == null);\n\t\t\tsym.attrPos = null;\n\t\t\tif (la.kind == 26 || la.kind == 28) {\n\t\t\t\tAttrDecl(sym);\n\t\t\t}\n\t\t\tif (!undef && noAttrs != (sym.attrPos == null))\n\t\t\t SemErr(\"attribute mismatch between declaration and use of this symbol\");\n\t\t\tif (la.kind == 41) {\n\t\t\t\tSemText(out sym.semPos);\n\t\t\t}\n\t\t\tExpectWeak(19, 5);\n\t\t\tExpression(out g);\n\t\t\tsym.graph = g.l;\n\t\t\ttab.Finish(g);\n\t\t\tExpectWeak(20, 6);\n\t\t}\n\t\tExpect(21);\n\t\tExpect(1);\n\t\tif (grammarName != t.val)\n\t\t SemErr(\"name does not match grammar name\");\n\t\ttab.gramSy = tab.FindSym(grammarName);\n\t\tif (tab.gramSy == null)\n\t\t  SemErr(\"missing production for grammar name\");\n\t\telse {\n\t\t  sym = tab.gramSy;\n\t\t  if (sym.attrPos != null)\n\t\t    SemErr(\"grammar symbol must not have attributes\");\n\t\t}\n\t\ttab.noSym = tab.NewSym(Node.t, \"???\", 0); // noSym gets highest number\n\t\ttab.SetupAnys();\n\t\ttab.RenumberPragmas();\n\t\tif (tab.ddt[2]) tab.PrintNodes();\n\t\tif (errors.count == 0) {\n\t\t  Console.WriteLine(\"checking\");\n\t\t  tab.CompSymbolSets();\n\t\t  if (tab.ddt[7]) tab.XRef();\n\t\t  if (tab.GrammarOk()) {\n\t\t    Console.Write(\"parser\");\n\t\t    pgen.WriteParser();\n\t\t    if (genScanner) {\n\t\t      Console.Write(\" + scanner\");\n\t\t      dfa.WriteScanner();\n\t\t      if (tab.ddt[0]) dfa.PrintStates();\n\t\t    }\n\t\t    Console.WriteLine(\" generated\");\n\t\t    if (tab.ddt[8]) {\n\t\t      tab.PrintStatistics();\n\t\t      pgen.PrintStatistics();\n\t\t    }\n\t\t  }\n\t\t}\n\t\tif (tab.ddt[6]) tab.PrintSymbolTable();\n\t\tExpect(20);\n\t}\n\tvoid SetDecl() {\n\t\tCharSet s;\n\t\tExpect(1);\n\t\tstring name = t.val;\n\t\tCharClass c = tab.FindCharClass(name);\n\t\tif (c != null) SemErr(\"name declared twice\");\n\t\tExpect(19);\n\t\tSet(out s);\n\t\tif (s.Elements() == 0) SemErr(\"character set must not be empty\");\n\t\ttab.NewCharClass(name, s);\n\t\tExpect(20);\n\t}\n\tvoid TokenDecl(int typ) {\n\t\tstring name; int kind; Symbol sym; Graph g;\n\t\tSym(out name, out kind);\n\t\tsym = tab.FindSym(name);\n\t\tif (sym != null) SemErr(\"name declared twice\");\n\t\telse {\n\t\t  sym = tab.NewSym(typ, name, t.line);\n\t\t  sym.tokenKind = Symbol.fixedToken;\n\t\t}\n\t\ttokenString = null;\n\t\twhile (!(StartOf(7))) {SynErr(45); Get();}\n\t\tif (la.kind == 19) {\n\t\t\tGet();\n\t\t\tTokenExpr(out g);\n\t\t\tExpect(20);\n\t\t\tif (kind == isLiteral) SemErr(\"a literal must not be declared with a structure\");\n\t\t\ttab.Finish(g);\n\t\t\tif (tokenString == null || tokenString.Equals(noString))\n\t\t\t  dfa.ConvertToStates(g.l, sym);\n\t\t\telse { // TokenExpr is a single string\n\t\t\t  if (tab.literals[tokenString] != null)\n\t\t\t    SemErr(\"token string declared twice\");\n\t\t\t  tab.literals[tokenString] = sym;\n\t\t\t  dfa.MatchLiteral(tokenString, sym);\n\t\t\t}\n\t\t} else if (StartOf(8)) {\n\t\t\tif (kind == isIdent) genScanner = false;\n\t\t\telse dfa.MatchLiteral(sym.name, sym);\n\t\t} else SynErr(46);\n\t\tif (la.kind == 41) {\n\t\t\tSemText(out sym.semPos);\n\t\t\tif (typ != Node.pr) SemErr(\"semantic action not allowed here\");\n\t\t}\n\t}\n\tvoid TokenExpr(out Graph g) {\n\t\tGraph g2;\n\t\tTokenTerm(out g);\n\t\tbool first = true;\n\t\twhile (WeakSeparator(30,9,10) ) {\n\t\t\tTokenTerm(out g2);\n\t\t\tif (first) { tab.MakeFirstAlt(g); first = false; }\n\t\t\ttab.MakeAlternative(g, g2);\n\t\t}\n\t}\n\tvoid Set(out CharSet s) {\n\t\tCharSet s2;\n\t\tSimSet(out s);\n\t\twhile (la.kind == 22 || la.kind == 23) {\n\t\t\tif (la.kind == 22) {\n\t\t\t\tGet();\n\t\t\t\tSimSet(out s2);\n\t\t\t\ts.Or(s2);\n\t\t\t} else {\n\t\t\t\tGet();\n\t\t\t\tSimSet(out s2);\n\t\t\t\ts.Subtract(s2);\n\t\t\t}\n\t\t}\n\t}\n\tvoid AttrDecl(Symbol sym) {\n\t\tif (la.kind == 26) {\n\t\t\tGet();\n\t\t\tint beg = la.pos; int col = la.col;\n\t\t\twhile (StartOf(11)) {\n\t\t\t\tif (StartOf(12)) {\n\t\t\t\t\tGet();\n\t\t\t\t} else {\n\t\t\t\t\tGet();\n\t\t\t\t\tSemErr(\"bad string in attributes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tExpect(27);\n\t\t\tif (t.pos > beg)\n\t\t\t sym.attrPos = new Position(beg, t.pos, col);\n\t\t} else if (la.kind == 28) {\n\t\t\tGet();\nNext line of code:\n",
        "prediction": "\t\t\tif (la.kind == 26) {\n\t\t\t\tGet();\n\t\t\t\tint beg = la.pos; int col = la.col;\n\t\t\t\twhile (StartOf(11)) {\n\t\t\t\t\tif (StartOf",
        "gold": [
            "\t\t\tint beg = la.pos; int col = la.col;"
        ],
        "time": 3.366798162460327
    },
    "22": {
        "origin_prompt": "Please complete the code given below. \nusing System;\nusing System.Collections.Generic;\nusing Server.Targeting;\nusing Server.Engines.Craft;\nnamespace Server.Items\n{\n    public class KeyRing : Item, IResource, IQuality\n    {\n        private CraftResource _Resource;\n        private Mobile _Crafter;\n        private ItemQuality _Quality;\n        [CommandProperty(AccessLevel.GameMaster)]\n        public CraftResource Resource { get { return _Resource; } set { _Resource = value; _Resource = value; Hue = CraftResources.GetHue(_Resource); InvalidateProperties(); } }\n        [CommandProperty(AccessLevel.GameMaster)]\n        public Mobile Crafter { get { return _Crafter; } set { _Crafter = value; InvalidateProperties(); } }\n        [CommandProperty(AccessLevel.GameMaster)]\n        public ItemQuality Quality { get { return _Quality; } set { _Quality = value; InvalidateProperties(); } }\n        public bool PlayerConstructed { get { return true; } }\n        public static readonly int MaxKeys = 20;\n        private List<Key> m_Keys;\n        [Constructable]\n        public KeyRing()\n            : base(0x1011)\n        {\n            Weight = 1.0; // They seem to have no weight on OSI ?!\n            m_Keys = new List<Key>();\n        }\n        public KeyRing(Serial serial)\n            : base(serial)\n        {\n        }\n        public List<Key> Keys\n        {\n            get\n            {\n                return m_Keys;\n            }\n        }\n        public override bool OnDragDrop(Mobile from, Item dropped)\n        {\n            if (!IsChildOf(from.Backpack))\n            {\n                from.SendLocalizedMessage(1060640); // The item must be in your backpack to use it.\n                return false;\n            }\n            Key key = dropped as Key;\n            if (key == null || key.KeyValue == 0)\n            {\n                from.SendLocalizedMessage(501689); // Only non-blank keys can be put on a keyring.\n                return false;\n            }\n            else if (Keys.Count >= MaxKeys)\n            {\n                from.SendLocalizedMessage(1008138); // This keyring is full.\n                return false;\n            }\n            else\n            {\n                Add(key);\n                from.SendLocalizedMessage(501691); // You put the key on the keyring.\n                return true;\n            }\n        }\n        public override void OnDoubleClick(Mobile from)\n        {\n            if (!IsChildOf(from.Backpack))\n            {\n                from.SendLocalizedMessage(1060640); // The item must be in your backpack to use it.\n                return;\n            }\n            from.SendLocalizedMessage(501680); // What do you want to unlock?\n            from.Target = new InternalTarget(this);\n        }\n        public override void OnDelete()\n        {\n            base.OnDelete();\n            foreach (Key key in m_Keys)\n            {\n                key.Delete();\n            }\n            m_Keys.Clear();\n        }\n        public void Add(Key key)\n        {\n            key.Internalize();\n            m_Keys.Add(key);\n            UpdateItemID();\n        }\n        public void Open(Mobile from)\n        {\n            Container cont = Parent as Container;\n            if (cont == null)\n                return;\n            for (int i = m_Keys.Count - 1; i >= 0; i--)\n            {\n                Key key = m_Keys[i];\n                if (!key.Deleted && !cont.TryDropItem(from, key, true))\n                    break;\n                m_Keys.RemoveAt(i);\n            }\n            UpdateItemID();\n        }\n        public void RemoveKeys(uint keyValue)\n        {\n            for (int i = m_Keys.Count - 1; i >= 0; i--)\n            {\n                Key key = m_Keys[i];\n                if (key.KeyValue == keyValue)\n                {\n                    key.Delete();\n                    m_Keys.RemoveAt(i);\n                }\n            }\n            UpdateItemID();\n        }\n        public bool ContainsKey(uint keyValue)\n        {\n            foreach (Key key in m_Keys)\n            {\n                if (key.KeyValue == keyValue)\n                    return true;\n            }\n            return false;\n        }\n        public override void AddCraftedProperties(ObjectPropertyList list)\n        {\n            if (_Crafter != null)\n            {\n                list.Add(1050043, _Crafter.TitleName); // crafted by ~1_NAME~\n            }\n            if (_Quality == ItemQuality.Exceptional)\n            {\n                list.Add(1060636); // Exceptional\n            }\n        }\n        public override void AddNameProperty(ObjectPropertyList list)\n        {\n            if (_Resource > CraftResource.Iron)\n            {\n                list.Add(1053099, \"#{0}\\t{1}\", CraftResources.GetLocalizationNumber(_Resource), String.Format(\"#{0}\", LabelNumber.ToString())); // ~1_oretype~ ~2_armortype~\n            }\n            else\n            {\n                base.AddNameProperty(list);\n            }\n        }\n        public virtual int OnCraft(int quality, bool makersMark, Mobile from, CraftSystem craftSystem, Type typeRes, ITool tool, CraftItem craftItem, int resHue)\n        {\n            Quality = (ItemQuality)quality;\n            if (makersMark)\n                Crafter = from;\n            if (!craftItem.ForceNonExceptional)\n            {\n                if (typeRes == null)\n                    typeRes = craftItem.Resources.GetAt(0).ItemType;\n                Resource = CraftResources.GetFromType(typeRes);\n            }\n            return quality;\n        }\n        public override void Serialize(GenericWriter writer)\n        {\n            base.Serialize(writer);\n            writer.WriteEncodedInt(1); // version\n            writer.Write((int)_Resource);\n            writer.Write(_Crafter);\n            writer.Write((int)_Quality);\n            writer.WriteItemList<Key>(m_Keys);\n        }\n        public override void Deserialize(GenericReader reader)\n        {\n            base.Deserialize(reader);\n            int version = reader.ReadEncodedInt();\n            switch (version)\n            {\n                case 1:\n                    _Resource = (CraftResource)reader.ReadInt();\n                    _Crafter = reader.ReadMobile();\n                    _Quality = (ItemQuality)reader.ReadInt();\n                    goto case 0;\n                case 0:\n                    m_Keys = reader.ReadStrongItemList<Key>();\n                    break;\n            }\n        }\n        private void UpdateItemID()\n        {\nNext line of code:\n",
        "prediction": "           if (m_Keys != null)\n            {\n                m_Keys.ForEach(key => key.UpdateItemID());\n            }\n        }\n    }\n}\n",
        "gold": [
            "            if (Keys.Count < 1)"
        ],
        "time": 2.4116733074188232
    },
    "23": {
        "origin_prompt": "Please complete the code given below. \npackage com.bkoneti.fileManager.controller;\nimport android.app.Activity;\nimport android.app.DialogFragment;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.util.SparseBooleanArray;\nimport android.view.ActionMode;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.AbsListView;\nimport android.widget.AbsListView.MultiChoiceModeListener;\nimport com.bkoneti.fileManager.BrowserActivity;\nimport com.bkoneti.fileManager.R;\nimport com.bkoneti.fileManager.SearchActivity;\nimport com.bkoneti.fileManager.adapters.BookmarksAdapter;\nimport com.bkoneti.fileManager.dialogs.DeleteFilesDialog;\nimport com.bkoneti.fileManager.dialogs.FilePropertiesDialog;\nimport com.bkoneti.fileManager.dialogs.GroupOwnerDialog;\nimport com.bkoneti.fileManager.dialogs.RenameDialog;\nimport com.bkoneti.fileManager.dialogs.ZipFilesDialog;\nimport com.bkoneti.fileManager.settings.Settings;\nimport com.bkoneti.fileManager.utils.ClipBoard;\nimport com.bkoneti.fileManager.utils.SimpleUtils;\nimport java.io.File;\nimport java.util.ArrayList;\npublic final class ActionModeController {\n    private final MultiChoiceModeListener multiChoiceListener;\n    private final Activity mActivity;\n    private AbsListView mListView;\n    private ActionMode mActionMode;\n    public ActionModeController(final Activity activity) {\n        this.mActivity = activity;\n        this.multiChoiceListener = new MultiChoiceListener();\n    }\n    public void finishActionMode() {\n        if (this.mActionMode != null) {\n            this.mActionMode.finish();\n        }\n    }\n    public void setListView(AbsListView list) {\n        if (this.mActionMode != null) {\n            this.mActionMode.finish();\n        }\n        this.mListView = list;\n        this.mListView.setMultiChoiceModeListener(this.multiChoiceListener);\n    }\n    public boolean isActionMode() {\n        return mActionMode != null;\n    }\n    private final class MultiChoiceListener implements MultiChoiceModeListener {\n        final String mSelected = mActivity.getString(R.string._selected);\n        @Override\n        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n            menu.clear();\n            mActivity.getMenuInflater().inflate(R.menu.actionmode, menu);\n            if (mActivity instanceof SearchActivity) {\n                    menu.removeItem(R.id.actiongroupowner);\n                    menu.removeItem(R.id.actionrename);\n                    menu.removeItem(R.id.actionzip);\n                if (mListView.getCheckedItemCount() > 1) {\n                    menu.removeItem(R.id.actiondetails);\n                }\n            } else {\n                if (!Settings.rootAccess())\n                    menu.removeItem(R.id.actiongroupowner);\n                if (mListView.getCheckedItemCount() > 1) {\n                    menu.removeItem(R.id.actionrename);\n                    menu.removeItem(R.id.actiongroupowner);\n                    menu.removeItem(R.id.actiondetails);\n                }\n            }\n            return true;\n        }\n        @Override\n        public void onDestroyActionMode(ActionMode mode) {\n            ActionModeController.this.mActionMode = null;\n        }\n        @Override\n        public boolean onCreateActionMode(ActionMode mode, Menu menu) {\n            ActionModeController.this.mActionMode = mode;\n            return true;\n        }\n        @Override\n        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n            final SparseBooleanArray items = mListView.getCheckedItemPositions();\n            final int checkedItemSize = items.size();\n            final String[] files = new String[mListView.getCheckedItemCount()];\n            int index = -1;\n            switch (item.getItemId()) {\n                case R.id.actionmove:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    ClipBoard.cutMove(files);\n                    mode.finish();\n                    mActivity.invalidateOptionsMenu();\n                    return true;\n                case R.id.actioncopy:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    ClipBoard.cutCopy(files);\n                    mode.finish();\n                    mActivity.invalidateOptionsMenu();\n                    return true;\n                case R.id.actiongroupowner:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            final DialogFragment dialog9 = GroupOwnerDialog\n                                    .instantiate(new File((String) mListView\n                                            .getItemAtPosition(key)));\n                            mode.finish();\n                            dialog9.show(mActivity.getFragmentManager(), BrowserActivity.TAG_DIALOG);\n                            break;\n                        }\n                    }\n                    return true;\n                case R.id.actiondelete:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    final DialogFragment dialog1 = DeleteFilesDialog.instantiate(files);\n                    mode.finish();\n                    dialog1.show(mActivity.getFragmentManager(), BrowserActivity.TAG_DIALOG);\n                    return true;\n                case R.id.actionshare:\n                    final ArrayList<Uri> uris = new ArrayList<>(mListView.getCheckedItemCount());\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            final File selected = new File((String) mListView.getItemAtPosition(key));\n                            if (!selected.isDirectory()) {\n                                uris.add(Uri.fromFile(selected));\n                            }\n                        }\n                    }\n                    Intent intent = new Intent();\n                    intent.setAction(Intent.ACTION_SEND_MULTIPLE);\n                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                    intent.setType(\"*/*\");\n                    intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);\n                    mode.finish();\n                    mActivity.startActivity(Intent.createChooser(intent,\n                            mActivity.getString(R.string.share)));\n                    return true;\n                case R.id.actionshortcut:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    for (String a : files) {\n                        SimpleUtils.createShortcut(mActivity, a);\n                    }\n                    mode.finish();\n                    return true;\n                case R.id.actionbookmark:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\n                            files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    BookmarksAdapter mAdapter = BrowserActivity.getBookmarksAdapter();\n                    for (String a : files) {\n                        mAdapter.createBookmark(new File(a));\n                    }\n                    mode.finish();\n                    return true;\n                case R.id.actionzip:\n                    for (int i = 0; i < checkedItemSize; i++) {\n                        final int key = items.keyAt(i);\n                        if (items.get(key)) {\nNext line of code:\n",
        "prediction": "                           files[++index] = (String) mListView.getItemAtPosition(key);\n                        }\n                    }\n                    final DialogFragment dialog2 = ZipFilesDialog.instantiate(files);\n                    mode.finish();\n                    dialog2.show",
        "gold": [
            "                            files[++index] = (String) mListView.getItemAtPosition(key);"
        ],
        "time": 3.3587751388549805
    },
    "24": {
        "origin_prompt": "Please complete the code given below. \npackage protocol.xmpp;\nimport android.util.Log;;\nimport protocol.Contact;\nimport protocol.Protocol;\nimport ru.sawim.comm.Util;\nimport ru.sawim.io.RosterStorage;\nimport ru.sawim.listener.OnMoreMessagesLoaded;\nimport ru.sawim.roster.RosterHelper;\nimport java.util.HashSet;\nimport java.util.concurrent.ConcurrentHashMap;\n/**\n * Created by gerc on 05.03.2015.\n */\npublic class MessageArchiveManagement {\n    private static final long MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000;\n    public static final long MAX_CATCHUP = MILLISECONDS_IN_DAY * 7;\n    public static final long MAX_MESSAGES = 20;\n    private final HashSet<Query> queries = new HashSet<>();\n    private String getQueryMessageArchiveManagement(Contact contact, Query query) {\n        XmlNode xmlNode = new XmlNode(XmlConstants.S_IQ);\n        xmlNode.putAttribute(XmlConstants.S_TYPE, XmlConstants.S_SET);\n        if (contact != null && contact.isConference()) {\n            xmlNode.putAttribute(XmlConstants.S_TO, Util.xmlEscape(contact.getUserId()));\n        }\n        xmlNode.putAttribute(XmlNode.S_ID, XmppConnection.generateId());\n        XmlNode queryNode = new XmlNode(XmlConstants.S_QUERY);\n        queryNode.putAttribute(XmlNode.S_XMLNS, \"urn:xmpp:mam:0\");\n        queryNode.putAttribute(\"queryid\", query.queryId);\n        XmlNode xNode = new XmlNode(\"x\");\n        xNode.putAttribute(XmlNode.S_XMLNS, \"jabber:x:data\");\n        xNode.putAttribute(\"type\", \"submit\");\n        XmlNode formTypeNode = new XmlNode(\"field\");\n        formTypeNode.putAttribute(\"var\", \"FORM_TYPE\");\n        formTypeNode.putAttribute(\"type\", \"hidden\");\n        formTypeNode.setValue(\"value\", \"urn:xmpp:mam:0\");\n        xNode.addNode(formTypeNode);\n    /*    if (query.getStart() > 0) {\n            XmlNode startNode = new XmlNode(\"field\");\n            startNode.putAttribute(\"var\", \"start\");\n            startNode.setValue(\"value\", Util.getTimestamp(query.getStart()));\n            xNode.addNode(startNode);\n        }\n        if (query.getEnd() > 0) {\n            XmlNode endNode = new XmlNode(\"field\");\n            endNode.putAttribute(\"var\", \"end\");\n            endNode.setValue(\"value\", Util.getTimestamp(query.getEnd()));\n            xNode.addNode(endNode);\n        }*/\n        if (query.withJid != null && contact != null && !contact.isConference()) {\n            XmlNode withNode = new XmlNode(\"field\");\n            withNode.putAttribute(\"var\", \"with\");\n            withNode.setValue(\"value\", query.withJid);\n            xNode.addNode(withNode);\n        }\n        XmlNode setNode = XmlNode.addXmlns(\"set\", \"http://jabber.org/protocol/rsm\");\n        setNode.setValue(\"max\", String.valueOf(MAX_MESSAGES));\n        if (query.getPagingOrder() == PagingOrder.REVERSE) {\n            setNode.setValue(\"before\", query.getReference());\n        } else {\n            setNode.setValue(\"after\", query.getReference());\n        }\n        queryNode.addNode(setNode);\n        queryNode.addNode(xNode);\n        xmlNode.addNode(queryNode);\n        return xmlNode.toString();\n    }\n    private void queryMessageArchiveManagement(XmppConnection connection, Query query) {\n        Contact contact = null;\n        if (query.getWith() != null) {\n            contact = connection.getProtocol().getItemByUID(query.getWith());\n        }\n        connection.putPacketIntoQueue(getQueryMessageArchiveManagement(contact, query));\n    }\n    public void catchup(XmppConnection connection) {\n        long startCatchup = getLastMessageTransmitted(connection);\n        long endCatchup = connection.getLastSessionEstablished();\n        if (startCatchup == 0) {\n            return;\n        } else {\n            ConcurrentHashMap<String, Contact> contacts = connection.getProtocol().getContactItems();\n            for (Contact contact : contacts.values()) {\n                queryReverse(connection, contact, startCatchup);\n            }\n        }\n        final Query query = new Query(connection.getXmpp().getUserId(), null, startCatchup, endCatchup);\n        queries.add(query);\n        queryMessageArchiveManagement(connection, query);\n    }\n    private long getLastMessageTransmitted(XmppConnection connection) {\n        long timestamp = 0;\n        for (Contact contact : connection.getProtocol().getContactItems().values()) {\n            long lastMessageTransmitted = contact.getLastMessageTransmitted();\n            if (lastMessageTransmitted > timestamp) {\n                timestamp = lastMessageTransmitted;\n            }\n        }\n        return timestamp;\n    }\n    public Query queryReverse(XmppConnection connection, final Contact contact) {\n        return queryReverse(connection, contact, connection.getLastSessionEstablished());\n    }\n    public Query queryReverse(XmppConnection connection, final Contact contact, long end) {\n        long lastMessageTransmitted = contact.getLastMessageTransmitted();\n        return queryReverse(connection, contact, lastMessageTransmitted, end);\n    }\n    public Query queryReverse(XmppConnection connection, Contact contact, long start, long end) {\n        synchronized (queries) {\n            if (start > end) {\n                return null;\n            }\n            final Query query = new Query(connection.getXmpp().getUserId(), contact.getUserId(),\n                    start, end, PagingOrder.REVERSE);\n            queries.add(query);\n            queryMessageArchiveManagement(connection, query);\n            return query;\n        }\n    }\n    public Query prev(XmppConnection connection, Contact contact) {\n        synchronized (queries) {\n            Query query = new Query(connection.getXmpp().getUserId(), contact.getUserId(), 0, 0)\n                        .prev(contact.firstServerMsgId);\n            queries.add(query);\n            queryMessageArchiveManagement(connection, query);\n            return query;\n        }\n    }\n    public void processFin(XmppConnection connection, XmlNode fin) {\n        Query query = findQuery(fin.getAttribute(\"queryid\"));\n        if (query == null) {\n            return;\n        }\n        boolean complete = XmppConnection.isTrue(fin.getAttribute(\"complete\"));\n        XmlNode set = fin.getFirstNode(\"set\", \"http://jabber.org/protocol/rsm\");\n        String last = set == null ? null : set.getFirstNodeValue(\"last\");\n        String first = set == null ? null : set.getFirstNodeValue(\"first\");\n        String relevant = query.getPagingOrder() == PagingOrder.NORMAL ? last : first;\n        String count = set == null ? null : set.getFirstNodeValue(\"count\");\n        if (count != null) {\n            query.setAllMessageCount(Integer.valueOf(count));\n        }\n        if (relevant != null) {\n            Contact contact = null;\n            if (query.getWith() != null) {\n                contact = connection.getProtocol().getItemByUID(query.getWith());\n            }\n            contact.firstServerMsgId = first;\n            connection.getXmpp().getStorage().updateFirstServerMsgId(contact);\n        }\n        if (complete || relevant == null) {\n            finalizeQuery(connection.getProtocol(), query);\n            Log.d(\"MAM\", \"finished mam after \" + query.getAllMessagesCount() + \" messages\");\n        } else {\n            final Query nextQuery;\n            if (query.getPagingOrder() == PagingOrder.NORMAL) {\n                nextQuery = query.next(last);\n            } else {\n                nextQuery = query.prev(first);\n            }\n        //    queryMessageArchiveManagement(connection, nextQuery);\n            finalizeQuery(connection.getProtocol(), query);\n            synchronized (queries) {\n            //    queries.add(nextQuery);\n            }\n        }\n    }\n    public boolean queryInProgress(Contact contact, OnMoreMessagesLoaded moreMessagesLoadedListener) {\n        synchronized (queries) {\n            for (Query query : queries) {\n                if (query.getWith().equals(contact.getUserId())) {\n                    if (query.onMoreMessagesLoaded == null && moreMessagesLoadedListener != null) {\n                        query.setOnMoreMessagesLoaded(moreMessagesLoadedListener);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    private void finalizeQuery(Protocol protocol, Query query) {\n        synchronized (queries) {\n            queries.remove(query);\n        }\n        Contact contact = null;\n        if (query.getWith() != null) {\n            contact = protocol.getItemByUID(query.getWith());\n        }\n        if (contact != null) {\nNext line of code:\n",
        "prediction": "           contact.firstServerMsgId = query.getLastMessageTransmitted();\n            protocol.getStorage().updateFirstServerMsgId(contact);\n        }\n    }\n    public void onMoreMessagesLoaded(Query query, int count) {\n        synchronized (queries) {\n",
        "gold": [
            "            if (contact.setLastMessageTransmitted(query.getEnd())) {"
        ],
        "time": 3.3628733158111572
    },
    "25": {
        "origin_prompt": "Please complete the code given below. \n//    <TMSEG: Prediction of Transmembrane Helices in Proteins.>\n//    Copyright (C) 2014  Michael Bernhofer\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n//\n//    This program is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    You should have received a copy of the GNU General Public License\n//    along with this program.  If not, see <http://www.gnu.org/licenses/>.\npackage predictors;\nimport io.ModelHandler;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport util.ErrorUtils;\nimport util.Globals;\nimport util.Mappings;\nimport weka.classifiers.Classifier;\nimport weka.classifiers.trees.RandomForest;\nimport weka.core.Attribute;\nimport weka.core.Instance;\nimport weka.core.Instances;\nimport weka.core.SparseInstance;\nimport weka.core.converters.ArffSaver;\nimport data.Protein;\nimport data.Pssm;\n/**\n * Class to predict transmembrane residues within a protein.\n */\npublic class HelixIndexer {\n\t\n\t\n\tpublic static final int \t\tindexNotTmh \t= 0;\n\tpublic static final int \t\tindexTmh \t\t= 1;\n\tpublic static final int \t\tindexSignal \t= 2;\n\t\n\tprivate ArrayList<Attribute> \tattributes \t\t= null;\n\tprivate Instances \t\t\t\tdataset \t\t= null;\n\tprivate Classifier \t\t\t\tclassifier \t\t= null;\n\tprivate boolean \t\t\t\tisTrained \t\t= false;\n\t\n\tprivate double[] \t\t\t\tglobalConsAa \t= null;\n\tprivate double[] \t\t\t\tglobalNonConsAa = null;\n\t\n\t\n\tpublic HelixIndexer()\n\t{\n\t\tthis.buildAttributes();\n\t\tthis.initialize();\n\t}\n\t\n\t\n\t/**\n\t * Initializes the attributes list for the Weka arff-format.\n\t */\n\tprivate void buildAttributes()\n\t{\n\t\tthis.attributes = new ArrayList<Attribute>();\n\t\t\n\t\tfor (int i = 1; i <= ((2*Globals.INDEXER_WINDOW_SIZE)+1); ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 21; ++j)\n\t\t\t{\n\t\t\t\tthis.attributes.add(new Attribute(Mappings.intToAa(j)+\"_\"+i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.attributes.add(new Attribute(\"conserved_hydrophobicity\"));\n\t\tthis.attributes.add(new Attribute(\"non-conserved_hydrophobicity\"));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"conserved_hydrophobic\"));\n\t\tthis.attributes.add(new Attribute(\"non-conserved_hydrophobic\"));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"conserved_pos_charged\"));\n\t\tthis.attributes.add(new Attribute(\"non-conserved_pos_charged\"));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"conserved_neg_charged\"));\n\t\tthis.attributes.add(new Attribute(\"non-conserved_neg_charged\"));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"conserved_polar\"));\n\t\tthis.attributes.add(new Attribute(\"non-conserved_polar\"));\n\t\t\n\t\tArrayList<String> lengths = new ArrayList<String>();\n\t\t\n\t\tlengths.add(String.valueOf(\"0\"));\n\t\tlengths.add(String.valueOf(\"1\"));\n\t\tlengths.add(String.valueOf(\"2\"));\n\t\tlengths.add(String.valueOf(\"3\"));\n\t\tlengths.add(String.valueOf(\"4\"));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"n-term_distance\", lengths));\n\t\tthis.attributes.add(new Attribute(\"c-term_distance\", lengths));\n\t\tthis.attributes.add(new Attribute(\"global_length\", lengths));\n\t\t\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t{\n\t\t\tthis.attributes.add(new Attribute(\"global_conserved_\"+Mappings.intToAa(j)));\n\t\t\tthis.attributes.add(new Attribute(\"global_non-conserved_\"+Mappings.intToAa(j)));\n\t\t}\n\t\t\n\t\tArrayList<String> classes = new ArrayList<String>();\n\t\t\n\t\tclasses.add(String.valueOf(HelixIndexer.indexNotTmh));\n\t\tclasses.add(String.valueOf(HelixIndexer.indexTmh));\n\t\tclasses.add(String.valueOf(HelixIndexer.indexSignal));\n\t\t\n\t\tthis.attributes.add(new Attribute(\"class\", classes));\n\t}\n\t\n\t\n\t/**\n\t * Initializes the classifier and dataset.\n\t */\n\tpublic void initialize()\n\t{\n\t\tthis.isTrained \t= false;\n\t\tthis.classifier = null;\n\t\tthis.dataset \t= new Instances(\"HelixIndexer Model\", this.attributes, 0);\n\t\t\n\t\tthis.dataset.setClassIndex(this.attributes.size()-1);\n\t}\n\t\n\t\n\t/**\n\t * Inputs a given list of proteins for the training data.\n\t * \n\t * @param proteins\n\t */\n\tpublic void input(List<Protein> proteins)\n\t{\n\t\tfor (Protein protein : proteins)\n\t\t{\n\t\t\tthis.input(protein);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Inputs a given protein for the training data.\n\t * \n\t * @param protein\n\t */\n\tpublic void input(Protein protein)\n\t{\n\t\tif (protein == null) \t\t\t\t{return;}\n\t\tif (protein.getStructure() == null) {return;}\n\t\tif (protein.getPssm() == null) \t\t{return;}\n\t\t\n\t\tPssm \tpssm \t\t= protein.getPssm();\n\t\tint \tlength \t\t= pssm.getLength();\n\t\tchar[] \tstructure \t= protein.getStructure();\n\t\t\n\t\tif (pssm.getLength() != structure.length)\n\t\t{\n\t\t\tErrorUtils.printError(HelixIndexer.class, \"PSSM and structure annotation length do not match for \" + protein.getName(), null);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.globalComposition(pssm);\n\t\t\n\t\tfor (int i = 0; i < length; ++i)\n\t\t{\n\t\t\tif (Mappings.ssToInt(structure[i]) != Mappings.indexUnknown)\n\t\t\t{\n\t\t\t\tthis.addWindowToDatabase(pssm, i, structure);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Predicts transmembrane residues for a given list of proteins.\n\t * \n\t * @param proteins\n\t */\n\tpublic void predict(List<Protein> proteins)\n\t{\n\t\tfor (Protein protein : proteins)\n\t\t{\n\t\t\tthis.predict(protein);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Predicts transmembrane residues for a given protein.\n\t * \n\t * @param protein\n\t */\n\tpublic void predict(Protein protein)\n\t{\n\t\tif (protein == null || protein.getPssm() == null) {return;}\n\t\t\n\t\tPssm \t\tpssm \t\t= protein.getPssm();\n\t\tint \t\tlength \t\t= pssm.getLength();\n\t\tint[] \t\tscoresSol \t= new int[length];\nNext line of code:\n",
        "prediction": "\t\tint[]\t\tscoresNeg \t= new int[length];\nNext line of code:\n\t\tint[]\t\tscoresPos \t= new int[length];\nNext line of code:\n\t\tint[]\t\tscoresTmh \t= new",
        "gold": [
            "\t\tint[] \t\tscoresTmh \t= new int[length];"
        ],
        "time": 3.3618075847625732
    }
}